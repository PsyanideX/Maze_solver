{"version":3,"file":"./bundle.js","mappings":"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","sources":["webpack://maze/./node_modules/rxjs/src/index.ts","webpack://maze/./node_modules/rxjs/src/internal/AsyncSubject.ts","webpack://maze/./node_modules/rxjs/src/internal/BehaviorSubject.ts","webpack://maze/./node_modules/rxjs/src/internal/Notification.ts","webpack://maze/./node_modules/rxjs/src/internal/NotificationFactories.ts","webpack://maze/./node_modules/rxjs/src/internal/Observable.ts","webpack://maze/./node_modules/rxjs/src/internal/ReplaySubject.ts","webpack://maze/./node_modules/rxjs/src/internal/Scheduler.ts","webpack://maze/./node_modules/rxjs/src/internal/Subject.ts","webpack://maze/./node_modules/rxjs/src/internal/Subscriber.ts","webpack://maze/./node_modules/rxjs/src/internal/Subscription.ts","webpack://maze/./node_modules/rxjs/src/internal/config.ts","webpack://maze/./node_modules/rxjs/src/internal/firstValueFrom.ts","webpack://maze/./node_modules/rxjs/src/internal/lastValueFrom.ts","webpack://maze/./node_modules/rxjs/src/internal/observable/ConnectableObservable.ts","webpack://maze/./node_modules/rxjs/src/internal/observable/bindCallback.ts","webpack://maze/./node_modules/rxjs/src/internal/observable/bindCallbackInternals.ts","webpack://maze/./node_modules/rxjs/src/internal/observable/bindNodeCallback.ts","webpack://maze/./node_modules/rxjs/src/internal/observable/combineLatest.ts","webpack://maze/./node_modules/rxjs/src/internal/observable/concat.ts","webpack://maze/./node_modules/rxjs/src/internal/observable/connectable.ts","webpack://maze/./node_modules/rxjs/src/internal/observable/defer.ts","webpack://maze/./node_modules/rxjs/src/internal/observable/dom/animationFrames.ts","webpack://maze/./node_modules/rxjs/src/internal/observable/empty.ts","webpack://maze/./node_modules/rxjs/src/internal/observable/forkJoin.ts","webpack://maze/./node_modules/rxjs/src/internal/observable/from.ts","webpack://maze/./node_modules/rxjs/src/internal/observable/fromEvent.ts","webpack://maze/./node_modules/rxjs/src/internal/observable/fromEventPattern.ts","webpack://maze/./node_modules/rxjs/src/internal/observable/fromSubscribable.ts","webpack://maze/./node_modules/rxjs/src/internal/observable/generate.ts","webpack://maze/./node_modules/rxjs/src/internal/observable/iif.ts","webpack://maze/./node_modules/rxjs/src/internal/observable/innerFrom.ts","webpack://maze/./node_modules/rxjs/src/internal/observable/interval.ts","webpack://maze/./node_modules/rxjs/src/internal/observable/merge.ts","webpack://maze/./node_modules/rxjs/src/internal/observable/never.ts","webpack://maze/./node_modules/rxjs/src/internal/observable/of.ts","webpack://maze/./node_modules/rxjs/src/internal/observable/onErrorResumeNext.ts","webpack://maze/./node_modules/rxjs/src/internal/observable/pairs.ts","webpack://maze/./node_modules/rxjs/src/internal/observable/partition.ts","webpack://maze/./node_modules/rxjs/src/internal/observable/race.ts","webpack://maze/./node_modules/rxjs/src/internal/observable/range.ts","webpack://maze/./node_modules/rxjs/src/internal/observable/throwError.ts","webpack://maze/./node_modules/rxjs/src/internal/observable/timer.ts","webpack://maze/./node_modules/rxjs/src/internal/observable/using.ts","webpack://maze/./node_modules/rxjs/src/internal/observable/zip.ts","webpack://maze/./node_modules/rxjs/src/internal/operators/OperatorSubscriber.ts","webpack://maze/./node_modules/rxjs/src/internal/operators/audit.ts","webpack://maze/./node_modules/rxjs/src/internal/operators/auditTime.ts","webpack://maze/./node_modules/rxjs/src/internal/operators/buffer.ts","webpack://maze/./node_modules/rxjs/src/internal/operators/bufferCount.ts","webpack://maze/./node_modules/rxjs/src/internal/operators/bufferTime.ts","webpack://maze/./node_modules/rxjs/src/internal/operators/bufferToggle.ts","webpack://maze/./node_modules/rxjs/src/internal/operators/bufferWhen.ts","webpack://maze/./node_modules/rxjs/src/internal/operators/catchError.ts","webpack://maze/./node_modules/rxjs/src/internal/operators/combineAll.ts","webpack://maze/./node_modules/rxjs/src/internal/operators/combineLatest.ts","webpack://maze/./node_modules/rxjs/src/internal/operators/combineLatestAll.ts","webpack://maze/./node_modules/rxjs/src/internal/operators/combineLatestWith.ts","webpack://maze/./node_modules/rxjs/src/internal/operators/concat.ts","webpack://maze/./node_modules/rxjs/src/internal/operators/concatAll.ts","webpack://maze/./node_modules/rxjs/src/internal/operators/concatMap.ts","webpack://maze/./node_modules/rxjs/src/internal/operators/concatMapTo.ts","webpack://maze/./node_modules/rxjs/src/internal/operators/concatWith.ts","webpack://maze/./node_modules/rxjs/src/internal/operators/connect.ts","webpack://maze/./node_modules/rxjs/src/internal/operators/count.ts","webpack://maze/./node_modules/rxjs/src/internal/operators/debounce.ts","webpack://maze/./node_modules/rxjs/src/internal/operators/debounceTime.ts","webpack://maze/./node_modules/rxjs/src/internal/operators/defaultIfEmpty.ts","webpack://maze/./node_modules/rxjs/src/internal/operators/delay.ts","webpack://maze/./node_modules/rxjs/src/internal/operators/delayWhen.ts","webpack://maze/./node_modules/rxjs/src/internal/operators/dematerialize.ts","webpack://maze/./node_modules/rxjs/src/internal/operators/distinct.ts","webpack://maze/./node_modules/rxjs/src/internal/operators/distinctUntilChanged.ts","webpack://maze/./node_modules/rxjs/src/internal/operators/distinctUntilKeyChanged.ts","webpack://maze/./node_modules/rxjs/src/internal/operators/elementAt.ts","webpack://maze/./node_modules/rxjs/src/internal/operators/endWith.ts","webpack://maze/./node_modules/rxjs/src/internal/operators/every.ts","webpack://maze/./node_modules/rxjs/src/internal/operators/exhaust.ts","webpack://maze/./node_modules/rxjs/src/internal/operators/exhaustAll.ts","webpack://maze/./node_modules/rxjs/src/internal/operators/exhaustMap.ts","webpack://maze/./node_modules/rxjs/src/internal/operators/expand.ts","webpack://maze/./node_modules/rxjs/src/internal/operators/filter.ts","webpack://maze/./node_modules/rxjs/src/internal/operators/finalize.ts","webpack://maze/./node_modules/rxjs/src/internal/operators/find.ts","webpack://maze/./node_modules/rxjs/src/internal/operators/findIndex.ts","webpack://maze/./node_modules/rxjs/src/internal/operators/first.ts","webpack://maze/./node_modules/rxjs/src/internal/operators/flatMap.ts","webpack://maze/./node_modules/rxjs/src/internal/operators/groupBy.ts","webpack://maze/./node_modules/rxjs/src/internal/operators/ignoreElements.ts","webpack://maze/./node_modules/rxjs/src/internal/operators/isEmpty.ts","webpack://maze/./node_modules/rxjs/src/internal/operators/joinAllInternals.ts","webpack://maze/./node_modules/rxjs/src/internal/operators/last.ts","webpack://maze/./node_modules/rxjs/src/internal/operators/map.ts","webpack://maze/./node_modules/rxjs/src/internal/operators/mapTo.ts","webpack://maze/./node_modules/rxjs/src/internal/operators/materialize.ts","webpack://maze/./node_modules/rxjs/src/internal/operators/max.ts","webpack://maze/./node_modules/rxjs/src/internal/operators/merge.ts","webpack://maze/./node_modules/rxjs/src/internal/operators/mergeAll.ts","webpack://maze/./node_modules/rxjs/src/internal/operators/mergeInternals.ts","webpack://maze/./node_modules/rxjs/src/internal/operators/mergeMap.ts","webpack://maze/./node_modules/rxjs/src/internal/operators/mergeMapTo.ts","webpack://maze/./node_modules/rxjs/src/internal/operators/mergeScan.ts","webpack://maze/./node_modules/rxjs/src/internal/operators/mergeWith.ts","webpack://maze/./node_modules/rxjs/src/internal/operators/min.ts","webpack://maze/./node_modules/rxjs/src/internal/operators/multicast.ts","webpack://maze/./node_modules/rxjs/src/internal/operators/observeOn.ts","webpack://maze/./node_modules/rxjs/src/internal/operators/onErrorResumeNextWith.ts","webpack://maze/./node_modules/rxjs/src/internal/operators/pairwise.ts","webpack://maze/./node_modules/rxjs/src/internal/operators/pluck.ts","webpack://maze/./node_modules/rxjs/src/internal/operators/publish.ts","webpack://maze/./node_modules/rxjs/src/internal/operators/publishBehavior.ts","webpack://maze/./node_modules/rxjs/src/internal/operators/publishLast.ts","webpack://maze/./node_modules/rxjs/src/internal/operators/publishReplay.ts","webpack://maze/./node_modules/rxjs/src/internal/operators/raceWith.ts","webpack://maze/./node_modules/rxjs/src/internal/operators/reduce.ts","webpack://maze/./node_modules/rxjs/src/internal/operators/refCount.ts","webpack://maze/./node_modules/rxjs/src/internal/operators/repeat.ts","webpack://maze/./node_modules/rxjs/src/internal/operators/repeatWhen.ts","webpack://maze/./node_modules/rxjs/src/internal/operators/retry.ts","webpack://maze/./node_modules/rxjs/src/internal/operators/retryWhen.ts","webpack://maze/./node_modules/rxjs/src/internal/operators/sample.ts","webpack://maze/./node_modules/rxjs/src/internal/operators/sampleTime.ts","webpack://maze/./node_modules/rxjs/src/internal/operators/scan.ts","webpack://maze/./node_modules/rxjs/src/internal/operators/scanInternals.ts","webpack://maze/./node_modules/rxjs/src/internal/operators/sequenceEqual.ts","webpack://maze/./node_modules/rxjs/src/internal/operators/share.ts","webpack://maze/./node_modules/rxjs/src/internal/operators/shareReplay.ts","webpack://maze/./node_modules/rxjs/src/internal/operators/single.ts","webpack://maze/./node_modules/rxjs/src/internal/operators/skip.ts","webpack://maze/./node_modules/rxjs/src/internal/operators/skipLast.ts","webpack://maze/./node_modules/rxjs/src/internal/operators/skipUntil.ts","webpack://maze/./node_modules/rxjs/src/internal/operators/skipWhile.ts","webpack://maze/./node_modules/rxjs/src/internal/operators/startWith.ts","webpack://maze/./node_modules/rxjs/src/internal/operators/subscribeOn.ts","webpack://maze/./node_modules/rxjs/src/internal/operators/switchAll.ts","webpack://maze/./node_modules/rxjs/src/internal/operators/switchMap.ts","webpack://maze/./node_modules/rxjs/src/internal/operators/switchMapTo.ts","webpack://maze/./node_modules/rxjs/src/internal/operators/switchScan.ts","webpack://maze/./node_modules/rxjs/src/internal/operators/take.ts","webpack://maze/./node_modules/rxjs/src/internal/operators/takeLast.ts","webpack://maze/./node_modules/rxjs/src/internal/operators/takeUntil.ts","webpack://maze/./node_modules/rxjs/src/internal/operators/takeWhile.ts","webpack://maze/./node_modules/rxjs/src/internal/operators/tap.ts","webpack://maze/./node_modules/rxjs/src/internal/operators/throttle.ts","webpack://maze/./node_modules/rxjs/src/internal/operators/throttleTime.ts","webpack://maze/./node_modules/rxjs/src/internal/operators/throwIfEmpty.ts","webpack://maze/./node_modules/rxjs/src/internal/operators/timeInterval.ts","webpack://maze/./node_modules/rxjs/src/internal/operators/timeout.ts","webpack://maze/./node_modules/rxjs/src/internal/operators/timeoutWith.ts","webpack://maze/./node_modules/rxjs/src/internal/operators/timestamp.ts","webpack://maze/./node_modules/rxjs/src/internal/operators/toArray.ts","webpack://maze/./node_modules/rxjs/src/internal/operators/window.ts","webpack://maze/./node_modules/rxjs/src/internal/operators/windowCount.ts","webpack://maze/./node_modules/rxjs/src/internal/operators/windowTime.ts","webpack://maze/./node_modules/rxjs/src/internal/operators/windowToggle.ts","webpack://maze/./node_modules/rxjs/src/internal/operators/windowWhen.ts","webpack://maze/./node_modules/rxjs/src/internal/operators/withLatestFrom.ts","webpack://maze/./node_modules/rxjs/src/internal/operators/zip.ts","webpack://maze/./node_modules/rxjs/src/internal/operators/zipAll.ts","webpack://maze/./node_modules/rxjs/src/internal/operators/zipWith.ts","webpack://maze/./node_modules/rxjs/src/internal/scheduled/scheduleArray.ts","webpack://maze/./node_modules/rxjs/src/internal/scheduled/scheduleAsyncIterable.ts","webpack://maze/./node_modules/rxjs/src/internal/scheduled/scheduleIterable.ts","webpack://maze/./node_modules/rxjs/src/internal/scheduled/scheduleObservable.ts","webpack://maze/./node_modules/rxjs/src/internal/scheduled/schedulePromise.ts","webpack://maze/./node_modules/rxjs/src/internal/scheduled/scheduleReadableStreamLike.ts","webpack://maze/./node_modules/rxjs/src/internal/scheduled/scheduled.ts","webpack://maze/./node_modules/rxjs/src/internal/scheduler/Action.ts","webpack://maze/./node_modules/rxjs/src/internal/scheduler/AnimationFrameAction.ts","webpack://maze/./node_modules/rxjs/src/internal/scheduler/AnimationFrameScheduler.ts","webpack://maze/./node_modules/rxjs/src/internal/scheduler/AsapAction.ts","webpack://maze/./node_modules/rxjs/src/internal/scheduler/AsapScheduler.ts","webpack://maze/./node_modules/rxjs/src/internal/scheduler/AsyncAction.ts","webpack://maze/./node_modules/rxjs/src/internal/scheduler/AsyncScheduler.ts","webpack://maze/./node_modules/rxjs/src/internal/scheduler/QueueAction.ts","webpack://maze/./node_modules/rxjs/src/internal/scheduler/QueueScheduler.ts","webpack://maze/./node_modules/rxjs/src/internal/scheduler/VirtualTimeScheduler.ts","webpack://maze/./node_modules/rxjs/src/internal/scheduler/animationFrame.ts","webpack://maze/./node_modules/rxjs/src/internal/scheduler/animationFrameProvider.ts","webpack://maze/./node_modules/rxjs/src/internal/scheduler/asap.ts","webpack://maze/./node_modules/rxjs/src/internal/scheduler/async.ts","webpack://maze/./node_modules/rxjs/src/internal/scheduler/dateTimestampProvider.ts","webpack://maze/./node_modules/rxjs/src/internal/scheduler/immediateProvider.ts","webpack://maze/./node_modules/rxjs/src/internal/scheduler/intervalProvider.ts","webpack://maze/./node_modules/rxjs/src/internal/scheduler/performanceTimestampProvider.ts","webpack://maze/./node_modules/rxjs/src/internal/scheduler/queue.ts","webpack://maze/./node_modules/rxjs/src/internal/scheduler/timeoutProvider.ts","webpack://maze/./node_modules/rxjs/src/internal/symbol/iterator.ts","webpack://maze/./node_modules/rxjs/src/internal/symbol/observable.ts","webpack://maze/./node_modules/rxjs/src/internal/util/ArgumentOutOfRangeError.ts","webpack://maze/./node_modules/rxjs/src/internal/util/EmptyError.ts","webpack://maze/./node_modules/rxjs/src/internal/util/Immediate.ts","webpack://maze/./node_modules/rxjs/src/internal/util/NotFoundError.ts","webpack://maze/./node_modules/rxjs/src/internal/util/ObjectUnsubscribedError.ts","webpack://maze/./node_modules/rxjs/src/internal/util/SequenceError.ts","webpack://maze/./node_modules/rxjs/src/internal/util/UnsubscriptionError.ts","webpack://maze/./node_modules/rxjs/src/internal/util/args.ts","webpack://maze/./node_modules/rxjs/src/internal/util/argsArgArrayOrObject.ts","webpack://maze/./node_modules/rxjs/src/internal/util/argsOrArgArray.ts","webpack://maze/./node_modules/rxjs/src/internal/util/arrRemove.ts","webpack://maze/./node_modules/rxjs/src/internal/util/createErrorClass.ts","webpack://maze/./node_modules/rxjs/src/internal/util/createObject.ts","webpack://maze/./node_modules/rxjs/src/internal/util/errorContext.ts","webpack://maze/./node_modules/rxjs/src/internal/util/executeSchedule.ts","webpack://maze/./node_modules/rxjs/src/internal/util/identity.ts","webpack://maze/./node_modules/rxjs/src/internal/util/isArrayLike.ts","webpack://maze/./node_modules/rxjs/src/internal/util/isAsyncIterable.ts","webpack://maze/./node_modules/rxjs/src/internal/util/isDate.ts","webpack://maze/./node_modules/rxjs/src/internal/util/isFunction.ts","webpack://maze/./node_modules/rxjs/src/internal/util/isInteropObservable.ts","webpack://maze/./node_modules/rxjs/src/internal/util/isIterable.ts","webpack://maze/./node_modules/rxjs/src/internal/util/isObservable.ts","webpack://maze/./node_modules/rxjs/src/internal/util/isPromise.ts","webpack://maze/./node_modules/rxjs/src/internal/util/isReadableStreamLike.ts","webpack://maze/./node_modules/rxjs/src/internal/util/isScheduler.ts","webpack://maze/./node_modules/rxjs/src/internal/util/lift.ts","webpack://maze/./node_modules/rxjs/src/internal/util/mapOneOrManyArgs.ts","webpack://maze/./node_modules/rxjs/src/internal/util/noop.ts","webpack://maze/./node_modules/rxjs/src/internal/util/not.ts","webpack://maze/./node_modules/rxjs/src/internal/util/pipe.ts","webpack://maze/./node_modules/rxjs/src/internal/util/reportUnhandledError.ts","webpack://maze/./node_modules/rxjs/src/internal/util/throwUnobservableError.ts","webpack://maze/./src/common.ts","webpack://maze/./src/conversor.ts","webpack://maze/./src/init.ts","webpack://maze/./src/maze_generators.ts","webpack://maze/./src/maze_solvers.ts","webpack://maze/./src/properties.ts","webpack://maze/webpack/bootstrap","webpack://maze/./src/index.ts"],"sourcesContent":["//////////////////////////////////////////////////////////\n// Here we need to reference our other deep imports\n// so VS code will figure out where they are\n// see conversation here:\n// https://github.com/microsoft/TypeScript/issues/43034\n//////////////////////////////////////////////////////////\n\n// tslint:disable: no-reference\n// It's tempting to add references to all of the deep-import locations, but\n// adding references to those that require DOM types breaks Node projects.\n/// <reference path=\"./operators/index.ts\" />\n/// <reference path=\"./testing/index.ts\" />\n// tslint:enable: no-reference\n\n/* Observable */\nexport { Observable } from './internal/Observable';\nexport { ConnectableObservable } from './internal/observable/ConnectableObservable';\nexport { GroupedObservable } from './internal/operators/groupBy';\nexport { Operator } from './internal/Operator';\nexport { observable } from './internal/symbol/observable';\nexport { animationFrames } from './internal/observable/dom/animationFrames';\n\n/* Subjects */\nexport { Subject } from './internal/Subject';\nexport { BehaviorSubject } from './internal/BehaviorSubject';\nexport { ReplaySubject } from './internal/ReplaySubject';\nexport { AsyncSubject } from './internal/AsyncSubject';\n\n/* Schedulers */\nexport { asap, asapScheduler } from './internal/scheduler/asap';\nexport { async, asyncScheduler } from './internal/scheduler/async';\nexport { queue, queueScheduler } from './internal/scheduler/queue';\nexport { animationFrame, animationFrameScheduler } from './internal/scheduler/animationFrame';\nexport { VirtualTimeScheduler, VirtualAction } from './internal/scheduler/VirtualTimeScheduler';\nexport { Scheduler } from './internal/Scheduler';\n\n/* Subscription */\nexport { Subscription } from './internal/Subscription';\nexport { Subscriber } from './internal/Subscriber';\n\n/* Notification */\nexport { Notification, NotificationKind } from './internal/Notification';\n\n/* Utils */\nexport { pipe } from './internal/util/pipe';\nexport { noop } from './internal/util/noop';\nexport { identity } from './internal/util/identity';\nexport { isObservable } from './internal/util/isObservable';\n\n/* Promise Conversion */\nexport { lastValueFrom } from './internal/lastValueFrom';\nexport { firstValueFrom } from './internal/firstValueFrom';\n\n/* Error types */\nexport { ArgumentOutOfRangeError } from './internal/util/ArgumentOutOfRangeError';\nexport { EmptyError } from './internal/util/EmptyError';\nexport { NotFoundError } from './internal/util/NotFoundError';\nexport { ObjectUnsubscribedError } from './internal/util/ObjectUnsubscribedError';\nexport { SequenceError } from './internal/util/SequenceError';\nexport { TimeoutError } from './internal/operators/timeout';\nexport { UnsubscriptionError } from './internal/util/UnsubscriptionError';\n\n/* Static observable creation exports */\nexport { bindCallback } from './internal/observable/bindCallback';\nexport { bindNodeCallback } from './internal/observable/bindNodeCallback';\nexport { combineLatest } from './internal/observable/combineLatest';\nexport { concat } from './internal/observable/concat';\nexport { connectable } from './internal/observable/connectable';\nexport { defer } from './internal/observable/defer';\nexport { empty } from './internal/observable/empty';\nexport { forkJoin } from './internal/observable/forkJoin';\nexport { from } from './internal/observable/from';\nexport { fromEvent } from './internal/observable/fromEvent';\nexport { fromEventPattern } from './internal/observable/fromEventPattern';\nexport { generate } from './internal/observable/generate';\nexport { iif } from './internal/observable/iif';\nexport { interval } from './internal/observable/interval';\nexport { merge } from './internal/observable/merge';\nexport { never } from './internal/observable/never';\nexport { of } from './internal/observable/of';\nexport { onErrorResumeNext } from './internal/observable/onErrorResumeNext';\nexport { pairs } from './internal/observable/pairs';\nexport { partition } from './internal/observable/partition';\nexport { race } from './internal/observable/race';\nexport { range } from './internal/observable/range';\nexport { throwError } from './internal/observable/throwError';\nexport { timer } from './internal/observable/timer';\nexport { using } from './internal/observable/using';\nexport { zip } from './internal/observable/zip';\nexport { scheduled } from './internal/scheduled/scheduled';\n\n/* Constants */\nexport { EMPTY } from './internal/observable/empty';\nexport { NEVER } from './internal/observable/never';\n\n/* Types */\nexport * from './internal/types';\n\n/* Config */\nexport { config, GlobalConfig } from './internal/config';\n\n/* Operators */\nexport { audit } from './internal/operators/audit';\nexport { auditTime } from './internal/operators/auditTime';\nexport { buffer } from './internal/operators/buffer';\nexport { bufferCount } from './internal/operators/bufferCount';\nexport { bufferTime } from './internal/operators/bufferTime';\nexport { bufferToggle } from './internal/operators/bufferToggle';\nexport { bufferWhen } from './internal/operators/bufferWhen';\nexport { catchError } from './internal/operators/catchError';\nexport { combineAll } from './internal/operators/combineAll';\nexport { combineLatestAll } from './internal/operators/combineLatestAll';\nexport { combineLatestWith } from './internal/operators/combineLatestWith';\nexport { concatAll } from './internal/operators/concatAll';\nexport { concatMap } from './internal/operators/concatMap';\nexport { concatMapTo } from './internal/operators/concatMapTo';\nexport { concatWith } from './internal/operators/concatWith';\nexport { connect, ConnectConfig } from './internal/operators/connect';\nexport { count } from './internal/operators/count';\nexport { debounce } from './internal/operators/debounce';\nexport { debounceTime } from './internal/operators/debounceTime';\nexport { defaultIfEmpty } from './internal/operators/defaultIfEmpty';\nexport { delay } from './internal/operators/delay';\nexport { delayWhen } from './internal/operators/delayWhen';\nexport { dematerialize } from './internal/operators/dematerialize';\nexport { distinct } from './internal/operators/distinct';\nexport { distinctUntilChanged } from './internal/operators/distinctUntilChanged';\nexport { distinctUntilKeyChanged } from './internal/operators/distinctUntilKeyChanged';\nexport { elementAt } from './internal/operators/elementAt';\nexport { endWith } from './internal/operators/endWith';\nexport { every } from './internal/operators/every';\nexport { exhaust } from './internal/operators/exhaust';\nexport { exhaustAll } from './internal/operators/exhaustAll';\nexport { exhaustMap } from './internal/operators/exhaustMap';\nexport { expand } from './internal/operators/expand';\nexport { filter } from './internal/operators/filter';\nexport { finalize } from './internal/operators/finalize';\nexport { find } from './internal/operators/find';\nexport { findIndex } from './internal/operators/findIndex';\nexport { first } from './internal/operators/first';\nexport { groupBy, BasicGroupByOptions, GroupByOptionsWithElement } from './internal/operators/groupBy';\nexport { ignoreElements } from './internal/operators/ignoreElements';\nexport { isEmpty } from './internal/operators/isEmpty';\nexport { last } from './internal/operators/last';\nexport { map } from './internal/operators/map';\nexport { mapTo } from './internal/operators/mapTo';\nexport { materialize } from './internal/operators/materialize';\nexport { max } from './internal/operators/max';\nexport { mergeAll } from './internal/operators/mergeAll';\nexport { flatMap } from './internal/operators/flatMap';\nexport { mergeMap } from './internal/operators/mergeMap';\nexport { mergeMapTo } from './internal/operators/mergeMapTo';\nexport { mergeScan } from './internal/operators/mergeScan';\nexport { mergeWith } from './internal/operators/mergeWith';\nexport { min } from './internal/operators/min';\nexport { multicast } from './internal/operators/multicast';\nexport { observeOn } from './internal/operators/observeOn';\nexport { onErrorResumeNextWith } from './internal/operators/onErrorResumeNextWith';\nexport { pairwise } from './internal/operators/pairwise';\nexport { pluck } from './internal/operators/pluck';\nexport { publish } from './internal/operators/publish';\nexport { publishBehavior } from './internal/operators/publishBehavior';\nexport { publishLast } from './internal/operators/publishLast';\nexport { publishReplay } from './internal/operators/publishReplay';\nexport { raceWith } from './internal/operators/raceWith';\nexport { reduce } from './internal/operators/reduce';\nexport { repeat, RepeatConfig } from './internal/operators/repeat';\nexport { repeatWhen } from './internal/operators/repeatWhen';\nexport { retry, RetryConfig } from './internal/operators/retry';\nexport { retryWhen } from './internal/operators/retryWhen';\nexport { refCount } from './internal/operators/refCount';\nexport { sample } from './internal/operators/sample';\nexport { sampleTime } from './internal/operators/sampleTime';\nexport { scan } from './internal/operators/scan';\nexport { sequenceEqual } from './internal/operators/sequenceEqual';\nexport { share, ShareConfig } from './internal/operators/share';\nexport { shareReplay, ShareReplayConfig } from './internal/operators/shareReplay';\nexport { single } from './internal/operators/single';\nexport { skip } from './internal/operators/skip';\nexport { skipLast } from './internal/operators/skipLast';\nexport { skipUntil } from './internal/operators/skipUntil';\nexport { skipWhile } from './internal/operators/skipWhile';\nexport { startWith } from './internal/operators/startWith';\nexport { subscribeOn } from './internal/operators/subscribeOn';\nexport { switchAll } from './internal/operators/switchAll';\nexport { switchMap } from './internal/operators/switchMap';\nexport { switchMapTo } from './internal/operators/switchMapTo';\nexport { switchScan } from './internal/operators/switchScan';\nexport { take } from './internal/operators/take';\nexport { takeLast } from './internal/operators/takeLast';\nexport { takeUntil } from './internal/operators/takeUntil';\nexport { takeWhile } from './internal/operators/takeWhile';\nexport { tap, TapObserver } from './internal/operators/tap';\nexport { throttle, ThrottleConfig } from './internal/operators/throttle';\nexport { throttleTime } from './internal/operators/throttleTime';\nexport { throwIfEmpty } from './internal/operators/throwIfEmpty';\nexport { timeInterval } from './internal/operators/timeInterval';\nexport { timeout, TimeoutConfig, TimeoutInfo } from './internal/operators/timeout';\nexport { timeoutWith } from './internal/operators/timeoutWith';\nexport { timestamp } from './internal/operators/timestamp';\nexport { toArray } from './internal/operators/toArray';\nexport { window } from './internal/operators/window';\nexport { windowCount } from './internal/operators/windowCount';\nexport { windowTime } from './internal/operators/windowTime';\nexport { windowToggle } from './internal/operators/windowToggle';\nexport { windowWhen } from './internal/operators/windowWhen';\nexport { withLatestFrom } from './internal/operators/withLatestFrom';\nexport { zipAll } from './internal/operators/zipAll';\nexport { zipWith } from './internal/operators/zipWith';\n","import { Subject } from './Subject';\nimport { Subscriber } from './Subscriber';\n\n/**\n * A variant of Subject that only emits a value when it completes. It will emit\n * its latest value to all its observers on completion.\n *\n * @class AsyncSubject<T>\n */\nexport class AsyncSubject<T> extends Subject<T> {\n  private _value: T | null = null;\n  private _hasValue = false;\n  private _isComplete = false;\n\n  /** @internal */\n  protected _checkFinalizedStatuses(subscriber: Subscriber<T>) {\n    const { hasError, _hasValue, _value, thrownError, isStopped, _isComplete } = this;\n    if (hasError) {\n      subscriber.error(thrownError);\n    } else if (isStopped || _isComplete) {\n      _hasValue && subscriber.next(_value!);\n      subscriber.complete();\n    }\n  }\n\n  next(value: T): void {\n    if (!this.isStopped) {\n      this._value = value;\n      this._hasValue = true;\n    }\n  }\n\n  complete(): void {\n    const { _hasValue, _value, _isComplete } = this;\n    if (!_isComplete) {\n      this._isComplete = true;\n      _hasValue && super.next(_value!);\n      super.complete();\n    }\n  }\n}\n","import { Subject } from './Subject';\nimport { Subscriber } from './Subscriber';\nimport { Subscription } from './Subscription';\n\n/**\n * A variant of Subject that requires an initial value and emits its current\n * value whenever it is subscribed to.\n *\n * @class BehaviorSubject<T>\n */\nexport class BehaviorSubject<T> extends Subject<T> {\n  constructor(private _value: T) {\n    super();\n  }\n\n  get value(): T {\n    return this.getValue();\n  }\n\n  /** @internal */\n  protected _subscribe(subscriber: Subscriber<T>): Subscription {\n    const subscription = super._subscribe(subscriber);\n    !subscription.closed && subscriber.next(this._value);\n    return subscription;\n  }\n\n  getValue(): T {\n    const { hasError, thrownError, _value } = this;\n    if (hasError) {\n      throw thrownError;\n    }\n    this._throwIfClosed();\n    return _value;\n  }\n\n  next(value: T): void {\n    super.next((this._value = value));\n  }\n}\n","import { PartialObserver, ObservableNotification, CompleteNotification, NextNotification, ErrorNotification } from './types';\nimport { Observable } from './Observable';\nimport { EMPTY } from './observable/empty';\nimport { of } from './observable/of';\nimport { throwError } from './observable/throwError';\nimport { isFunction } from './util/isFunction';\n\n// TODO: When this enum is removed, replace it with a type alias. See #4556.\n/**\n * @deprecated Use a string literal instead. `NotificationKind` will be replaced with a type alias in v8.\n * It will not be replaced with a const enum as those are not compatible with isolated modules.\n */\nexport enum NotificationKind {\n  NEXT = 'N',\n  ERROR = 'E',\n  COMPLETE = 'C',\n}\n\n/**\n * Represents a push-based event or value that an {@link Observable} can emit.\n * This class is particularly useful for operators that manage notifications,\n * like {@link materialize}, {@link dematerialize}, {@link observeOn}, and\n * others. Besides wrapping the actual delivered value, it also annotates it\n * with metadata of, for instance, what type of push message it is (`next`,\n * `error`, or `complete`).\n *\n * @see {@link materialize}\n * @see {@link dematerialize}\n * @see {@link observeOn}\n * @deprecated It is NOT recommended to create instances of `Notification` directly.\n * Rather, try to create POJOs matching the signature outlined in {@link ObservableNotification}.\n * For example: `{ kind: 'N', value: 1 }`, `{ kind: 'E', error: new Error('bad') }`, or `{ kind: 'C' }`.\n * Will be removed in v8.\n */\nexport class Notification<T> {\n  /**\n   * A value signifying that the notification will \"next\" if observed. In truth,\n   * This is really synonymous with just checking `kind === \"N\"`.\n   * @deprecated Will be removed in v8. Instead, just check to see if the value of `kind` is `\"N\"`.\n   */\n  readonly hasValue: boolean;\n\n  /**\n   * Creates a \"Next\" notification object.\n   * @param kind Always `'N'`\n   * @param value The value to notify with if observed.\n   * @deprecated Internal implementation detail. Use {@link Notification#createNext createNext} instead.\n   */\n  constructor(kind: 'N', value?: T);\n  /**\n   * Creates an \"Error\" notification object.\n   * @param kind Always `'E'`\n   * @param value Always `undefined`\n   * @param error The error to notify with if observed.\n   * @deprecated Internal implementation detail. Use {@link Notification#createError createError} instead.\n   */\n  constructor(kind: 'E', value: undefined, error: any);\n  /**\n   * Creates a \"completion\" notification object.\n   * @param kind Always `'C'`\n   * @deprecated Internal implementation detail. Use {@link Notification#createComplete createComplete} instead.\n   */\n  constructor(kind: 'C');\n  constructor(public readonly kind: 'N' | 'E' | 'C', public readonly value?: T, public readonly error?: any) {\n    this.hasValue = kind === 'N';\n  }\n\n  /**\n   * Executes the appropriate handler on a passed `observer` given the `kind` of notification.\n   * If the handler is missing it will do nothing. Even if the notification is an error, if\n   * there is no error handler on the observer, an error will not be thrown, it will noop.\n   * @param observer The observer to notify.\n   */\n  observe(observer: PartialObserver<T>): void {\n    return observeNotification(this as ObservableNotification<T>, observer);\n  }\n\n  /**\n   * Executes a notification on the appropriate handler from a list provided.\n   * If a handler is missing for the kind of notification, nothing is called\n   * and no error is thrown, it will be a noop.\n   * @param next A next handler\n   * @param error An error handler\n   * @param complete A complete handler\n   * @deprecated Replaced with {@link Notification#observe observe}. Will be removed in v8.\n   */\n  do(next: (value: T) => void, error: (err: any) => void, complete: () => void): void;\n  /**\n   * Executes a notification on the appropriate handler from a list provided.\n   * If a handler is missing for the kind of notification, nothing is called\n   * and no error is thrown, it will be a noop.\n   * @param next A next handler\n   * @param error An error handler\n   * @deprecated Replaced with {@link Notification#observe observe}. Will be removed in v8.\n   */\n  do(next: (value: T) => void, error: (err: any) => void): void;\n  /**\n   * Executes the next handler if the Notification is of `kind` `\"N\"`. Otherwise\n   * this will not error, and it will be a noop.\n   * @param next The next handler\n   * @deprecated Replaced with {@link Notification#observe observe}. Will be removed in v8.\n   */\n  do(next: (value: T) => void): void;\n  do(nextHandler: (value: T) => void, errorHandler?: (err: any) => void, completeHandler?: () => void): void {\n    const { kind, value, error } = this;\n    return kind === 'N' ? nextHandler?.(value!) : kind === 'E' ? errorHandler?.(error) : completeHandler?.();\n  }\n\n  /**\n   * Executes a notification on the appropriate handler from a list provided.\n   * If a handler is missing for the kind of notification, nothing is called\n   * and no error is thrown, it will be a noop.\n   * @param next A next handler\n   * @param error An error handler\n   * @param complete A complete handler\n   * @deprecated Replaced with {@link Notification#observe observe}. Will be removed in v8.\n   */\n  accept(next: (value: T) => void, error: (err: any) => void, complete: () => void): void;\n  /**\n   * Executes a notification on the appropriate handler from a list provided.\n   * If a handler is missing for the kind of notification, nothing is called\n   * and no error is thrown, it will be a noop.\n   * @param next A next handler\n   * @param error An error handler\n   * @deprecated Replaced with {@link Notification#observe observe}. Will be removed in v8.\n   */\n  accept(next: (value: T) => void, error: (err: any) => void): void;\n  /**\n   * Executes the next handler if the Notification is of `kind` `\"N\"`. Otherwise\n   * this will not error, and it will be a noop.\n   * @param next The next handler\n   * @deprecated Replaced with {@link Notification#observe observe}. Will be removed in v8.\n   */\n  accept(next: (value: T) => void): void;\n\n  /**\n   * Executes the appropriate handler on a passed `observer` given the `kind` of notification.\n   * If the handler is missing it will do nothing. Even if the notification is an error, if\n   * there is no error handler on the observer, an error will not be thrown, it will noop.\n   * @param observer The observer to notify.\n   * @deprecated Replaced with {@link Notification#observe observe}. Will be removed in v8.\n   */\n  accept(observer: PartialObserver<T>): void;\n  accept(nextOrObserver: PartialObserver<T> | ((value: T) => void), error?: (err: any) => void, complete?: () => void) {\n    return isFunction((nextOrObserver as any)?.next)\n      ? this.observe(nextOrObserver as PartialObserver<T>)\n      : this.do(nextOrObserver as (value: T) => void, error as any, complete as any);\n  }\n\n  /**\n   * Returns a simple Observable that just delivers the notification represented\n   * by this Notification instance.\n   *\n   * @deprecated Will be removed in v8. To convert a `Notification` to an {@link Observable},\n   * use {@link of} and {@link dematerialize}: `of(notification).pipe(dematerialize())`.\n   */\n  toObservable(): Observable<T> {\n    const { kind, value, error } = this;\n    // Select the observable to return by `kind`\n    const result =\n      kind === 'N'\n        ? // Next kind. Return an observable of that value.\n          of(value!)\n        : //\n        kind === 'E'\n        ? // Error kind. Return an observable that emits the error.\n          throwError(() => error)\n        : //\n        kind === 'C'\n        ? // Completion kind. Kind is \"C\", return an observable that just completes.\n          EMPTY\n        : // Unknown kind, return falsy, so we error below.\n          0;\n    if (!result) {\n      // TODO: consider removing this check. The only way to cause this would be to\n      // use the Notification constructor directly in a way that is not type-safe.\n      // and direct use of the Notification constructor is deprecated.\n      throw new TypeError(`Unexpected notification kind ${kind}`);\n    }\n    return result;\n  }\n\n  private static completeNotification = new Notification('C') as Notification<never> & CompleteNotification;\n  /**\n   * A shortcut to create a Notification instance of the type `next` from a\n   * given value.\n   * @param {T} value The `next` value.\n   * @return {Notification<T>} The \"next\" Notification representing the\n   * argument.\n   * @nocollapse\n   * @deprecated It is NOT recommended to create instances of `Notification` directly.\n   * Rather, try to create POJOs matching the signature outlined in {@link ObservableNotification}.\n   * For example: `{ kind: 'N', value: 1 }`, `{ kind: 'E', error: new Error('bad') }`, or `{ kind: 'C' }`.\n   * Will be removed in v8.\n   */\n  static createNext<T>(value: T) {\n    return new Notification('N', value) as Notification<T> & NextNotification<T>;\n  }\n\n  /**\n   * A shortcut to create a Notification instance of the type `error` from a\n   * given error.\n   * @param {any} [err] The `error` error.\n   * @return {Notification<T>} The \"error\" Notification representing the\n   * argument.\n   * @nocollapse\n   * @deprecated It is NOT recommended to create instances of `Notification` directly.\n   * Rather, try to create POJOs matching the signature outlined in {@link ObservableNotification}.\n   * For example: `{ kind: 'N', value: 1 }`, `{ kind: 'E', error: new Error('bad') }`, or `{ kind: 'C' }`.\n   * Will be removed in v8.\n   */\n  static createError(err?: any) {\n    return new Notification('E', undefined, err) as Notification<never> & ErrorNotification;\n  }\n\n  /**\n   * A shortcut to create a Notification instance of the type `complete`.\n   * @return {Notification<any>} The valueless \"complete\" Notification.\n   * @nocollapse\n   * @deprecated It is NOT recommended to create instances of `Notification` directly.\n   * Rather, try to create POJOs matching the signature outlined in {@link ObservableNotification}.\n   * For example: `{ kind: 'N', value: 1 }`, `{ kind: 'E', error: new Error('bad') }`, or `{ kind: 'C' }`.\n   * Will be removed in v8.\n   */\n  static createComplete(): Notification<never> & CompleteNotification {\n    return Notification.completeNotification;\n  }\n}\n\n/**\n * Executes the appropriate handler on a passed `observer` given the `kind` of notification.\n * If the handler is missing it will do nothing. Even if the notification is an error, if\n * there is no error handler on the observer, an error will not be thrown, it will noop.\n * @param notification The notification object to observe.\n * @param observer The observer to notify.\n */\nexport function observeNotification<T>(notification: ObservableNotification<T>, observer: PartialObserver<T>) {\n  const { kind, value, error } = notification as any;\n  if (typeof kind !== 'string') {\n    throw new TypeError('Invalid notification, missing \"kind\"');\n  }\n  kind === 'N' ? observer.next?.(value!) : kind === 'E' ? observer.error?.(error) : observer.complete?.();\n}\n","import { CompleteNotification, NextNotification, ErrorNotification } from './types';\n\n/**\n * A completion object optimized for memory use and created to be the\n * same \"shape\" as other notifications in v8.\n * @internal\n */\nexport const COMPLETE_NOTIFICATION = (() => createNotification('C', undefined, undefined) as CompleteNotification)();\n\n/**\n * Internal use only. Creates an optimized error notification that is the same \"shape\"\n * as other notifications.\n * @internal\n */\nexport function errorNotification(error: any): ErrorNotification {\n  return createNotification('E', undefined, error) as any;\n}\n\n/**\n * Internal use only. Creates an optimized next notification that is the same \"shape\"\n * as other notifications.\n * @internal\n */\nexport function nextNotification<T>(value: T) {\n  return createNotification('N', value, undefined) as NextNotification<T>;\n}\n\n/**\n * Ensures that all notifications created internally have the same \"shape\" in v8.\n *\n * TODO: This is only exported to support a crazy legacy test in `groupBy`.\n * @internal\n */\nexport function createNotification(kind: 'N' | 'E' | 'C', value: any, error: any) {\n  return {\n    kind,\n    value,\n    error,\n  };\n}\n","import { Operator } from './Operator';\nimport { SafeSubscriber, Subscriber } from './Subscriber';\nimport { isSubscription, Subscription } from './Subscription';\nimport { TeardownLogic, OperatorFunction, Subscribable, Observer } from './types';\nimport { observable as Symbol_observable } from './symbol/observable';\nimport { pipeFromArray } from './util/pipe';\nimport { config } from './config';\nimport { isFunction } from './util/isFunction';\nimport { errorContext } from './util/errorContext';\n\n/**\n * A representation of any set of values over any amount of time. This is the most basic building block\n * of RxJS.\n *\n * @class Observable<T>\n */\nexport class Observable<T> implements Subscribable<T> {\n  /**\n   * @deprecated Internal implementation detail, do not use directly. Will be made internal in v8.\n   */\n  source: Observable<any> | undefined;\n\n  /**\n   * @deprecated Internal implementation detail, do not use directly. Will be made internal in v8.\n   */\n  operator: Operator<any, T> | undefined;\n\n  /**\n   * @constructor\n   * @param {Function} subscribe the function that is called when the Observable is\n   * initially subscribed to. This function is given a Subscriber, to which new values\n   * can be `next`ed, or an `error` method can be called to raise an error, or\n   * `complete` can be called to notify of a successful completion.\n   */\n  constructor(subscribe?: (this: Observable<T>, subscriber: Subscriber<T>) => TeardownLogic) {\n    if (subscribe) {\n      this._subscribe = subscribe;\n    }\n  }\n\n  // HACK: Since TypeScript inherits static properties too, we have to\n  // fight against TypeScript here so Subject can have a different static create signature\n  /**\n   * Creates a new Observable by calling the Observable constructor\n   * @owner Observable\n   * @method create\n   * @param {Function} subscribe? the subscriber function to be passed to the Observable constructor\n   * @return {Observable} a new observable\n   * @nocollapse\n   * @deprecated Use `new Observable()` instead. Will be removed in v8.\n   */\n  static create: (...args: any[]) => any = <T>(subscribe?: (subscriber: Subscriber<T>) => TeardownLogic) => {\n    return new Observable<T>(subscribe);\n  };\n\n  /**\n   * Creates a new Observable, with this Observable instance as the source, and the passed\n   * operator defined as the new observable's operator.\n   * @method lift\n   * @param operator the operator defining the operation to take on the observable\n   * @return a new observable with the Operator applied\n   * @deprecated Internal implementation detail, do not use directly. Will be made internal in v8.\n   * If you have implemented an operator using `lift`, it is recommended that you create an\n   * operator by simply returning `new Observable()` directly. See \"Creating new operators from\n   * scratch\" section here: https://rxjs.dev/guide/operators\n   */\n  lift<R>(operator?: Operator<T, R>): Observable<R> {\n    const observable = new Observable<R>();\n    observable.source = this;\n    observable.operator = operator;\n    return observable;\n  }\n\n  subscribe(observerOrNext?: Partial<Observer<T>> | ((value: T) => void)): Subscription;\n  /** @deprecated Instead of passing separate callback arguments, use an observer argument. Signatures taking separate callback arguments will be removed in v8. Details: https://rxjs.dev/deprecations/subscribe-arguments */\n  subscribe(next?: ((value: T) => void) | null, error?: ((error: any) => void) | null, complete?: (() => void) | null): Subscription;\n  /**\n   * Invokes an execution of an Observable and registers Observer handlers for notifications it will emit.\n   *\n   * <span class=\"informal\">Use it when you have all these Observables, but still nothing is happening.</span>\n   *\n   * `subscribe` is not a regular operator, but a method that calls Observable's internal `subscribe` function. It\n   * might be for example a function that you passed to Observable's constructor, but most of the time it is\n   * a library implementation, which defines what will be emitted by an Observable, and when it be will emitted. This means\n   * that calling `subscribe` is actually the moment when Observable starts its work, not when it is created, as it is often\n   * the thought.\n   *\n   * Apart from starting the execution of an Observable, this method allows you to listen for values\n   * that an Observable emits, as well as for when it completes or errors. You can achieve this in two\n   * of the following ways.\n   *\n   * The first way is creating an object that implements {@link Observer} interface. It should have methods\n   * defined by that interface, but note that it should be just a regular JavaScript object, which you can create\n   * yourself in any way you want (ES6 class, classic function constructor, object literal etc.). In particular, do\n   * not attempt to use any RxJS implementation details to create Observers - you don't need them. Remember also\n   * that your object does not have to implement all methods. If you find yourself creating a method that doesn't\n   * do anything, you can simply omit it. Note however, if the `error` method is not provided and an error happens,\n   * it will be thrown asynchronously. Errors thrown asynchronously cannot be caught using `try`/`catch`. Instead,\n   * use the {@link onUnhandledError} configuration option or use a runtime handler (like `window.onerror` or\n   * `process.on('error)`) to be notified of unhandled errors. Because of this, it's recommended that you provide\n   * an `error` method to avoid missing thrown errors.\n   *\n   * The second way is to give up on Observer object altogether and simply provide callback functions in place of its methods.\n   * This means you can provide three functions as arguments to `subscribe`, where the first function is equivalent\n   * of a `next` method, the second of an `error` method and the third of a `complete` method. Just as in case of an Observer,\n   * if you do not need to listen for something, you can omit a function by passing `undefined` or `null`,\n   * since `subscribe` recognizes these functions by where they were placed in function call. When it comes\n   * to the `error` function, as with an Observer, if not provided, errors emitted by an Observable will be thrown asynchronously.\n   *\n   * You can, however, subscribe with no parameters at all. This may be the case where you're not interested in terminal events\n   * and you also handled emissions internally by using operators (e.g. using `tap`).\n   *\n   * Whichever style of calling `subscribe` you use, in both cases it returns a Subscription object.\n   * This object allows you to call `unsubscribe` on it, which in turn will stop the work that an Observable does and will clean\n   * up all resources that an Observable used. Note that cancelling a subscription will not call `complete` callback\n   * provided to `subscribe` function, which is reserved for a regular completion signal that comes from an Observable.\n   *\n   * Remember that callbacks provided to `subscribe` are not guaranteed to be called asynchronously.\n   * It is an Observable itself that decides when these functions will be called. For example {@link of}\n   * by default emits all its values synchronously. Always check documentation for how given Observable\n   * will behave when subscribed and if its default behavior can be modified with a `scheduler`.\n   *\n   * #### Examples\n   *\n   * Subscribe with an {@link guide/observer Observer}\n   *\n   * ```ts\n   * import { of } from 'rxjs';\n   *\n   * const sumObserver = {\n   *   sum: 0,\n   *   next(value) {\n   *     console.log('Adding: ' + value);\n   *     this.sum = this.sum + value;\n   *   },\n   *   error() {\n   *     // We actually could just remove this method,\n   *     // since we do not really care about errors right now.\n   *   },\n   *   complete() {\n   *     console.log('Sum equals: ' + this.sum);\n   *   }\n   * };\n   *\n   * of(1, 2, 3) // Synchronously emits 1, 2, 3 and then completes.\n   *   .subscribe(sumObserver);\n   *\n   * // Logs:\n   * // 'Adding: 1'\n   * // 'Adding: 2'\n   * // 'Adding: 3'\n   * // 'Sum equals: 6'\n   * ```\n   *\n   * Subscribe with functions ({@link deprecations/subscribe-arguments deprecated})\n   *\n   * ```ts\n   * import { of } from 'rxjs'\n   *\n   * let sum = 0;\n   *\n   * of(1, 2, 3).subscribe(\n   *   value => {\n   *     console.log('Adding: ' + value);\n   *     sum = sum + value;\n   *   },\n   *   undefined,\n   *   () => console.log('Sum equals: ' + sum)\n   * );\n   *\n   * // Logs:\n   * // 'Adding: 1'\n   * // 'Adding: 2'\n   * // 'Adding: 3'\n   * // 'Sum equals: 6'\n   * ```\n   *\n   * Cancel a subscription\n   *\n   * ```ts\n   * import { interval } from 'rxjs';\n   *\n   * const subscription = interval(1000).subscribe({\n   *   next(num) {\n   *     console.log(num)\n   *   },\n   *   complete() {\n   *     // Will not be called, even when cancelling subscription.\n   *     console.log('completed!');\n   *   }\n   * });\n   *\n   * setTimeout(() => {\n   *   subscription.unsubscribe();\n   *   console.log('unsubscribed!');\n   * }, 2500);\n   *\n   * // Logs:\n   * // 0 after 1s\n   * // 1 after 2s\n   * // 'unsubscribed!' after 2.5s\n   * ```\n   *\n   * @param {Observer|Function} observerOrNext (optional) Either an observer with methods to be called,\n   * or the first of three possible handlers, which is the handler for each value emitted from the subscribed\n   * Observable.\n   * @param {Function} error (optional) A handler for a terminal event resulting from an error. If no error handler is provided,\n   * the error will be thrown asynchronously as unhandled.\n   * @param {Function} complete (optional) A handler for a terminal event resulting from successful completion.\n   * @return {Subscription} a subscription reference to the registered handlers\n   * @method subscribe\n   */\n  subscribe(\n    observerOrNext?: Partial<Observer<T>> | ((value: T) => void) | null,\n    error?: ((error: any) => void) | null,\n    complete?: (() => void) | null\n  ): Subscription {\n    const subscriber = isSubscriber(observerOrNext) ? observerOrNext : new SafeSubscriber(observerOrNext, error, complete);\n\n    errorContext(() => {\n      const { operator, source } = this;\n      subscriber.add(\n        operator\n          ? // We're dealing with a subscription in the\n            // operator chain to one of our lifted operators.\n            operator.call(subscriber, source)\n          : source\n          ? // If `source` has a value, but `operator` does not, something that\n            // had intimate knowledge of our API, like our `Subject`, must have\n            // set it. We're going to just call `_subscribe` directly.\n            this._subscribe(subscriber)\n          : // In all other cases, we're likely wrapping a user-provided initializer\n            // function, so we need to catch errors and handle them appropriately.\n            this._trySubscribe(subscriber)\n      );\n    });\n\n    return subscriber;\n  }\n\n  /** @internal */\n  protected _trySubscribe(sink: Subscriber<T>): TeardownLogic {\n    try {\n      return this._subscribe(sink);\n    } catch (err) {\n      // We don't need to return anything in this case,\n      // because it's just going to try to `add()` to a subscription\n      // above.\n      sink.error(err);\n    }\n  }\n\n  /**\n   * Used as a NON-CANCELLABLE means of subscribing to an observable, for use with\n   * APIs that expect promises, like `async/await`. You cannot unsubscribe from this.\n   *\n   * **WARNING**: Only use this with observables you *know* will complete. If the source\n   * observable does not complete, you will end up with a promise that is hung up, and\n   * potentially all of the state of an async function hanging out in memory. To avoid\n   * this situation, look into adding something like {@link timeout}, {@link take},\n   * {@link takeWhile}, or {@link takeUntil} amongst others.\n   *\n   * #### Example\n   *\n   * ```ts\n   * import { interval, take } from 'rxjs';\n   *\n   * const source$ = interval(1000).pipe(take(4));\n   *\n   * async function getTotal() {\n   *   let total = 0;\n   *\n   *   await source$.forEach(value => {\n   *     total += value;\n   *     console.log('observable -> ' + value);\n   *   });\n   *\n   *   return total;\n   * }\n   *\n   * getTotal().then(\n   *   total => console.log('Total: ' + total)\n   * );\n   *\n   * // Expected:\n   * // 'observable -> 0'\n   * // 'observable -> 1'\n   * // 'observable -> 2'\n   * // 'observable -> 3'\n   * // 'Total: 6'\n   * ```\n   *\n   * @param next a handler for each value emitted by the observable\n   * @return a promise that either resolves on observable completion or\n   *  rejects with the handled error\n   */\n  forEach(next: (value: T) => void): Promise<void>;\n\n  /**\n   * @param next a handler for each value emitted by the observable\n   * @param promiseCtor a constructor function used to instantiate the Promise\n   * @return a promise that either resolves on observable completion or\n   *  rejects with the handled error\n   * @deprecated Passing a Promise constructor will no longer be available\n   * in upcoming versions of RxJS. This is because it adds weight to the library, for very\n   * little benefit. If you need this functionality, it is recommended that you either\n   * polyfill Promise, or you create an adapter to convert the returned native promise\n   * to whatever promise implementation you wanted. Will be removed in v8.\n   */\n  forEach(next: (value: T) => void, promiseCtor: PromiseConstructorLike): Promise<void>;\n\n  forEach(next: (value: T) => void, promiseCtor?: PromiseConstructorLike): Promise<void> {\n    promiseCtor = getPromiseCtor(promiseCtor);\n\n    return new promiseCtor<void>((resolve, reject) => {\n      const subscriber = new SafeSubscriber<T>({\n        next: (value) => {\n          try {\n            next(value);\n          } catch (err) {\n            reject(err);\n            subscriber.unsubscribe();\n          }\n        },\n        error: reject,\n        complete: resolve,\n      });\n      this.subscribe(subscriber);\n    }) as Promise<void>;\n  }\n\n  /** @internal */\n  protected _subscribe(subscriber: Subscriber<any>): TeardownLogic {\n    return this.source?.subscribe(subscriber);\n  }\n\n  /**\n   * An interop point defined by the es7-observable spec https://github.com/zenparsing/es-observable\n   * @method Symbol.observable\n   * @return {Observable} this instance of the observable\n   */\n  [Symbol_observable]() {\n    return this;\n  }\n\n  /* tslint:disable:max-line-length */\n  pipe(): Observable<T>;\n  pipe<A>(op1: OperatorFunction<T, A>): Observable<A>;\n  pipe<A, B>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>): Observable<B>;\n  pipe<A, B, C>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>): Observable<C>;\n  pipe<A, B, C, D>(\n    op1: OperatorFunction<T, A>,\n    op2: OperatorFunction<A, B>,\n    op3: OperatorFunction<B, C>,\n    op4: OperatorFunction<C, D>\n  ): Observable<D>;\n  pipe<A, B, C, D, E>(\n    op1: OperatorFunction<T, A>,\n    op2: OperatorFunction<A, B>,\n    op3: OperatorFunction<B, C>,\n    op4: OperatorFunction<C, D>,\n    op5: OperatorFunction<D, E>\n  ): Observable<E>;\n  pipe<A, B, C, D, E, F>(\n    op1: OperatorFunction<T, A>,\n    op2: OperatorFunction<A, B>,\n    op3: OperatorFunction<B, C>,\n    op4: OperatorFunction<C, D>,\n    op5: OperatorFunction<D, E>,\n    op6: OperatorFunction<E, F>\n  ): Observable<F>;\n  pipe<A, B, C, D, E, F, G>(\n    op1: OperatorFunction<T, A>,\n    op2: OperatorFunction<A, B>,\n    op3: OperatorFunction<B, C>,\n    op4: OperatorFunction<C, D>,\n    op5: OperatorFunction<D, E>,\n    op6: OperatorFunction<E, F>,\n    op7: OperatorFunction<F, G>\n  ): Observable<G>;\n  pipe<A, B, C, D, E, F, G, H>(\n    op1: OperatorFunction<T, A>,\n    op2: OperatorFunction<A, B>,\n    op3: OperatorFunction<B, C>,\n    op4: OperatorFunction<C, D>,\n    op5: OperatorFunction<D, E>,\n    op6: OperatorFunction<E, F>,\n    op7: OperatorFunction<F, G>,\n    op8: OperatorFunction<G, H>\n  ): Observable<H>;\n  pipe<A, B, C, D, E, F, G, H, I>(\n    op1: OperatorFunction<T, A>,\n    op2: OperatorFunction<A, B>,\n    op3: OperatorFunction<B, C>,\n    op4: OperatorFunction<C, D>,\n    op5: OperatorFunction<D, E>,\n    op6: OperatorFunction<E, F>,\n    op7: OperatorFunction<F, G>,\n    op8: OperatorFunction<G, H>,\n    op9: OperatorFunction<H, I>\n  ): Observable<I>;\n  pipe<A, B, C, D, E, F, G, H, I>(\n    op1: OperatorFunction<T, A>,\n    op2: OperatorFunction<A, B>,\n    op3: OperatorFunction<B, C>,\n    op4: OperatorFunction<C, D>,\n    op5: OperatorFunction<D, E>,\n    op6: OperatorFunction<E, F>,\n    op7: OperatorFunction<F, G>,\n    op8: OperatorFunction<G, H>,\n    op9: OperatorFunction<H, I>,\n    ...operations: OperatorFunction<any, any>[]\n  ): Observable<unknown>;\n  /* tslint:enable:max-line-length */\n\n  /**\n   * Used to stitch together functional operators into a chain.\n   * @method pipe\n   * @return {Observable} the Observable result of all of the operators having\n   * been called in the order they were passed in.\n   *\n   * ## Example\n   *\n   * ```ts\n   * import { interval, filter, map, scan } from 'rxjs';\n   *\n   * interval(1000)\n   *   .pipe(\n   *     filter(x => x % 2 === 0),\n   *     map(x => x + x),\n   *     scan((acc, x) => acc + x)\n   *   )\n   *   .subscribe(x => console.log(x));\n   * ```\n   */\n  pipe(...operations: OperatorFunction<any, any>[]): Observable<any> {\n    return pipeFromArray(operations)(this);\n  }\n\n  /* tslint:disable:max-line-length */\n  /** @deprecated Replaced with {@link firstValueFrom} and {@link lastValueFrom}. Will be removed in v8. Details: https://rxjs.dev/deprecations/to-promise */\n  toPromise(): Promise<T | undefined>;\n  /** @deprecated Replaced with {@link firstValueFrom} and {@link lastValueFrom}. Will be removed in v8. Details: https://rxjs.dev/deprecations/to-promise */\n  toPromise(PromiseCtor: typeof Promise): Promise<T | undefined>;\n  /** @deprecated Replaced with {@link firstValueFrom} and {@link lastValueFrom}. Will be removed in v8. Details: https://rxjs.dev/deprecations/to-promise */\n  toPromise(PromiseCtor: PromiseConstructorLike): Promise<T | undefined>;\n  /* tslint:enable:max-line-length */\n\n  /**\n   * Subscribe to this Observable and get a Promise resolving on\n   * `complete` with the last emission (if any).\n   *\n   * **WARNING**: Only use this with observables you *know* will complete. If the source\n   * observable does not complete, you will end up with a promise that is hung up, and\n   * potentially all of the state of an async function hanging out in memory. To avoid\n   * this situation, look into adding something like {@link timeout}, {@link take},\n   * {@link takeWhile}, or {@link takeUntil} amongst others.\n   *\n   * @method toPromise\n   * @param [promiseCtor] a constructor function used to instantiate\n   * the Promise\n   * @return A Promise that resolves with the last value emit, or\n   * rejects on an error. If there were no emissions, Promise\n   * resolves with undefined.\n   * @deprecated Replaced with {@link firstValueFrom} and {@link lastValueFrom}. Will be removed in v8. Details: https://rxjs.dev/deprecations/to-promise\n   */\n  toPromise(promiseCtor?: PromiseConstructorLike): Promise<T | undefined> {\n    promiseCtor = getPromiseCtor(promiseCtor);\n\n    return new promiseCtor((resolve, reject) => {\n      let value: T | undefined;\n      this.subscribe(\n        (x: T) => (value = x),\n        (err: any) => reject(err),\n        () => resolve(value)\n      );\n    }) as Promise<T | undefined>;\n  }\n}\n\n/**\n * Decides between a passed promise constructor from consuming code,\n * A default configured promise constructor, and the native promise\n * constructor and returns it. If nothing can be found, it will throw\n * an error.\n * @param promiseCtor The optional promise constructor to passed by consuming code\n */\nfunction getPromiseCtor(promiseCtor: PromiseConstructorLike | undefined) {\n  return promiseCtor ?? config.Promise ?? Promise;\n}\n\nfunction isObserver<T>(value: any): value is Observer<T> {\n  return value && isFunction(value.next) && isFunction(value.error) && isFunction(value.complete);\n}\n\nfunction isSubscriber<T>(value: any): value is Subscriber<T> {\n  return (value && value instanceof Subscriber) || (isObserver(value) && isSubscription(value));\n}\n","import { Subject } from './Subject';\nimport { TimestampProvider } from './types';\nimport { Subscriber } from './Subscriber';\nimport { Subscription } from './Subscription';\nimport { dateTimestampProvider } from './scheduler/dateTimestampProvider';\n\n/**\n * A variant of {@link Subject} that \"replays\" old values to new subscribers by emitting them when they first subscribe.\n *\n * `ReplaySubject` has an internal buffer that will store a specified number of values that it has observed. Like `Subject`,\n * `ReplaySubject` \"observes\" values by having them passed to its `next` method. When it observes a value, it will store that\n * value for a time determined by the configuration of the `ReplaySubject`, as passed to its constructor.\n *\n * When a new subscriber subscribes to the `ReplaySubject` instance, it will synchronously emit all values in its buffer in\n * a First-In-First-Out (FIFO) manner. The `ReplaySubject` will also complete, if it has observed completion; and it will\n * error if it has observed an error.\n *\n * There are two main configuration items to be concerned with:\n *\n * 1. `bufferSize` - This will determine how many items are stored in the buffer, defaults to infinite.\n * 2. `windowTime` - The amount of time to hold a value in the buffer before removing it from the buffer.\n *\n * Both configurations may exist simultaneously. So if you would like to buffer a maximum of 3 values, as long as the values\n * are less than 2 seconds old, you could do so with a `new ReplaySubject(3, 2000)`.\n *\n * ### Differences with BehaviorSubject\n *\n * `BehaviorSubject` is similar to `new ReplaySubject(1)`, with a couple of exceptions:\n *\n * 1. `BehaviorSubject` comes \"primed\" with a single value upon construction.\n * 2. `ReplaySubject` will replay values, even after observing an error, where `BehaviorSubject` will not.\n *\n * @see {@link Subject}\n * @see {@link BehaviorSubject}\n * @see {@link shareReplay}\n */\nexport class ReplaySubject<T> extends Subject<T> {\n  private _buffer: (T | number)[] = [];\n  private _infiniteTimeWindow = true;\n\n  /**\n   * @param bufferSize The size of the buffer to replay on subscription\n   * @param windowTime The amount of time the buffered items will stay buffered\n   * @param timestampProvider An object with a `now()` method that provides the current timestamp. This is used to\n   * calculate the amount of time something has been buffered.\n   */\n  constructor(\n    private _bufferSize = Infinity,\n    private _windowTime = Infinity,\n    private _timestampProvider: TimestampProvider = dateTimestampProvider\n  ) {\n    super();\n    this._infiniteTimeWindow = _windowTime === Infinity;\n    this._bufferSize = Math.max(1, _bufferSize);\n    this._windowTime = Math.max(1, _windowTime);\n  }\n\n  next(value: T): void {\n    const { isStopped, _buffer, _infiniteTimeWindow, _timestampProvider, _windowTime } = this;\n    if (!isStopped) {\n      _buffer.push(value);\n      !_infiniteTimeWindow && _buffer.push(_timestampProvider.now() + _windowTime);\n    }\n    this._trimBuffer();\n    super.next(value);\n  }\n\n  /** @internal */\n  protected _subscribe(subscriber: Subscriber<T>): Subscription {\n    this._throwIfClosed();\n    this._trimBuffer();\n\n    const subscription = this._innerSubscribe(subscriber);\n\n    const { _infiniteTimeWindow, _buffer } = this;\n    // We use a copy here, so reentrant code does not mutate our array while we're\n    // emitting it to a new subscriber.\n    const copy = _buffer.slice();\n    for (let i = 0; i < copy.length && !subscriber.closed; i += _infiniteTimeWindow ? 1 : 2) {\n      subscriber.next(copy[i] as T);\n    }\n\n    this._checkFinalizedStatuses(subscriber);\n\n    return subscription;\n  }\n\n  private _trimBuffer() {\n    const { _bufferSize, _timestampProvider, _buffer, _infiniteTimeWindow } = this;\n    // If we don't have an infinite buffer size, and we're over the length,\n    // use splice to truncate the old buffer values off. Note that we have to\n    // double the size for instances where we're not using an infinite time window\n    // because we're storing the values and the timestamps in the same array.\n    const adjustedBufferSize = (_infiniteTimeWindow ? 1 : 2) * _bufferSize;\n    _bufferSize < Infinity && adjustedBufferSize < _buffer.length && _buffer.splice(0, _buffer.length - adjustedBufferSize);\n\n    // Now, if we're not in an infinite time window, remove all values where the time is\n    // older than what is allowed.\n    if (!_infiniteTimeWindow) {\n      const now = _timestampProvider.now();\n      let last = 0;\n      // Search the array for the first timestamp that isn't expired and\n      // truncate the buffer up to that point.\n      for (let i = 1; i < _buffer.length && (_buffer[i] as number) <= now; i += 2) {\n        last = i;\n      }\n      last && _buffer.splice(0, last + 1);\n    }\n  }\n}\n","import { Action } from './scheduler/Action';\nimport { Subscription } from './Subscription';\nimport { SchedulerLike, SchedulerAction } from './types';\nimport { dateTimestampProvider } from './scheduler/dateTimestampProvider';\n\n/**\n * An execution context and a data structure to order tasks and schedule their\n * execution. Provides a notion of (potentially virtual) time, through the\n * `now()` getter method.\n *\n * Each unit of work in a Scheduler is called an `Action`.\n *\n * ```ts\n * class Scheduler {\n *   now(): number;\n *   schedule(work, delay?, state?): Subscription;\n * }\n * ```\n *\n * @class Scheduler\n * @deprecated Scheduler is an internal implementation detail of RxJS, and\n * should not be used directly. Rather, create your own class and implement\n * {@link SchedulerLike}. Will be made internal in v8.\n */\nexport class Scheduler implements SchedulerLike {\n  public static now: () => number = dateTimestampProvider.now;\n\n  constructor(private schedulerActionCtor: typeof Action, now: () => number = Scheduler.now) {\n    this.now = now;\n  }\n\n  /**\n   * A getter method that returns a number representing the current time\n   * (at the time this function was called) according to the scheduler's own\n   * internal clock.\n   * @return {number} A number that represents the current time. May or may not\n   * have a relation to wall-clock time. May or may not refer to a time unit\n   * (e.g. milliseconds).\n   */\n  public now: () => number;\n\n  /**\n   * Schedules a function, `work`, for execution. May happen at some point in\n   * the future, according to the `delay` parameter, if specified. May be passed\n   * some context object, `state`, which will be passed to the `work` function.\n   *\n   * The given arguments will be processed an stored as an Action object in a\n   * queue of actions.\n   *\n   * @param {function(state: ?T): ?Subscription} work A function representing a\n   * task, or some unit of work to be executed by the Scheduler.\n   * @param {number} [delay] Time to wait before executing the work, where the\n   * time unit is implicit and defined by the Scheduler itself.\n   * @param {T} [state] Some contextual data that the `work` function uses when\n   * called by the Scheduler.\n   * @return {Subscription} A subscription in order to be able to unsubscribe\n   * the scheduled work.\n   */\n  public schedule<T>(work: (this: SchedulerAction<T>, state?: T) => void, delay: number = 0, state?: T): Subscription {\n    return new this.schedulerActionCtor<T>(this, work).schedule(state, delay);\n  }\n}\n","import { Operator } from './Operator';\nimport { Observable } from './Observable';\nimport { Subscriber } from './Subscriber';\nimport { Subscription, EMPTY_SUBSCRIPTION } from './Subscription';\nimport { Observer, SubscriptionLike, TeardownLogic } from './types';\nimport { ObjectUnsubscribedError } from './util/ObjectUnsubscribedError';\nimport { arrRemove } from './util/arrRemove';\nimport { errorContext } from './util/errorContext';\n\n/**\n * A Subject is a special type of Observable that allows values to be\n * multicasted to many Observers. Subjects are like EventEmitters.\n *\n * Every Subject is an Observable and an Observer. You can subscribe to a\n * Subject, and you can call next to feed values as well as error and complete.\n */\nexport class Subject<T> extends Observable<T> implements SubscriptionLike {\n  closed = false;\n\n  private currentObservers: Observer<T>[] | null = null;\n\n  /** @deprecated Internal implementation detail, do not use directly. Will be made internal in v8. */\n  observers: Observer<T>[] = [];\n  /** @deprecated Internal implementation detail, do not use directly. Will be made internal in v8. */\n  isStopped = false;\n  /** @deprecated Internal implementation detail, do not use directly. Will be made internal in v8. */\n  hasError = false;\n  /** @deprecated Internal implementation detail, do not use directly. Will be made internal in v8. */\n  thrownError: any = null;\n\n  /**\n   * Creates a \"subject\" by basically gluing an observer to an observable.\n   *\n   * @nocollapse\n   * @deprecated Recommended you do not use. Will be removed at some point in the future. Plans for replacement still under discussion.\n   */\n  static create: (...args: any[]) => any = <T>(destination: Observer<T>, source: Observable<T>): AnonymousSubject<T> => {\n    return new AnonymousSubject<T>(destination, source);\n  };\n\n  constructor() {\n    // NOTE: This must be here to obscure Observable's constructor.\n    super();\n  }\n\n  /** @deprecated Internal implementation detail, do not use directly. Will be made internal in v8. */\n  lift<R>(operator: Operator<T, R>): Observable<R> {\n    const subject = new AnonymousSubject(this, this);\n    subject.operator = operator as any;\n    return subject as any;\n  }\n\n  /** @internal */\n  protected _throwIfClosed() {\n    if (this.closed) {\n      throw new ObjectUnsubscribedError();\n    }\n  }\n\n  next(value: T) {\n    errorContext(() => {\n      this._throwIfClosed();\n      if (!this.isStopped) {\n        if (!this.currentObservers) {\n          this.currentObservers = Array.from(this.observers);\n        }\n        for (const observer of this.currentObservers) {\n          observer.next(value);\n        }\n      }\n    });\n  }\n\n  error(err: any) {\n    errorContext(() => {\n      this._throwIfClosed();\n      if (!this.isStopped) {\n        this.hasError = this.isStopped = true;\n        this.thrownError = err;\n        const { observers } = this;\n        while (observers.length) {\n          observers.shift()!.error(err);\n        }\n      }\n    });\n  }\n\n  complete() {\n    errorContext(() => {\n      this._throwIfClosed();\n      if (!this.isStopped) {\n        this.isStopped = true;\n        const { observers } = this;\n        while (observers.length) {\n          observers.shift()!.complete();\n        }\n      }\n    });\n  }\n\n  unsubscribe() {\n    this.isStopped = this.closed = true;\n    this.observers = this.currentObservers = null!;\n  }\n\n  get observed() {\n    return this.observers?.length > 0;\n  }\n\n  /** @internal */\n  protected _trySubscribe(subscriber: Subscriber<T>): TeardownLogic {\n    this._throwIfClosed();\n    return super._trySubscribe(subscriber);\n  }\n\n  /** @internal */\n  protected _subscribe(subscriber: Subscriber<T>): Subscription {\n    this._throwIfClosed();\n    this._checkFinalizedStatuses(subscriber);\n    return this._innerSubscribe(subscriber);\n  }\n\n  /** @internal */\n  protected _innerSubscribe(subscriber: Subscriber<any>) {\n    const { hasError, isStopped, observers } = this;\n    if (hasError || isStopped) {\n      return EMPTY_SUBSCRIPTION;\n    }\n    this.currentObservers = null;\n    observers.push(subscriber);\n    return new Subscription(() => {\n      this.currentObservers = null;\n      arrRemove(observers, subscriber);\n    });\n  }\n\n  /** @internal */\n  protected _checkFinalizedStatuses(subscriber: Subscriber<any>) {\n    const { hasError, thrownError, isStopped } = this;\n    if (hasError) {\n      subscriber.error(thrownError);\n    } else if (isStopped) {\n      subscriber.complete();\n    }\n  }\n\n  /**\n   * Creates a new Observable with this Subject as the source. You can do this\n   * to create custom Observer-side logic of the Subject and conceal it from\n   * code that uses the Observable.\n   * @return {Observable} Observable that the Subject casts to\n   */\n  asObservable(): Observable<T> {\n    const observable: any = new Observable<T>();\n    observable.source = this;\n    return observable;\n  }\n}\n\n/**\n * @class AnonymousSubject<T>\n */\nexport class AnonymousSubject<T> extends Subject<T> {\n  constructor(\n    /** @deprecated Internal implementation detail, do not use directly. Will be made internal in v8. */\n    public destination?: Observer<T>,\n    source?: Observable<T>\n  ) {\n    super();\n    this.source = source;\n  }\n\n  next(value: T) {\n    this.destination?.next?.(value);\n  }\n\n  error(err: any) {\n    this.destination?.error?.(err);\n  }\n\n  complete() {\n    this.destination?.complete?.();\n  }\n\n  /** @internal */\n  protected _subscribe(subscriber: Subscriber<T>): Subscription {\n    return this.source?.subscribe(subscriber) ?? EMPTY_SUBSCRIPTION;\n  }\n}\n","import { isFunction } from './util/isFunction';\nimport { Observer, ObservableNotification } from './types';\nimport { isSubscription, Subscription } from './Subscription';\nimport { config } from './config';\nimport { reportUnhandledError } from './util/reportUnhandledError';\nimport { noop } from './util/noop';\nimport { nextNotification, errorNotification, COMPLETE_NOTIFICATION } from './NotificationFactories';\nimport { timeoutProvider } from './scheduler/timeoutProvider';\nimport { captureError } from './util/errorContext';\n\n/**\n * Implements the {@link Observer} interface and extends the\n * {@link Subscription} class. While the {@link Observer} is the public API for\n * consuming the values of an {@link Observable}, all Observers get converted to\n * a Subscriber, in order to provide Subscription-like capabilities such as\n * `unsubscribe`. Subscriber is a common type in RxJS, and crucial for\n * implementing operators, but it is rarely used as a public API.\n *\n * @class Subscriber<T>\n */\nexport class Subscriber<T> extends Subscription implements Observer<T> {\n  /**\n   * A static factory for a Subscriber, given a (potentially partial) definition\n   * of an Observer.\n   * @param next The `next` callback of an Observer.\n   * @param error The `error` callback of an\n   * Observer.\n   * @param complete The `complete` callback of an\n   * Observer.\n   * @return A Subscriber wrapping the (partially defined)\n   * Observer represented by the given arguments.\n   * @nocollapse\n   * @deprecated Do not use. Will be removed in v8. There is no replacement for this\n   * method, and there is no reason to be creating instances of `Subscriber` directly.\n   * If you have a specific use case, please file an issue.\n   */\n  static create<T>(next?: (x?: T) => void, error?: (e?: any) => void, complete?: () => void): Subscriber<T> {\n    return new SafeSubscriber(next, error, complete);\n  }\n\n  /** @deprecated Internal implementation detail, do not use directly. Will be made internal in v8. */\n  protected isStopped: boolean = false;\n  /** @deprecated Internal implementation detail, do not use directly. Will be made internal in v8. */\n  protected destination: Subscriber<any> | Observer<any>; // this `any` is the escape hatch to erase extra type param (e.g. R)\n\n  /**\n   * @deprecated Internal implementation detail, do not use directly. Will be made internal in v8.\n   * There is no reason to directly create an instance of Subscriber. This type is exported for typings reasons.\n   */\n  constructor(destination?: Subscriber<any> | Observer<any>) {\n    super();\n    if (destination) {\n      this.destination = destination;\n      // Automatically chain subscriptions together here.\n      // if destination is a Subscription, then it is a Subscriber.\n      if (isSubscription(destination)) {\n        destination.add(this);\n      }\n    } else {\n      this.destination = EMPTY_OBSERVER;\n    }\n  }\n\n  /**\n   * The {@link Observer} callback to receive notifications of type `next` from\n   * the Observable, with a value. The Observable may call this method 0 or more\n   * times.\n   * @param {T} [value] The `next` value.\n   * @return {void}\n   */\n  next(value?: T): void {\n    if (this.isStopped) {\n      handleStoppedNotification(nextNotification(value), this);\n    } else {\n      this._next(value!);\n    }\n  }\n\n  /**\n   * The {@link Observer} callback to receive notifications of type `error` from\n   * the Observable, with an attached `Error`. Notifies the Observer that\n   * the Observable has experienced an error condition.\n   * @param {any} [err] The `error` exception.\n   * @return {void}\n   */\n  error(err?: any): void {\n    if (this.isStopped) {\n      handleStoppedNotification(errorNotification(err), this);\n    } else {\n      this.isStopped = true;\n      this._error(err);\n    }\n  }\n\n  /**\n   * The {@link Observer} callback to receive a valueless notification of type\n   * `complete` from the Observable. Notifies the Observer that the Observable\n   * has finished sending push-based notifications.\n   * @return {void}\n   */\n  complete(): void {\n    if (this.isStopped) {\n      handleStoppedNotification(COMPLETE_NOTIFICATION, this);\n    } else {\n      this.isStopped = true;\n      this._complete();\n    }\n  }\n\n  unsubscribe(): void {\n    if (!this.closed) {\n      this.isStopped = true;\n      super.unsubscribe();\n      this.destination = null!;\n    }\n  }\n\n  protected _next(value: T): void {\n    this.destination.next(value);\n  }\n\n  protected _error(err: any): void {\n    try {\n      this.destination.error(err);\n    } finally {\n      this.unsubscribe();\n    }\n  }\n\n  protected _complete(): void {\n    try {\n      this.destination.complete();\n    } finally {\n      this.unsubscribe();\n    }\n  }\n}\n\n/**\n * This bind is captured here because we want to be able to have\n * compatibility with monoid libraries that tend to use a method named\n * `bind`. In particular, a library called Monio requires this.\n */\nconst _bind = Function.prototype.bind;\n\nfunction bind<Fn extends (...args: any[]) => any>(fn: Fn, thisArg: any): Fn {\n  return _bind.call(fn, thisArg);\n}\n\n/**\n * Internal optimization only, DO NOT EXPOSE.\n * @internal\n */\nclass ConsumerObserver<T> implements Observer<T> {\n  constructor(private partialObserver: Partial<Observer<T>>) {}\n\n  next(value: T): void {\n    const { partialObserver } = this;\n    if (partialObserver.next) {\n      try {\n        partialObserver.next(value);\n      } catch (error) {\n        handleUnhandledError(error);\n      }\n    }\n  }\n\n  error(err: any): void {\n    const { partialObserver } = this;\n    if (partialObserver.error) {\n      try {\n        partialObserver.error(err);\n      } catch (error) {\n        handleUnhandledError(error);\n      }\n    } else {\n      handleUnhandledError(err);\n    }\n  }\n\n  complete(): void {\n    const { partialObserver } = this;\n    if (partialObserver.complete) {\n      try {\n        partialObserver.complete();\n      } catch (error) {\n        handleUnhandledError(error);\n      }\n    }\n  }\n}\n\nexport class SafeSubscriber<T> extends Subscriber<T> {\n  constructor(\n    observerOrNext?: Partial<Observer<T>> | ((value: T) => void) | null,\n    error?: ((e?: any) => void) | null,\n    complete?: (() => void) | null\n  ) {\n    super();\n\n    let partialObserver: Partial<Observer<T>>;\n    if (isFunction(observerOrNext) || !observerOrNext) {\n      // The first argument is a function, not an observer. The next\n      // two arguments *could* be observers, or they could be empty.\n      partialObserver = {\n        next: (observerOrNext ?? undefined) as (((value: T) => void) | undefined),\n        error: error ?? undefined,\n        complete: complete ?? undefined,\n      };\n    } else {\n      // The first argument is a partial observer.\n      let context: any;\n      if (this && config.useDeprecatedNextContext) {\n        // This is a deprecated path that made `this.unsubscribe()` available in\n        // next handler functions passed to subscribe. This only exists behind a flag\n        // now, as it is *very* slow.\n        context = Object.create(observerOrNext);\n        context.unsubscribe = () => this.unsubscribe();\n        partialObserver = {\n          next: observerOrNext.next && bind(observerOrNext.next, context),\n          error: observerOrNext.error && bind(observerOrNext.error, context),\n          complete: observerOrNext.complete && bind(observerOrNext.complete, context),\n        };\n      } else {\n        // The \"normal\" path. Just use the partial observer directly.\n        partialObserver = observerOrNext;\n      }\n    }\n\n    // Wrap the partial observer to ensure it's a full observer, and\n    // make sure proper error handling is accounted for.\n    this.destination = new ConsumerObserver(partialObserver);\n  }\n}\n\nfunction handleUnhandledError(error: any) {\n  if (config.useDeprecatedSynchronousErrorHandling) {\n    captureError(error);\n  } else {\n    // Ideal path, we report this as an unhandled error,\n    // which is thrown on a new call stack.\n    reportUnhandledError(error);\n  }\n}\n\n/**\n * An error handler used when no error handler was supplied\n * to the SafeSubscriber -- meaning no error handler was supplied\n * do the `subscribe` call on our observable.\n * @param err The error to handle\n */\nfunction defaultErrorHandler(err: any) {\n  throw err;\n}\n\n/**\n * A handler for notifications that cannot be sent to a stopped subscriber.\n * @param notification The notification being sent\n * @param subscriber The stopped subscriber\n */\nfunction handleStoppedNotification(notification: ObservableNotification<any>, subscriber: Subscriber<any>) {\n  const { onStoppedNotification } = config;\n  onStoppedNotification && timeoutProvider.setTimeout(() => onStoppedNotification(notification, subscriber));\n}\n\n/**\n * The observer used as a stub for subscriptions where the user did not\n * pass any arguments to `subscribe`. Comes with the default error handling\n * behavior.\n */\nexport const EMPTY_OBSERVER: Readonly<Observer<any>> & { closed: true } = {\n  closed: true,\n  next: noop,\n  error: defaultErrorHandler,\n  complete: noop,\n};\n","import { isFunction } from './util/isFunction';\nimport { UnsubscriptionError } from './util/UnsubscriptionError';\nimport { SubscriptionLike, TeardownLogic, Unsubscribable } from './types';\nimport { arrRemove } from './util/arrRemove';\n\n/**\n * Represents a disposable resource, such as the execution of an Observable. A\n * Subscription has one important method, `unsubscribe`, that takes no argument\n * and just disposes the resource held by the subscription.\n *\n * Additionally, subscriptions may be grouped together through the `add()`\n * method, which will attach a child Subscription to the current Subscription.\n * When a Subscription is unsubscribed, all its children (and its grandchildren)\n * will be unsubscribed as well.\n *\n * @class Subscription\n */\nexport class Subscription implements SubscriptionLike {\n  /** @nocollapse */\n  public static EMPTY = (() => {\n    const empty = new Subscription();\n    empty.closed = true;\n    return empty;\n  })();\n\n  /**\n   * A flag to indicate whether this Subscription has already been unsubscribed.\n   */\n  public closed = false;\n\n  private _parentage: Subscription[] | Subscription | null = null;\n\n  /**\n   * The list of registered finalizers to execute upon unsubscription. Adding and removing from this\n   * list occurs in the {@link #add} and {@link #remove} methods.\n   */\n  private _finalizers: Exclude<TeardownLogic, void>[] | null = null;\n\n  /**\n   * @param initialTeardown A function executed first as part of the finalization\n   * process that is kicked off when {@link #unsubscribe} is called.\n   */\n  constructor(private initialTeardown?: () => void) {}\n\n  /**\n   * Disposes the resources held by the subscription. May, for instance, cancel\n   * an ongoing Observable execution or cancel any other type of work that\n   * started when the Subscription was created.\n   * @return {void}\n   */\n  unsubscribe(): void {\n    let errors: any[] | undefined;\n\n    if (!this.closed) {\n      this.closed = true;\n\n      // Remove this from it's parents.\n      const { _parentage } = this;\n      if (_parentage) {\n        this._parentage = null;\n        if (Array.isArray(_parentage)) {\n          for (const parent of _parentage) {\n            parent.remove(this);\n          }\n        } else {\n          _parentage.remove(this);\n        }\n      }\n\n      const { initialTeardown: initialFinalizer } = this;\n      if (isFunction(initialFinalizer)) {\n        try {\n          initialFinalizer();\n        } catch (e) {\n          errors = e instanceof UnsubscriptionError ? e.errors : [e];\n        }\n      }\n\n      const { _finalizers } = this;\n      if (_finalizers) {\n        this._finalizers = null;\n        for (const finalizer of _finalizers) {\n          try {\n            execFinalizer(finalizer);\n          } catch (err) {\n            errors = errors ?? [];\n            if (err instanceof UnsubscriptionError) {\n              errors = [...errors, ...err.errors];\n            } else {\n              errors.push(err);\n            }\n          }\n        }\n      }\n\n      if (errors) {\n        throw new UnsubscriptionError(errors);\n      }\n    }\n  }\n\n  /**\n   * Adds a finalizer to this subscription, so that finalization will be unsubscribed/called\n   * when this subscription is unsubscribed. If this subscription is already {@link #closed},\n   * because it has already been unsubscribed, then whatever finalizer is passed to it\n   * will automatically be executed (unless the finalizer itself is also a closed subscription).\n   *\n   * Closed Subscriptions cannot be added as finalizers to any subscription. Adding a closed\n   * subscription to a any subscription will result in no operation. (A noop).\n   *\n   * Adding a subscription to itself, or adding `null` or `undefined` will not perform any\n   * operation at all. (A noop).\n   *\n   * `Subscription` instances that are added to this instance will automatically remove themselves\n   * if they are unsubscribed. Functions and {@link Unsubscribable} objects that you wish to remove\n   * will need to be removed manually with {@link #remove}\n   *\n   * @param teardown The finalization logic to add to this subscription.\n   */\n  add(teardown: TeardownLogic): void {\n    // Only add the finalizer if it's not undefined\n    // and don't add a subscription to itself.\n    if (teardown && teardown !== this) {\n      if (this.closed) {\n        // If this subscription is already closed,\n        // execute whatever finalizer is handed to it automatically.\n        execFinalizer(teardown);\n      } else {\n        if (teardown instanceof Subscription) {\n          // We don't add closed subscriptions, and we don't add the same subscription\n          // twice. Subscription unsubscribe is idempotent.\n          if (teardown.closed || teardown._hasParent(this)) {\n            return;\n          }\n          teardown._addParent(this);\n        }\n        (this._finalizers = this._finalizers ?? []).push(teardown);\n      }\n    }\n  }\n\n  /**\n   * Checks to see if a this subscription already has a particular parent.\n   * This will signal that this subscription has already been added to the parent in question.\n   * @param parent the parent to check for\n   */\n  private _hasParent(parent: Subscription) {\n    const { _parentage } = this;\n    return _parentage === parent || (Array.isArray(_parentage) && _parentage.includes(parent));\n  }\n\n  /**\n   * Adds a parent to this subscription so it can be removed from the parent if it\n   * unsubscribes on it's own.\n   *\n   * NOTE: THIS ASSUMES THAT {@link _hasParent} HAS ALREADY BEEN CHECKED.\n   * @param parent The parent subscription to add\n   */\n  private _addParent(parent: Subscription) {\n    const { _parentage } = this;\n    this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;\n  }\n\n  /**\n   * Called on a child when it is removed via {@link #remove}.\n   * @param parent The parent to remove\n   */\n  private _removeParent(parent: Subscription) {\n    const { _parentage } = this;\n    if (_parentage === parent) {\n      this._parentage = null;\n    } else if (Array.isArray(_parentage)) {\n      arrRemove(_parentage, parent);\n    }\n  }\n\n  /**\n   * Removes a finalizer from this subscription that was previously added with the {@link #add} method.\n   *\n   * Note that `Subscription` instances, when unsubscribed, will automatically remove themselves\n   * from every other `Subscription` they have been added to. This means that using the `remove` method\n   * is not a common thing and should be used thoughtfully.\n   *\n   * If you add the same finalizer instance of a function or an unsubscribable object to a `Subscription` instance\n   * more than once, you will need to call `remove` the same number of times to remove all instances.\n   *\n   * All finalizer instances are removed to free up memory upon unsubscription.\n   *\n   * @param teardown The finalizer to remove from this subscription\n   */\n  remove(teardown: Exclude<TeardownLogic, void>): void {\n    const { _finalizers } = this;\n    _finalizers && arrRemove(_finalizers, teardown);\n\n    if (teardown instanceof Subscription) {\n      teardown._removeParent(this);\n    }\n  }\n}\n\nexport const EMPTY_SUBSCRIPTION = Subscription.EMPTY;\n\nexport function isSubscription(value: any): value is Subscription {\n  return (\n    value instanceof Subscription ||\n    (value && 'closed' in value && isFunction(value.remove) && isFunction(value.add) && isFunction(value.unsubscribe))\n  );\n}\n\nfunction execFinalizer(finalizer: Unsubscribable | (() => void)) {\n  if (isFunction(finalizer)) {\n    finalizer();\n  } else {\n    finalizer.unsubscribe();\n  }\n}\n","import { Subscriber } from './Subscriber';\nimport { ObservableNotification } from './types';\n\n/**\n * The {@link GlobalConfig} object for RxJS. It is used to configure things\n * like how to react on unhandled errors.\n */\nexport const config: GlobalConfig = {\n  onUnhandledError: null,\n  onStoppedNotification: null,\n  Promise: undefined,\n  useDeprecatedSynchronousErrorHandling: false,\n  useDeprecatedNextContext: false,\n};\n\n/**\n * The global configuration object for RxJS, used to configure things\n * like how to react on unhandled errors. Accessible via {@link config}\n * object.\n */\nexport interface GlobalConfig {\n  /**\n   * A registration point for unhandled errors from RxJS. These are errors that\n   * cannot were not handled by consuming code in the usual subscription path. For\n   * example, if you have this configured, and you subscribe to an observable without\n   * providing an error handler, errors from that subscription will end up here. This\n   * will _always_ be called asynchronously on another job in the runtime. This is because\n   * we do not want errors thrown in this user-configured handler to interfere with the\n   * behavior of the library.\n   */\n  onUnhandledError: ((err: any) => void) | null;\n\n  /**\n   * A registration point for notifications that cannot be sent to subscribers because they\n   * have completed, errored or have been explicitly unsubscribed. By default, next, complete\n   * and error notifications sent to stopped subscribers are noops. However, sometimes callers\n   * might want a different behavior. For example, with sources that attempt to report errors\n   * to stopped subscribers, a caller can configure RxJS to throw an unhandled error instead.\n   * This will _always_ be called asynchronously on another job in the runtime. This is because\n   * we do not want errors thrown in this user-configured handler to interfere with the\n   * behavior of the library.\n   */\n  onStoppedNotification: ((notification: ObservableNotification<any>, subscriber: Subscriber<any>) => void) | null;\n\n  /**\n   * The promise constructor used by default for {@link Observable#toPromise toPromise} and {@link Observable#forEach forEach}\n   * methods.\n   *\n   * @deprecated As of version 8, RxJS will no longer support this sort of injection of a\n   * Promise constructor. If you need a Promise implementation other than native promises,\n   * please polyfill/patch Promise as you see appropriate. Will be removed in v8.\n   */\n  Promise?: PromiseConstructorLike;\n\n  /**\n   * If true, turns on synchronous error rethrowing, which is a deprecated behavior\n   * in v6 and higher. This behavior enables bad patterns like wrapping a subscribe\n   * call in a try/catch block. It also enables producer interference, a nasty bug\n   * where a multicast can be broken for all observers by a downstream consumer with\n   * an unhandled error. DO NOT USE THIS FLAG UNLESS IT'S NEEDED TO BUY TIME\n   * FOR MIGRATION REASONS.\n   *\n   * @deprecated As of version 8, RxJS will no longer support synchronous throwing\n   * of unhandled errors. All errors will be thrown on a separate call stack to prevent bad\n   * behaviors described above. Will be removed in v8.\n   */\n  useDeprecatedSynchronousErrorHandling: boolean;\n\n  /**\n   * If true, enables an as-of-yet undocumented feature from v5: The ability to access\n   * `unsubscribe()` via `this` context in `next` functions created in observers passed\n   * to `subscribe`.\n   *\n   * This is being removed because the performance was severely problematic, and it could also cause\n   * issues when types other than POJOs are passed to subscribe as subscribers, as they will likely have\n   * their `this` context overwritten.\n   *\n   * @deprecated As of version 8, RxJS will no longer support altering the\n   * context of next functions provided as part of an observer to Subscribe. Instead,\n   * you will have access to a subscription or a signal or token that will allow you to do things like\n   * unsubscribe and test closed status. Will be removed in v8.\n   */\n  useDeprecatedNextContext: boolean;\n}\n","import { Observable } from './Observable';\nimport { EmptyError } from './util/EmptyError';\nimport { SafeSubscriber } from './Subscriber';\n\nexport interface FirstValueFromConfig<T> {\n  defaultValue: T;\n}\n\nexport function firstValueFrom<T, D>(source: Observable<T>, config: FirstValueFromConfig<D>): Promise<T | D>;\nexport function firstValueFrom<T>(source: Observable<T>): Promise<T>;\n\n/**\n * Converts an observable to a promise by subscribing to the observable,\n * and returning a promise that will resolve as soon as the first value\n * arrives from the observable. The subscription will then be closed.\n *\n * If the observable stream completes before any values were emitted, the\n * returned promise will reject with {@link EmptyError} or will resolve\n * with the default value if a default was specified.\n *\n * If the observable stream emits an error, the returned promise will reject\n * with that error.\n *\n * **WARNING**: Only use this with observables you *know* will emit at least one value,\n * *OR* complete. If the source observable does not emit one value or complete, you will\n * end up with a promise that is hung up, and potentially all of the state of an\n * async function hanging out in memory. To avoid this situation, look into adding\n * something like {@link timeout}, {@link take}, {@link takeWhile}, or {@link takeUntil}\n * amongst others.\n *\n * ## Example\n *\n * Wait for the first value from a stream and emit it from a promise in\n * an async function\n *\n * ```ts\n * import { interval, firstValueFrom } from 'rxjs';\n *\n * async function execute() {\n *   const source$ = interval(2000);\n *   const firstNumber = await firstValueFrom(source$);\n *   console.log(`The first number is ${ firstNumber }`);\n * }\n *\n * execute();\n *\n * // Expected output:\n * // 'The first number is 0'\n * ```\n *\n * @see {@link lastValueFrom}\n *\n * @param source the observable to convert to a promise\n * @param config a configuration object to define the `defaultValue` to use if the source completes without emitting a value\n */\nexport function firstValueFrom<T, D>(source: Observable<T>, config?: FirstValueFromConfig<D>): Promise<T | D> {\n  const hasConfig = typeof config === 'object';\n  return new Promise<T | D>((resolve, reject) => {\n    const subscriber = new SafeSubscriber<T>({\n      next: (value) => {\n        resolve(value);\n        subscriber.unsubscribe();\n      },\n      error: reject,\n      complete: () => {\n        if (hasConfig) {\n          resolve(config!.defaultValue);\n        } else {\n          reject(new EmptyError());\n        }\n      },\n    });\n    source.subscribe(subscriber);\n  });\n}\n","import { Observable } from './Observable';\nimport { EmptyError } from './util/EmptyError';\n\nexport interface LastValueFromConfig<T> {\n  defaultValue: T;\n}\n\nexport function lastValueFrom<T, D>(source: Observable<T>, config: LastValueFromConfig<D>): Promise<T | D>;\nexport function lastValueFrom<T>(source: Observable<T>): Promise<T>;\n\n/**\n * Converts an observable to a promise by subscribing to the observable,\n * waiting for it to complete, and resolving the returned promise with the\n * last value from the observed stream.\n *\n * If the observable stream completes before any values were emitted, the\n * returned promise will reject with {@link EmptyError} or will resolve\n * with the default value if a default was specified.\n *\n * If the observable stream emits an error, the returned promise will reject\n * with that error.\n *\n * **WARNING**: Only use this with observables you *know* will complete. If the source\n * observable does not complete, you will end up with a promise that is hung up, and\n * potentially all of the state of an async function hanging out in memory. To avoid\n * this situation, look into adding something like {@link timeout}, {@link take},\n * {@link takeWhile}, or {@link takeUntil} amongst others.\n *\n * ## Example\n *\n * Wait for the last value from a stream and emit it from a promise in\n * an async function\n *\n * ```ts\n * import { interval, take, lastValueFrom } from 'rxjs';\n *\n * async function execute() {\n *   const source$ = interval(2000).pipe(take(10));\n *   const finalNumber = await lastValueFrom(source$);\n *   console.log(`The final number is ${ finalNumber }`);\n * }\n *\n * execute();\n *\n * // Expected output:\n * // 'The final number is 9'\n * ```\n *\n * @see {@link firstValueFrom}\n *\n * @param source the observable to convert to a promise\n * @param config a configuration object to define the `defaultValue` to use if the source completes without emitting a value\n */\nexport function lastValueFrom<T, D>(source: Observable<T>, config?: LastValueFromConfig<D>): Promise<T | D> {\n  const hasConfig = typeof config === 'object';\n  return new Promise<T | D>((resolve, reject) => {\n    let _hasValue = false;\n    let _value: T;\n    source.subscribe({\n      next: (value) => {\n        _value = value;\n        _hasValue = true;\n      },\n      error: reject,\n      complete: () => {\n        if (_hasValue) {\n          resolve(_value);\n        } else if (hasConfig) {\n          resolve(config!.defaultValue);\n        } else {\n          reject(new EmptyError());\n        }\n      },\n    });\n  });\n}\n","import { Subject } from '../Subject';\nimport { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\nimport { refCount as higherOrderRefCount } from '../operators/refCount';\nimport { createOperatorSubscriber } from '../operators/OperatorSubscriber';\nimport { hasLift } from '../util/lift';\n\n/**\n * @class ConnectableObservable<T>\n * @deprecated Will be removed in v8. Use {@link connectable} to create a connectable observable.\n * If you are using the `refCount` method of `ConnectableObservable`, use the {@link share} operator\n * instead.\n * Details: https://rxjs.dev/deprecations/multicasting\n */\nexport class ConnectableObservable<T> extends Observable<T> {\n  protected _subject: Subject<T> | null = null;\n  protected _refCount: number = 0;\n  protected _connection: Subscription | null = null;\n\n  /**\n   * @param source The source observable\n   * @param subjectFactory The factory that creates the subject used internally.\n   * @deprecated Will be removed in v8. Use {@link connectable} to create a connectable observable.\n   * `new ConnectableObservable(source, factory)` is equivalent to\n   * `connectable(source, { connector: factory })`.\n   * When the `refCount()` method is needed, the {@link share} operator should be used instead:\n   * `new ConnectableObservable(source, factory).refCount()` is equivalent to\n   * `source.pipe(share({ connector: factory }))`.\n   * Details: https://rxjs.dev/deprecations/multicasting\n   */\n  constructor(public source: Observable<T>, protected subjectFactory: () => Subject<T>) {\n    super();\n    // If we have lift, monkey patch that here. This is done so custom observable\n    // types will compose through multicast. Otherwise the resulting observable would\n    // simply be an instance of `ConnectableObservable`.\n    if (hasLift(source)) {\n      this.lift = source.lift;\n    }\n  }\n\n  /** @internal */\n  protected _subscribe(subscriber: Subscriber<T>) {\n    return this.getSubject().subscribe(subscriber);\n  }\n\n  protected getSubject(): Subject<T> {\n    const subject = this._subject;\n    if (!subject || subject.isStopped) {\n      this._subject = this.subjectFactory();\n    }\n    return this._subject!;\n  }\n\n  protected _teardown() {\n    this._refCount = 0;\n    const { _connection } = this;\n    this._subject = this._connection = null;\n    _connection?.unsubscribe();\n  }\n\n  /**\n   * @deprecated {@link ConnectableObservable} will be removed in v8. Use {@link connectable} instead.\n   * Details: https://rxjs.dev/deprecations/multicasting\n   */\n  connect(): Subscription {\n    let connection = this._connection;\n    if (!connection) {\n      connection = this._connection = new Subscription();\n      const subject = this.getSubject();\n      connection.add(\n        this.source.subscribe(\n          createOperatorSubscriber(\n            subject as any,\n            undefined,\n            () => {\n              this._teardown();\n              subject.complete();\n            },\n            (err) => {\n              this._teardown();\n              subject.error(err);\n            },\n            () => this._teardown()\n          )\n        )\n      );\n\n      if (connection.closed) {\n        this._connection = null;\n        connection = Subscription.EMPTY;\n      }\n    }\n    return connection;\n  }\n\n  /**\n   * @deprecated {@link ConnectableObservable} will be removed in v8. Use the {@link share} operator instead.\n   * Details: https://rxjs.dev/deprecations/multicasting\n   */\n  refCount(): Observable<T> {\n    return higherOrderRefCount()(this) as Observable<T>;\n  }\n}\n","/* @prettier */\nimport { SchedulerLike } from '../types';\nimport { Observable } from '../Observable';\nimport { bindCallbackInternals } from './bindCallbackInternals';\n\nexport function bindCallback(\n  callbackFunc: (...args: any[]) => void,\n  resultSelector: (...args: any[]) => any,\n  scheduler?: SchedulerLike\n): (...args: any[]) => Observable<any>;\n\n// args is the arguments array and we push the callback on the rest tuple since the rest parameter must be last (only item) in a parameter list\nexport function bindCallback<A extends readonly unknown[], R extends readonly unknown[]>(\n  callbackFunc: (...args: [...A, (...res: R) => void]) => void,\n  schedulerLike?: SchedulerLike\n): (...arg: A) => Observable<R extends [] ? void : R extends [any] ? R[0] : R>;\n\n/**\n * Converts a callback API to a function that returns an Observable.\n *\n * <span class=\"informal\">Give it a function `f` of type `f(x, callback)` and\n * it will return a function `g` that when called as `g(x)` will output an\n * Observable.</span>\n *\n * `bindCallback` is not an operator because its input and output are not\n * Observables. The input is a function `func` with some parameters. The\n * last parameter must be a callback function that `func` calls when it is\n * done.\n *\n * The output of `bindCallback` is a function that takes the same parameters\n * as `func`, except the last one (the callback). When the output function\n * is called with arguments it will return an Observable. If function `func`\n * calls its callback with one argument, the Observable will emit that value.\n * If on the other hand the callback is called with multiple values the resulting\n * Observable will emit an array with said values as arguments.\n *\n * It is **very important** to remember that input function `func` is not called\n * when the output function is, but rather when the Observable returned by the output\n * function is subscribed. This means if `func` makes an AJAX request, that request\n * will be made every time someone subscribes to the resulting Observable, but not before.\n *\n * The last optional parameter - `scheduler` - can be used to control when the call\n * to `func` happens after someone subscribes to Observable, as well as when results\n * passed to callback will be emitted. By default, the subscription to an Observable calls `func`\n * synchronously, but using {@link asyncScheduler} as the last parameter will defer the call to `func`,\n * just like wrapping the call in `setTimeout` with a timeout of `0` would. If you were to use the async Scheduler\n * and call `subscribe` on the output Observable, all function calls that are currently executing\n * will end before `func` is invoked.\n *\n * By default, results passed to the callback are emitted immediately after `func` invokes the callback.\n * In particular, if the callback is called synchronously, then the subscription of the resulting Observable\n * will call the `next` function synchronously as well.  If you want to defer that call,\n * you may use {@link asyncScheduler} just as before.  This means that by using `Scheduler.async` you can\n * ensure that `func` always calls its callback asynchronously, thus avoiding terrifying Zalgo.\n *\n * Note that the Observable created by the output function will always emit a single value\n * and then complete immediately. If `func` calls the callback multiple times, values from subsequent\n * calls will not appear in the stream. If you need to listen for multiple calls,\n *  you probably want to use {@link fromEvent} or {@link fromEventPattern} instead.\n *\n * If `func` depends on some context (`this` property) and is not already bound, the context of `func`\n * will be the context that the output function has at call time. In particular, if `func`\n * is called as a method of some object and if `func` is not already bound, in order to preserve the context\n * it is recommended that the context of the output function is set to that object as well.\n *\n * If the input function calls its callback in the \"node style\" (i.e. first argument to callback is\n * optional error parameter signaling whether the call failed or not), {@link bindNodeCallback}\n * provides convenient error handling and probably is a better choice.\n * `bindCallback` will treat such functions the same as any other and error parameters\n * (whether passed or not) will always be interpreted as regular callback argument.\n *\n * ## Examples\n *\n * ### Convert jQuery's getJSON to an Observable API\n * ```ts\n * import { bindCallback } from 'rxjs';\n * import * as jQuery from 'jquery';\n *\n * // Suppose we have jQuery.getJSON('/my/url', callback)\n * const getJSONAsObservable = bindCallback(jQuery.getJSON);\n * const result = getJSONAsObservable('/my/url');\n * result.subscribe(x => console.log(x), e => console.error(e));\n * ```\n *\n * ### Receive an array of arguments passed to a callback\n * ```ts\n * import { bindCallback } from 'rxjs';\n *\n * const someFunction = (n, s, cb) => {\n *   cb(n, s, { someProperty: 'someValue' });\n * };\n *\n * const boundSomeFunction = bindCallback(someFunction);\n * boundSomeFunction(5, 'some string').subscribe((values) => {\n *   console.log(values); // [5, 'some string', {someProperty: 'someValue'}]\n * });\n * ```\n *\n * ### Compare behaviour with and without async Scheduler\n * ```ts\n * import { bindCallback, asyncScheduler } from 'rxjs';\n *\n * function iCallMyCallbackSynchronously(cb) {\n *   cb();\n * }\n *\n * const boundSyncFn = bindCallback(iCallMyCallbackSynchronously);\n * const boundAsyncFn = bindCallback(iCallMyCallbackSynchronously, null, asyncScheduler);\n *\n * boundSyncFn().subscribe(() => console.log('I was sync!'));\n * boundAsyncFn().subscribe(() => console.log('I was async!'));\n * console.log('This happened...');\n *\n * // Logs:\n * // I was sync!\n * // This happened...\n * // I was async!\n * ```\n *\n * ### Use bindCallback on an object method\n * ```ts\n * import { bindCallback } from 'rxjs';\n *\n * const boundMethod = bindCallback(someObject.methodWithCallback);\n * boundMethod\n *   .call(someObject) // make sure methodWithCallback has access to someObject\n *   .subscribe(subscriber);\n * ```\n *\n * @see {@link bindNodeCallback}\n * @see {@link from}\n *\n * @param {function} func A function with a callback as the last parameter.\n * @param {SchedulerLike} [scheduler] The scheduler on which to schedule the\n * callbacks.\n * @return {function(...params: *): Observable} A function which returns the\n * Observable that delivers the same values the callback would deliver.\n */\nexport function bindCallback(\n  callbackFunc: (...args: [...any[], (...res: any) => void]) => void,\n  resultSelector?: ((...args: any[]) => any) | SchedulerLike,\n  scheduler?: SchedulerLike\n): (...args: any[]) => Observable<unknown> {\n  return bindCallbackInternals(false, callbackFunc, resultSelector, scheduler);\n}\n","import { SchedulerLike } from '../types';\nimport { isScheduler } from '../util/isScheduler';\nimport { Observable } from '../Observable';\nimport { subscribeOn } from '../operators/subscribeOn';\nimport { mapOneOrManyArgs } from '../util/mapOneOrManyArgs';\nimport { observeOn } from '../operators/observeOn';\nimport { AsyncSubject } from '../AsyncSubject';\n\nexport function bindCallbackInternals(\n  isNodeStyle: boolean,\n  callbackFunc: any,\n  resultSelector?: any,\n  scheduler?: SchedulerLike\n): (...args: any[]) => Observable<unknown> {\n  if (resultSelector) {\n    if (isScheduler(resultSelector)) {\n      scheduler = resultSelector;\n    } else {\n      // The user provided a result selector.\n      return function (this: any, ...args: any[]) {\n        return (bindCallbackInternals(isNodeStyle, callbackFunc, scheduler) as any)\n          .apply(this, args)\n          .pipe(mapOneOrManyArgs(resultSelector as any));\n      };\n    }\n  }\n\n  // If a scheduler was passed, use our `subscribeOn` and `observeOn` operators\n  // to compose that behavior for the user.\n  if (scheduler) {\n    return function (this: any, ...args: any[]) {\n      return (bindCallbackInternals(isNodeStyle, callbackFunc) as any)\n        .apply(this, args)\n        .pipe(subscribeOn(scheduler!), observeOn(scheduler!));\n    };\n  }\n\n  return function (this: any, ...args: any[]): Observable<any> {\n    // We're using AsyncSubject, because it emits when it completes,\n    // and it will play the value to all late-arriving subscribers.\n    const subject = new AsyncSubject<any>();\n\n    // If this is true, then we haven't called our function yet.\n    let uninitialized = true;\n    return new Observable((subscriber) => {\n      // Add our subscriber to the subject.\n      const subs = subject.subscribe(subscriber);\n\n      if (uninitialized) {\n        uninitialized = false;\n        // We're going to execute the bound function\n        // This bit is to signal that we are hitting the callback asynchronously.\n        // Because we don't have any anti-\"Zalgo\" guarantees with whatever\n        // function we are handed, we use this bit to figure out whether or not\n        // we are getting hit in a callback synchronously during our call.\n        let isAsync = false;\n\n        // This is used to signal that the callback completed synchronously.\n        let isComplete = false;\n\n        // Call our function that has a callback. If at any time during this\n        // call, an error is thrown, it will be caught by the Observable\n        // subscription process and sent to the consumer.\n        callbackFunc.apply(\n          // Pass the appropriate `this` context.\n          this,\n          [\n            // Pass the arguments.\n            ...args,\n            // And our callback handler.\n            (...results: any[]) => {\n              if (isNodeStyle) {\n                // If this is a node callback, shift the first value off of the\n                // results and check it, as it is the error argument. By shifting,\n                // we leave only the argument(s) we want to pass to the consumer.\n                const err = results.shift();\n                if (err != null) {\n                  subject.error(err);\n                  // If we've errored, we can stop processing this function\n                  // as there's nothing else to do. Just return to escape.\n                  return;\n                }\n              }\n              // If we have one argument, notify the consumer\n              // of it as a single value, otherwise, if there's more than one, pass\n              // them as an array. Note that if there are no arguments, `undefined`\n              // will be emitted.\n              subject.next(1 < results.length ? results : results[0]);\n              // Flip this flag, so we know we can complete it in the synchronous\n              // case below.\n              isComplete = true;\n              // If we're not asynchronous, we need to defer the `complete` call\n              // until after the call to the function is over. This is because an\n              // error could be thrown in the function after it calls our callback,\n              // and if that is the case, if we complete here, we are unable to notify\n              // the consumer than an error occurred.\n              if (isAsync) {\n                subject.complete();\n              }\n            },\n          ]\n        );\n        // If we flipped `isComplete` during the call, we resolved synchronously,\n        // notify complete, because we skipped it in the callback to wait\n        // to make sure there were no errors during the call.\n        if (isComplete) {\n          subject.complete();\n        }\n\n        // We're no longer synchronous. If the callback is called at this point\n        // we can notify complete on the spot.\n        isAsync = true;\n      }\n\n      // Return the subscription from adding our subscriber to the subject.\n      return subs;\n    });\n  };\n}\n","/* @prettier */\nimport { Observable } from '../Observable';\nimport { SchedulerLike } from '../types';\nimport { bindCallbackInternals } from './bindCallbackInternals';\n\nexport function bindNodeCallback(\n  callbackFunc: (...args: any[]) => void,\n  resultSelector: (...args: any[]) => any,\n  scheduler?: SchedulerLike\n): (...args: any[]) => Observable<any>;\n\n// args is the arguments array and we push the callback on the rest tuple since the rest parameter must be last (only item) in a parameter list\nexport function bindNodeCallback<A extends readonly unknown[], R extends readonly unknown[]>(\n  callbackFunc: (...args: [...A, (err: any, ...res: R) => void]) => void,\n  schedulerLike?: SchedulerLike\n): (...arg: A) => Observable<R extends [] ? void : R extends [any] ? R[0] : R>;\n\n/**\n * Converts a Node.js-style callback API to a function that returns an\n * Observable.\n *\n * <span class=\"informal\">It's just like {@link bindCallback}, but the\n * callback is expected to be of type `callback(error, result)`.</span>\n *\n * `bindNodeCallback` is not an operator because its input and output are not\n * Observables. The input is a function `func` with some parameters, but the\n * last parameter must be a callback function that `func` calls when it is\n * done. The callback function is expected to follow Node.js conventions,\n * where the first argument to the callback is an error object, signaling\n * whether call was successful. If that object is passed to callback, it means\n * something went wrong.\n *\n * The output of `bindNodeCallback` is a function that takes the same\n * parameters as `func`, except the last one (the callback). When the output\n * function is called with arguments, it will return an Observable.\n * If `func` calls its callback with error parameter present, Observable will\n * error with that value as well. If error parameter is not passed, Observable will emit\n * second parameter. If there are more parameters (third and so on),\n * Observable will emit an array with all arguments, except first error argument.\n *\n * Note that `func` will not be called at the same time output function is,\n * but rather whenever resulting Observable is subscribed. By default call to\n * `func` will happen synchronously after subscription, but that can be changed\n * with proper `scheduler` provided as optional third parameter. {@link SchedulerLike}\n * can also control when values from callback will be emitted by Observable.\n * To find out more, check out documentation for {@link bindCallback}, where\n * {@link SchedulerLike} works exactly the same.\n *\n * As in {@link bindCallback}, context (`this` property) of input function will be set to context\n * of returned function, when it is called.\n *\n * After Observable emits value, it will complete immediately. This means\n * even if `func` calls callback again, values from second and consecutive\n * calls will never appear on the stream. If you need to handle functions\n * that call callbacks multiple times, check out {@link fromEvent} or\n * {@link fromEventPattern} instead.\n *\n * Note that `bindNodeCallback` can be used in non-Node.js environments as well.\n * \"Node.js-style\" callbacks are just a convention, so if you write for\n * browsers or any other environment and API you use implements that callback style,\n * `bindNodeCallback` can be safely used on that API functions as well.\n *\n * Remember that Error object passed to callback does not have to be an instance\n * of JavaScript built-in `Error` object. In fact, it does not even have to an object.\n * Error parameter of callback function is interpreted as \"present\", when value\n * of that parameter is truthy. It could be, for example, non-zero number, non-empty\n * string or boolean `true`. In all of these cases resulting Observable would error\n * with that value. This means usually regular style callbacks will fail very often when\n * `bindNodeCallback` is used. If your Observable errors much more often then you\n * would expect, check if callback really is called in Node.js-style and, if not,\n * switch to {@link bindCallback} instead.\n *\n * Note that even if error parameter is technically present in callback, but its value\n * is falsy, it still won't appear in array emitted by Observable.\n *\n * ## Examples\n * ###  Read a file from the filesystem and get the data as an Observable\n * ```ts\n * import * as fs from 'fs';\n * const readFileAsObservable = bindNodeCallback(fs.readFile);\n * const result = readFileAsObservable('./roadNames.txt', 'utf8');\n * result.subscribe(x => console.log(x), e => console.error(e));\n * ```\n *\n * ### Use on function calling callback with multiple arguments\n * ```ts\n * someFunction((err, a, b) => {\n *   console.log(err); // null\n *   console.log(a); // 5\n *   console.log(b); // \"some string\"\n * });\n * const boundSomeFunction = bindNodeCallback(someFunction);\n * boundSomeFunction()\n * .subscribe(value => {\n *   console.log(value); // [5, \"some string\"]\n * });\n * ```\n *\n * ### Use on function calling callback in regular style\n * ```ts\n * someFunction(a => {\n *   console.log(a); // 5\n * });\n * const boundSomeFunction = bindNodeCallback(someFunction);\n * boundSomeFunction()\n * .subscribe(\n *   value => {}             // never gets called\n *   err => console.log(err) // 5\n * );\n * ```\n *\n * @see {@link bindCallback}\n * @see {@link from}\n *\n * @param {function} func Function with a Node.js-style callback as the last parameter.\n * @param {SchedulerLike} [scheduler] The scheduler on which to schedule the\n * callbacks.\n * @return {function(...params: *): Observable} A function which returns the\n * Observable that delivers the same values the Node.js callback would\n * deliver.\n */\nexport function bindNodeCallback(\n  callbackFunc: (...args: [...any[], (err: any, ...res: any) => void]) => void,\n  resultSelector?: ((...args: any[]) => any) | SchedulerLike,\n  scheduler?: SchedulerLike\n): (...args: any[]) => Observable<any> {\n  return bindCallbackInternals(true, callbackFunc, resultSelector, scheduler);\n}\n","import { Observable } from '../Observable';\nimport { ObservableInput, SchedulerLike, ObservedValueOf, ObservableInputTuple } from '../types';\nimport { argsArgArrayOrObject } from '../util/argsArgArrayOrObject';\nimport { Subscriber } from '../Subscriber';\nimport { from } from './from';\nimport { identity } from '../util/identity';\nimport { Subscription } from '../Subscription';\nimport { mapOneOrManyArgs } from '../util/mapOneOrManyArgs';\nimport { popResultSelector, popScheduler } from '../util/args';\nimport { createObject } from '../util/createObject';\nimport { createOperatorSubscriber } from '../operators/OperatorSubscriber';\nimport { AnyCatcher } from '../AnyCatcher';\nimport { executeSchedule } from '../util/executeSchedule';\n\n// combineLatest(any)\n// We put this first because we need to catch cases where the user has supplied\n// _exactly `any`_ as the argument. Since `any` literally matches _anything_,\n// we don't want it to randomly hit one of the other type signatures below,\n// as we have no idea at build-time what type we should be returning when given an any.\n\n/**\n * You have passed `any` here, we can't figure out if it is\n * an array or an object, so you're getting `unknown`. Use better types.\n * @param arg Something typed as `any`\n */\nexport function combineLatest<T extends AnyCatcher>(arg: T): Observable<unknown>;\n\n// combineLatest([a, b, c])\nexport function combineLatest(sources: []): Observable<never>;\nexport function combineLatest<A extends readonly unknown[]>(sources: readonly [...ObservableInputTuple<A>]): Observable<A>;\n/** @deprecated The `scheduler` parameter will be removed in v8. Use `scheduled` and `combineLatestAll`. Details: https://rxjs.dev/deprecations/scheduler-argument */\nexport function combineLatest<A extends readonly unknown[], R>(\n  sources: readonly [...ObservableInputTuple<A>],\n  resultSelector: (...values: A) => R,\n  scheduler: SchedulerLike\n): Observable<R>;\nexport function combineLatest<A extends readonly unknown[], R>(\n  sources: readonly [...ObservableInputTuple<A>],\n  resultSelector: (...values: A) => R\n): Observable<R>;\n/** @deprecated The `scheduler` parameter will be removed in v8. Use `scheduled` and `combineLatestAll`. Details: https://rxjs.dev/deprecations/scheduler-argument */\nexport function combineLatest<A extends readonly unknown[]>(\n  sources: readonly [...ObservableInputTuple<A>],\n  scheduler: SchedulerLike\n): Observable<A>;\n\n// combineLatest(a, b, c)\n/** @deprecated Pass an array of sources instead. The rest-parameters signature will be removed in v8. Details: https://rxjs.dev/deprecations/array-argument */\nexport function combineLatest<A extends readonly unknown[]>(...sources: [...ObservableInputTuple<A>]): Observable<A>;\n/** @deprecated The `scheduler` parameter will be removed in v8. Use `scheduled` and `combineLatestAll`. Details: https://rxjs.dev/deprecations/scheduler-argument */\nexport function combineLatest<A extends readonly unknown[], R>(\n  ...sourcesAndResultSelectorAndScheduler: [...ObservableInputTuple<A>, (...values: A) => R, SchedulerLike]\n): Observable<R>;\n/** @deprecated Pass an array of sources instead. The rest-parameters signature will be removed in v8. Details: https://rxjs.dev/deprecations/array-argument */\nexport function combineLatest<A extends readonly unknown[], R>(\n  ...sourcesAndResultSelector: [...ObservableInputTuple<A>, (...values: A) => R]\n): Observable<R>;\n/** @deprecated The `scheduler` parameter will be removed in v8. Use `scheduled` and `combineLatestAll`. Details: https://rxjs.dev/deprecations/scheduler-argument */\nexport function combineLatest<A extends readonly unknown[]>(\n  ...sourcesAndScheduler: [...ObservableInputTuple<A>, SchedulerLike]\n): Observable<A>;\n\n// combineLatest({a, b, c})\nexport function combineLatest(sourcesObject: { [K in any]: never }): Observable<never>;\nexport function combineLatest<T extends Record<string, ObservableInput<any>>>(\n  sourcesObject: T\n): Observable<{ [K in keyof T]: ObservedValueOf<T[K]> }>;\n\n/**\n * Combines multiple Observables to create an Observable whose values are\n * calculated from the latest values of each of its input Observables.\n *\n * <span class=\"informal\">Whenever any input Observable emits a value, it\n * computes a formula using the latest values from all the inputs, then emits\n * the output of that formula.</span>\n *\n * ![](combineLatest.png)\n *\n * `combineLatest` combines the values from all the Observables passed in the\n * observables array. This is done by subscribing to each Observable in order and,\n * whenever any Observable emits, collecting an array of the most recent\n * values from each Observable. So if you pass `n` Observables to this operator,\n * the returned Observable will always emit an array of `n` values, in an order\n * corresponding to the order of the passed Observables (the value from the first Observable\n * will be at index 0 of the array and so on).\n *\n * Static version of `combineLatest` accepts an array of Observables. Note that an array of\n * Observables is a good choice, if you don't know beforehand how many Observables\n * you will combine. Passing an empty array will result in an Observable that\n * completes immediately.\n *\n * To ensure the output array always has the same length, `combineLatest` will\n * actually wait for all input Observables to emit at least once,\n * before it starts emitting results. This means if some Observable emits\n * values before other Observables started emitting, all these values but the last\n * will be lost. On the other hand, if some Observable does not emit a value but\n * completes, resulting Observable will complete at the same moment without\n * emitting anything, since it will now be impossible to include a value from the\n * completed Observable in the resulting array. Also, if some input Observable does\n * not emit any value and never completes, `combineLatest` will also never emit\n * and never complete, since, again, it will wait for all streams to emit some\n * value.\n *\n * If at least one Observable was passed to `combineLatest` and all passed Observables\n * emitted something, the resulting Observable will complete when all combined\n * streams complete. So even if some Observable completes, the result of\n * `combineLatest` will still emit values when other Observables do. In case\n * of a completed Observable, its value from now on will always be the last\n * emitted value. On the other hand, if any Observable errors, `combineLatest`\n * will error immediately as well, and all other Observables will be unsubscribed.\n *\n * ## Examples\n *\n * Combine two timer Observables\n *\n * ```ts\n * import { timer, combineLatest } from 'rxjs';\n *\n * const firstTimer = timer(0, 1000); // emit 0, 1, 2... after every second, starting from now\n * const secondTimer = timer(500, 1000); // emit 0, 1, 2... after every second, starting 0,5s from now\n * const combinedTimers = combineLatest([firstTimer, secondTimer]);\n * combinedTimers.subscribe(value => console.log(value));\n * // Logs\n * // [0, 0] after 0.5s\n * // [1, 0] after 1s\n * // [1, 1] after 1.5s\n * // [2, 1] after 2s\n * ```\n *\n * Combine a dictionary of Observables\n *\n * ```ts\n * import { of, delay, startWith, combineLatest } from 'rxjs';\n *\n * const observables = {\n *   a: of(1).pipe(delay(1000), startWith(0)),\n *   b: of(5).pipe(delay(5000), startWith(0)),\n *   c: of(10).pipe(delay(10000), startWith(0))\n * };\n * const combined = combineLatest(observables);\n * combined.subscribe(value => console.log(value));\n * // Logs\n * // { a: 0, b: 0, c: 0 } immediately\n * // { a: 1, b: 0, c: 0 } after 1s\n * // { a: 1, b: 5, c: 0 } after 5s\n * // { a: 1, b: 5, c: 10 } after 10s\n * ```\n *\n * Combine an array of Observables\n *\n * ```ts\n * import { of, delay, startWith, combineLatest } from 'rxjs';\n *\n * const observables = [1, 5, 10].map(\n *   n => of(n).pipe(\n *     delay(n * 1000), // emit 0 and then emit n after n seconds\n *     startWith(0)\n *   )\n * );\n * const combined = combineLatest(observables);\n * combined.subscribe(value => console.log(value));\n * // Logs\n * // [0, 0, 0] immediately\n * // [1, 0, 0] after 1s\n * // [1, 5, 0] after 5s\n * // [1, 5, 10] after 10s\n * ```\n *\n * Use map operator to dynamically calculate the Body-Mass Index\n *\n * ```ts\n * import { of, combineLatest, map } from 'rxjs';\n *\n * const weight = of(70, 72, 76, 79, 75);\n * const height = of(1.76, 1.77, 1.78);\n * const bmi = combineLatest([weight, height]).pipe(\n *   map(([w, h]) => w / (h * h)),\n * );\n * bmi.subscribe(x => console.log('BMI is ' + x));\n *\n * // With output to console:\n * // BMI is 24.212293388429753\n * // BMI is 23.93948099205209\n * // BMI is 23.671253629592222\n * ```\n *\n * @see {@link combineLatestAll}\n * @see {@link merge}\n * @see {@link withLatestFrom}\n *\n * @param {ObservableInput} [observables] An array of input Observables to combine with each other.\n * An array of Observables must be given as the first argument.\n * @param {function} [project] An optional function to project the values from\n * the combined latest values into a new value on the output Observable.\n * @param {SchedulerLike} [scheduler=null] The {@link SchedulerLike} to use for subscribing to\n * each input Observable.\n * @return {Observable} An Observable of projected values from the most recent\n * values from each input Observable, or an array of the most recent values from\n * each input Observable.\n */\nexport function combineLatest<O extends ObservableInput<any>, R>(...args: any[]): Observable<R> | Observable<ObservedValueOf<O>[]> {\n  const scheduler = popScheduler(args);\n  const resultSelector = popResultSelector(args);\n\n  const { args: observables, keys } = argsArgArrayOrObject(args);\n\n  if (observables.length === 0) {\n    // If no observables are passed, or someone has passed an empty array\n    // of observables, or even an empty object POJO, we need to just\n    // complete (EMPTY), but we have to honor the scheduler provided if any.\n    return from([], scheduler as any);\n  }\n\n  const result = new Observable<ObservedValueOf<O>[]>(\n    combineLatestInit(\n      observables as ObservableInput<ObservedValueOf<O>>[],\n      scheduler,\n      keys\n        ? // A handler for scrubbing the array of args into a dictionary.\n          (values) => createObject(keys, values)\n        : // A passthrough to just return the array\n          identity\n    )\n  );\n\n  return resultSelector ? (result.pipe(mapOneOrManyArgs(resultSelector)) as Observable<R>) : result;\n}\n\nexport function combineLatestInit(\n  observables: ObservableInput<any>[],\n  scheduler?: SchedulerLike,\n  valueTransform: (values: any[]) => any = identity\n) {\n  return (subscriber: Subscriber<any>) => {\n    // The outer subscription. We're capturing this in a function\n    // because we may have to schedule it.\n    maybeSchedule(\n      scheduler,\n      () => {\n        const { length } = observables;\n        // A store for the values each observable has emitted so far. We match observable to value on index.\n        const values = new Array(length);\n        // The number of currently active subscriptions, as they complete, we decrement this number to see if\n        // we are all done combining values, so we can complete the result.\n        let active = length;\n        // The number of inner sources that still haven't emitted the first value\n        // We need to track this because all sources need to emit one value in order\n        // to start emitting values.\n        let remainingFirstValues = length;\n        // The loop to kick off subscription. We're keying everything on index `i` to relate the observables passed\n        // in to the slot in the output array or the key in the array of keys in the output dictionary.\n        for (let i = 0; i < length; i++) {\n          maybeSchedule(\n            scheduler,\n            () => {\n              const source = from(observables[i], scheduler as any);\n              let hasFirstValue = false;\n              source.subscribe(\n                createOperatorSubscriber(\n                  subscriber,\n                  (value) => {\n                    // When we get a value, record it in our set of values.\n                    values[i] = value;\n                    if (!hasFirstValue) {\n                      // If this is our first value, record that.\n                      hasFirstValue = true;\n                      remainingFirstValues--;\n                    }\n                    if (!remainingFirstValues) {\n                      // We're not waiting for any more\n                      // first values, so we can emit!\n                      subscriber.next(valueTransform(values.slice()));\n                    }\n                  },\n                  () => {\n                    if (!--active) {\n                      // We only complete the result if we have no more active\n                      // inner observables.\n                      subscriber.complete();\n                    }\n                  }\n                )\n              );\n            },\n            subscriber\n          );\n        }\n      },\n      subscriber\n    );\n  };\n}\n\n/**\n * A small utility to handle the couple of locations where we want to schedule if a scheduler was provided,\n * but we don't if there was no scheduler.\n */\nfunction maybeSchedule(scheduler: SchedulerLike | undefined, execute: () => void, subscription: Subscription) {\n  if (scheduler) {\n    executeSchedule(subscription, scheduler, execute);\n  } else {\n    execute();\n  }\n}\n","import { Observable } from '../Observable';\nimport { ObservableInputTuple, SchedulerLike } from '../types';\nimport { concatAll } from '../operators/concatAll';\nimport { popScheduler } from '../util/args';\nimport { from } from './from';\n\nexport function concat<T extends readonly unknown[]>(...inputs: [...ObservableInputTuple<T>]): Observable<T[number]>;\nexport function concat<T extends readonly unknown[]>(\n  ...inputsAndScheduler: [...ObservableInputTuple<T>, SchedulerLike]\n): Observable<T[number]>;\n\n/**\n * Creates an output Observable which sequentially emits all values from the first given\n * Observable and then moves on to the next.\n *\n * <span class=\"informal\">Concatenates multiple Observables together by\n * sequentially emitting their values, one Observable after the other.</span>\n *\n * ![](concat.png)\n *\n * `concat` joins multiple Observables together, by subscribing to them one at a time and\n * merging their results into the output Observable. You can pass either an array of\n * Observables, or put them directly as arguments. Passing an empty array will result\n * in Observable that completes immediately.\n *\n * `concat` will subscribe to first input Observable and emit all its values, without\n * changing or affecting them in any way. When that Observable completes, it will\n * subscribe to then next Observable passed and, again, emit its values. This will be\n * repeated, until the operator runs out of Observables. When last input Observable completes,\n * `concat` will complete as well. At any given moment only one Observable passed to operator\n * emits values. If you would like to emit values from passed Observables concurrently, check out\n * {@link merge} instead, especially with optional `concurrent` parameter. As a matter of fact,\n * `concat` is an equivalent of `merge` operator with `concurrent` parameter set to `1`.\n *\n * Note that if some input Observable never completes, `concat` will also never complete\n * and Observables following the one that did not complete will never be subscribed. On the other\n * hand, if some Observable simply completes immediately after it is subscribed, it will be\n * invisible for `concat`, which will just move on to the next Observable.\n *\n * If any Observable in chain errors, instead of passing control to the next Observable,\n * `concat` will error immediately as well. Observables that would be subscribed after\n * the one that emitted error, never will.\n *\n * If you pass to `concat` the same Observable many times, its stream of values\n * will be \"replayed\" on every subscription, which means you can repeat given Observable\n * as many times as you like. If passing the same Observable to `concat` 1000 times becomes tedious,\n * you can always use {@link repeat}.\n *\n * ## Examples\n *\n * Concatenate a timer counting from 0 to 3 with a synchronous sequence from 1 to 10\n *\n * ```ts\n * import { interval, take, range, concat } from 'rxjs';\n *\n * const timer = interval(1000).pipe(take(4));\n * const sequence = range(1, 10);\n * const result = concat(timer, sequence);\n * result.subscribe(x => console.log(x));\n *\n * // results in:\n * // 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3 -immediate-> 1 ... 10\n * ```\n *\n * Concatenate 3 Observables\n *\n * ```ts\n * import { interval, take, concat } from 'rxjs';\n *\n * const timer1 = interval(1000).pipe(take(10));\n * const timer2 = interval(2000).pipe(take(6));\n * const timer3 = interval(500).pipe(take(10));\n *\n * const result = concat(timer1, timer2, timer3);\n * result.subscribe(x => console.log(x));\n *\n * // results in the following:\n * // (Prints to console sequentially)\n * // -1000ms-> 0 -1000ms-> 1 -1000ms-> ... 9\n * // -2000ms-> 0 -2000ms-> 1 -2000ms-> ... 5\n * // -500ms-> 0 -500ms-> 1 -500ms-> ... 9\n * ```\n *\n * Concatenate the same Observable to repeat it\n *\n * ```ts\n * import { interval, take, concat } from 'rxjs';\n *\n * const timer = interval(1000).pipe(take(2));\n *\n * concat(timer, timer) // concatenating the same Observable!\n *   .subscribe({\n *     next: value => console.log(value),\n *     complete: () => console.log('...and it is done!')\n *   });\n *\n * // Logs:\n * // 0 after 1s\n * // 1 after 2s\n * // 0 after 3s\n * // 1 after 4s\n * // '...and it is done!' also after 4s\n * ```\n *\n * @see {@link concatAll}\n * @see {@link concatMap}\n * @see {@link concatMapTo}\n * @see {@link startWith}\n * @see {@link endWith}\n *\n * @param args Input Observables to concatenate.\n */\nexport function concat(...args: any[]): Observable<unknown> {\n  return concatAll()(from(args, popScheduler(args)));\n}\n","import { Connectable, ObservableInput, SubjectLike } from '../types';\nimport { Subject } from '../Subject';\nimport { Subscription } from '../Subscription';\nimport { Observable } from '../Observable';\nimport { defer } from './defer';\n\nexport interface ConnectableConfig<T> {\n  /**\n   * A factory function used to create the Subject through which the source\n   * is multicast. By default this creates a {@link Subject}.\n   */\n  connector: () => SubjectLike<T>;\n  /**\n   * If true, the resulting observable will reset internal state upon disconnection\n   * and return to a \"cold\" state. This allows the resulting observable to be\n   * reconnected.\n   * If false, upon disconnection, the connecting subject will remain the\n   * connecting subject, meaning the resulting observable will not go \"cold\" again,\n   * and subsequent repeats or resubscriptions will resubscribe to that same subject.\n   */\n  resetOnDisconnect?: boolean;\n}\n\n/**\n * The default configuration for `connectable`.\n */\nconst DEFAULT_CONFIG: ConnectableConfig<unknown> = {\n  connector: () => new Subject<unknown>(),\n  resetOnDisconnect: true,\n};\n\n/**\n * Creates an observable that multicasts once `connect()` is called on it.\n *\n * @param source The observable source to make connectable.\n * @param config The configuration object for `connectable`.\n * @returns A \"connectable\" observable, that has a `connect()` method, that you must call to\n * connect the source to all consumers through the subject provided as the connector.\n */\nexport function connectable<T>(source: ObservableInput<T>, config: ConnectableConfig<T> = DEFAULT_CONFIG): Connectable<T> {\n  // The subscription representing the connection.\n  let connection: Subscription | null = null;\n  const { connector, resetOnDisconnect = true } = config;\n  let subject = connector();\n\n  const result: any = new Observable<T>((subscriber) => {\n    return subject.subscribe(subscriber);\n  });\n\n  // Define the `connect` function. This is what users must call\n  // in order to \"connect\" the source to the subject that is\n  // multicasting it.\n  result.connect = () => {\n    if (!connection || connection.closed) {\n      connection = defer(() => source).subscribe(subject);\n      if (resetOnDisconnect) {\n        connection.add(() => (subject = connector()));\n      }\n    }\n    return connection;\n  };\n\n  return result;\n}\n","import { Observable } from '../Observable';\nimport { ObservedValueOf, ObservableInput } from '../types';\nimport { innerFrom } from './innerFrom';\n\n/**\n * Creates an Observable that, on subscribe, calls an Observable factory to\n * make an Observable for each new Observer.\n *\n * <span class=\"informal\">Creates the Observable lazily, that is, only when it\n * is subscribed.\n * </span>\n *\n * ![](defer.png)\n *\n * `defer` allows you to create an Observable only when the Observer\n * subscribes. It waits until an Observer subscribes to it, calls the given\n * factory function to get an Observable -- where a factory function typically\n * generates a new Observable -- and subscribes the Observer to this Observable.\n * In case the factory function returns a falsy value, then EMPTY is used as\n * Observable instead. Last but not least, an exception during the factory\n * function call is transferred to the Observer by calling `error`.\n *\n * ## Example\n *\n * Subscribe to either an Observable of clicks or an Observable of interval, at random\n *\n * ```ts\n * import { defer, fromEvent, interval } from 'rxjs';\n *\n * const clicksOrInterval = defer(() => {\n *   return Math.random() > 0.5\n *     ? fromEvent(document, 'click')\n *     : interval(1000);\n * });\n * clicksOrInterval.subscribe(x => console.log(x));\n *\n * // Results in the following behavior:\n * // If the result of Math.random() is greater than 0.5 it will listen\n * // for clicks anywhere on the \"document\"; when document is clicked it\n * // will log a MouseEvent object to the console. If the result is less\n * // than 0.5 it will emit ascending numbers, one every second(1000ms).\n * ```\n *\n * @see {@link Observable}\n *\n * @param {function(): ObservableInput} observableFactory The Observable\n * factory function to invoke for each Observer that subscribes to the output\n * Observable. May also return a Promise, which will be converted on the fly\n * to an Observable.\n * @return {Observable} An Observable whose Observers' subscriptions trigger\n * an invocation of the given Observable factory function.\n */\nexport function defer<R extends ObservableInput<any>>(observableFactory: () => R): Observable<ObservedValueOf<R>> {\n  return new Observable<ObservedValueOf<R>>((subscriber) => {\n    innerFrom(observableFactory()).subscribe(subscriber);\n  });\n}\n","import { Observable } from '../../Observable';\nimport { TimestampProvider } from '../../types';\nimport { performanceTimestampProvider } from '../../scheduler/performanceTimestampProvider';\nimport { animationFrameProvider } from '../../scheduler/animationFrameProvider';\n\n/**\n * An observable of animation frames\n *\n * Emits the amount of time elapsed since subscription and the timestamp on each animation frame.\n * Defaults to milliseconds provided to the requestAnimationFrame's callback. Does not end on its own.\n *\n * Every subscription will start a separate animation loop. Since animation frames are always scheduled\n * by the browser to occur directly before a repaint, scheduling more than one animation frame synchronously\n * should not be much different or have more overhead than looping over an array of events during\n * a single animation frame. However, if for some reason the developer would like to ensure the\n * execution of animation-related handlers are all executed during the same task by the engine,\n * the `share` operator can be used.\n *\n * This is useful for setting up animations with RxJS.\n *\n * ## Examples\n *\n * Tweening a div to move it on the screen\n *\n * ```ts\n * import { animationFrames, map, takeWhile, endWith } from 'rxjs';\n *\n * function tween(start: number, end: number, duration: number) {\n *   const diff = end - start;\n *   return animationFrames().pipe(\n *     // Figure out what percentage of time has passed\n *     map(({ elapsed }) => elapsed / duration),\n *     // Take the vector while less than 100%\n *     takeWhile(v => v < 1),\n *     // Finish with 100%\n *     endWith(1),\n *     // Calculate the distance traveled between start and end\n *     map(v => v * diff + start)\n *   );\n * }\n *\n * // Setup a div for us to move around\n * const div = document.createElement('div');\n * document.body.appendChild(div);\n * div.style.position = 'absolute';\n * div.style.width = '40px';\n * div.style.height = '40px';\n * div.style.backgroundColor = 'lime';\n * div.style.transform = 'translate3d(10px, 0, 0)';\n *\n * tween(10, 200, 4000).subscribe(x => {\n *   div.style.transform = `translate3d(${ x }px, 0, 0)`;\n * });\n * ```\n *\n * Providing a custom timestamp provider\n *\n * ```ts\n * import { animationFrames, TimestampProvider } from 'rxjs';\n *\n * // A custom timestamp provider\n * let now = 0;\n * const customTSProvider: TimestampProvider = {\n *   now() { return now++; }\n * };\n *\n * const source$ = animationFrames(customTSProvider);\n *\n * // Log increasing numbers 0...1...2... on every animation frame.\n * source$.subscribe(({ elapsed }) => console.log(elapsed));\n * ```\n *\n * @param timestampProvider An object with a `now` method that provides a numeric timestamp\n */\nexport function animationFrames(timestampProvider?: TimestampProvider) {\n  return timestampProvider ? animationFramesFactory(timestampProvider) : DEFAULT_ANIMATION_FRAMES;\n}\n\n/**\n * Does the work of creating the observable for `animationFrames`.\n * @param timestampProvider The timestamp provider to use to create the observable\n */\nfunction animationFramesFactory(timestampProvider?: TimestampProvider) {\n  return new Observable<{ timestamp: number; elapsed: number }>((subscriber) => {\n    // If no timestamp provider is specified, use performance.now() - as it\n    // will return timestamps 'compatible' with those passed to the run\n    // callback and won't be affected by NTP adjustments, etc.\n    const provider = timestampProvider || performanceTimestampProvider;\n\n    // Capture the start time upon subscription, as the run callback can remain\n    // queued for a considerable period of time and the elapsed time should\n    // represent the time elapsed since subscription - not the time since the\n    // first rendered animation frame.\n    const start = provider.now();\n\n    let id = 0;\n    const run = () => {\n      if (!subscriber.closed) {\n        id = animationFrameProvider.requestAnimationFrame((timestamp: DOMHighResTimeStamp | number) => {\n          id = 0;\n          // Use the provider's timestamp to calculate the elapsed time. Note that\n          // this means - if the caller hasn't passed a provider - that\n          // performance.now() will be used instead of the timestamp that was\n          // passed to the run callback. The reason for this is that the timestamp\n          // passed to the callback can be earlier than the start time, as it\n          // represents the time at which the browser decided it would render any\n          // queued frames - and that time can be earlier the captured start time.\n          const now = provider.now();\n          subscriber.next({\n            timestamp: timestampProvider ? now : timestamp,\n            elapsed: now - start,\n          });\n          run();\n        });\n      }\n    };\n\n    run();\n\n    return () => {\n      if (id) {\n        animationFrameProvider.cancelAnimationFrame(id);\n      }\n    };\n  });\n}\n\n/**\n * In the common case, where the timestamp provided by the rAF API is used,\n * we use this shared observable to reduce overhead.\n */\nconst DEFAULT_ANIMATION_FRAMES = animationFramesFactory();\n","import { Observable } from '../Observable';\nimport { SchedulerLike } from '../types';\n\n/**\n * A simple Observable that emits no items to the Observer and immediately\n * emits a complete notification.\n *\n * <span class=\"informal\">Just emits 'complete', and nothing else.</span>\n *\n * ![](empty.png)\n *\n * A simple Observable that only emits the complete notification. It can be used\n * for composing with other Observables, such as in a {@link mergeMap}.\n *\n * ## Examples\n *\n * Log complete notification\n *\n * ```ts\n * import { EMPTY } from 'rxjs';\n *\n * EMPTY.subscribe({\n *   next: () => console.log('Next'),\n *   complete: () => console.log('Complete!')\n * });\n *\n * // Outputs\n * // Complete!\n * ```\n *\n * Emit the number 7, then complete\n *\n * ```ts\n * import { EMPTY, startWith } from 'rxjs';\n *\n * const result = EMPTY.pipe(startWith(7));\n * result.subscribe(x => console.log(x));\n *\n * // Outputs\n * // 7\n * ```\n *\n * Map and flatten only odd numbers to the sequence `'a'`, `'b'`, `'c'`\n *\n * ```ts\n * import { interval, mergeMap, of, EMPTY } from 'rxjs';\n *\n * const interval$ = interval(1000);\n * const result = interval$.pipe(\n *   mergeMap(x => x % 2 === 1 ? of('a', 'b', 'c') : EMPTY),\n * );\n * result.subscribe(x => console.log(x));\n *\n * // Results in the following to the console:\n * // x is equal to the count on the interval, e.g. (0, 1, 2, 3, ...)\n * // x will occur every 1000ms\n * // if x % 2 is equal to 1, print a, b, c (each on its own)\n * // if x % 2 is not equal to 1, nothing will be output\n * ```\n *\n * @see {@link Observable}\n * @see {@link NEVER}\n * @see {@link of}\n * @see {@link throwError}\n */\nexport const EMPTY = new Observable<never>((subscriber) => subscriber.complete());\n\n/**\n * @param scheduler A {@link SchedulerLike} to use for scheduling\n * the emission of the complete notification.\n * @deprecated Replaced with the {@link EMPTY} constant or {@link scheduled} (e.g. `scheduled([], scheduler)`). Will be removed in v8.\n */\nexport function empty(scheduler?: SchedulerLike) {\n  return scheduler ? emptyScheduled(scheduler) : EMPTY;\n}\n\nfunction emptyScheduled(scheduler: SchedulerLike) {\n  return new Observable<never>((subscriber) => scheduler.schedule(() => subscriber.complete()));\n}\n","import { Observable } from '../Observable';\nimport { ObservedValueOf, ObservableInputTuple, ObservableInput } from '../types';\nimport { argsArgArrayOrObject } from '../util/argsArgArrayOrObject';\nimport { innerFrom } from './innerFrom';\nimport { popResultSelector } from '../util/args';\nimport { createOperatorSubscriber } from '../operators/OperatorSubscriber';\nimport { mapOneOrManyArgs } from '../util/mapOneOrManyArgs';\nimport { createObject } from '../util/createObject';\nimport { AnyCatcher } from '../AnyCatcher';\n\n// forkJoin(any)\n// We put this first because we need to catch cases where the user has supplied\n// _exactly `any`_ as the argument. Since `any` literally matches _anything_,\n// we don't want it to randomly hit one of the other type signatures below,\n// as we have no idea at build-time what type we should be returning when given an any.\n\n/**\n * You have passed `any` here, we can't figure out if it is\n * an array or an object, so you're getting `unknown`. Use better types.\n * @param arg Something typed as `any`\n */\nexport function forkJoin<T extends AnyCatcher>(arg: T): Observable<unknown>;\n\n// forkJoin(null | undefined)\nexport function forkJoin(scheduler: null | undefined): Observable<never>;\n\n// forkJoin([a, b, c])\nexport function forkJoin(sources: readonly []): Observable<never>;\nexport function forkJoin<A extends readonly unknown[]>(sources: readonly [...ObservableInputTuple<A>]): Observable<A>;\nexport function forkJoin<A extends readonly unknown[], R>(\n  sources: readonly [...ObservableInputTuple<A>],\n  resultSelector: (...values: A) => R\n): Observable<R>;\n\n// forkJoin(a, b, c)\n/** @deprecated Pass an array of sources instead. The rest-parameters signature will be removed in v8. Details: https://rxjs.dev/deprecations/array-argument */\nexport function forkJoin<A extends readonly unknown[]>(...sources: [...ObservableInputTuple<A>]): Observable<A>;\n/** @deprecated Pass an array of sources instead. The rest-parameters signature will be removed in v8. Details: https://rxjs.dev/deprecations/array-argument */\nexport function forkJoin<A extends readonly unknown[], R>(\n  ...sourcesAndResultSelector: [...ObservableInputTuple<A>, (...values: A) => R]\n): Observable<R>;\n\n// forkJoin({a, b, c})\nexport function forkJoin(sourcesObject: { [K in any]: never }): Observable<never>;\nexport function forkJoin<T extends Record<string, ObservableInput<any>>>(\n  sourcesObject: T\n): Observable<{ [K in keyof T]: ObservedValueOf<T[K]> }>;\n\n/**\n * Accepts an `Array` of {@link ObservableInput} or a dictionary `Object` of {@link ObservableInput} and returns\n * an {@link Observable} that emits either an array of values in the exact same order as the passed array,\n * or a dictionary of values in the same shape as the passed dictionary.\n *\n * <span class=\"informal\">Wait for Observables to complete and then combine last values they emitted;\n * complete immediately if an empty array is passed.</span>\n *\n * ![](forkJoin.png)\n *\n * `forkJoin` is an operator that takes any number of input observables which can be passed either as an array\n * or a dictionary of input observables. If no input observables are provided (e.g. an empty array is passed),\n * then the resulting stream will complete immediately.\n *\n * `forkJoin` will wait for all passed observables to emit and complete and then it will emit an array or an object with last\n * values from corresponding observables.\n *\n * If you pass an array of `n` observables to the operator, then the resulting\n * array will have `n` values, where the first value is the last one emitted by the first observable,\n * second value is the last one emitted by the second observable and so on.\n *\n * If you pass a dictionary of observables to the operator, then the resulting\n * objects will have the same keys as the dictionary passed, with their last values they have emitted\n * located at the corresponding key.\n *\n * That means `forkJoin` will not emit more than once and it will complete after that. If you need to emit combined\n * values not only at the end of the lifecycle of passed observables, but also throughout it, try out {@link combineLatest}\n * or {@link zip} instead.\n *\n * In order for the resulting array to have the same length as the number of input observables, whenever any of\n * the given observables completes without emitting any value, `forkJoin` will complete at that moment as well\n * and it will not emit anything either, even if it already has some last values from other observables.\n * Conversely, if there is an observable that never completes, `forkJoin` will never complete either,\n * unless at any point some other observable completes without emitting a value, which brings us back to\n * the previous case. Overall, in order for `forkJoin` to emit a value, all given observables\n * have to emit something at least once and complete.\n *\n * If any given observable errors at some point, `forkJoin` will error as well and immediately unsubscribe\n * from the other observables.\n *\n * Optionally `forkJoin` accepts a `resultSelector` function, that will be called with values which normally\n * would land in the emitted array. Whatever is returned by the `resultSelector`, will appear in the output\n * observable instead. This means that the default `resultSelector` can be thought of as a function that takes\n * all its arguments and puts them into an array. Note that the `resultSelector` will be called only\n * when `forkJoin` is supposed to emit a result.\n *\n * ## Examples\n *\n * Use `forkJoin` with a dictionary of observable inputs\n *\n * ```ts\n * import { forkJoin, of, timer } from 'rxjs';\n *\n * const observable = forkJoin({\n *   foo: of(1, 2, 3, 4),\n *   bar: Promise.resolve(8),\n *   baz: timer(4000)\n * });\n * observable.subscribe({\n *  next: value => console.log(value),\n *  complete: () => console.log('This is how it ends!'),\n * });\n *\n * // Logs:\n * // { foo: 4, bar: 8, baz: 0 } after 4 seconds\n * // 'This is how it ends!' immediately after\n * ```\n *\n * Use `forkJoin` with an array of observable inputs\n *\n * ```ts\n * import { forkJoin, of, timer } from 'rxjs';\n *\n * const observable = forkJoin([\n *   of(1, 2, 3, 4),\n *   Promise.resolve(8),\n *   timer(4000)\n * ]);\n * observable.subscribe({\n *  next: value => console.log(value),\n *  complete: () => console.log('This is how it ends!'),\n * });\n *\n * // Logs:\n * // [4, 8, 0] after 4 seconds\n * // 'This is how it ends!' immediately after\n * ```\n *\n * @see {@link combineLatest}\n * @see {@link zip}\n *\n * @param {...ObservableInput} args Any number of Observables provided either as an array or as an arguments\n * passed directly to the operator.\n * @param {function} [project] Function that takes values emitted by input Observables and returns value\n * that will appear in resulting Observable instead of default array.\n * @return {Observable} Observable emitting either an array of last values emitted by passed Observables\n * or value from project function.\n */\nexport function forkJoin(...args: any[]): Observable<any> {\n  const resultSelector = popResultSelector(args);\n  const { args: sources, keys } = argsArgArrayOrObject(args);\n  const result = new Observable((subscriber) => {\n    const { length } = sources;\n    if (!length) {\n      subscriber.complete();\n      return;\n    }\n    const values = new Array(length);\n    let remainingCompletions = length;\n    let remainingEmissions = length;\n    for (let sourceIndex = 0; sourceIndex < length; sourceIndex++) {\n      let hasValue = false;\n      innerFrom(sources[sourceIndex]).subscribe(\n        createOperatorSubscriber(\n          subscriber,\n          (value) => {\n            if (!hasValue) {\n              hasValue = true;\n              remainingEmissions--;\n            }\n            values[sourceIndex] = value;\n          },\n          () => remainingCompletions--,\n          undefined,\n          () => {\n            if (!remainingCompletions || !hasValue) {\n              if (!remainingEmissions) {\n                subscriber.next(keys ? createObject(keys, values) : values);\n              }\n              subscriber.complete();\n            }\n          }\n        )\n      );\n    }\n  });\n  return resultSelector ? result.pipe(mapOneOrManyArgs(resultSelector)) : result;\n}\n","import { Observable } from '../Observable';\nimport { ObservableInput, SchedulerLike, ObservedValueOf } from '../types';\nimport { scheduled } from '../scheduled/scheduled';\nimport { innerFrom } from './innerFrom';\n\nexport function from<O extends ObservableInput<any>>(input: O): Observable<ObservedValueOf<O>>;\n/** @deprecated The `scheduler` parameter will be removed in v8. Use `scheduled`. Details: https://rxjs.dev/deprecations/scheduler-argument */\nexport function from<O extends ObservableInput<any>>(input: O, scheduler: SchedulerLike | undefined): Observable<ObservedValueOf<O>>;\n\n/**\n * Creates an Observable from an Array, an array-like object, a Promise, an iterable object, or an Observable-like object.\n *\n * <span class=\"informal\">Converts almost anything to an Observable.</span>\n *\n * ![](from.png)\n *\n * `from` converts various other objects and data types into Observables. It also converts a Promise, an array-like, or an\n * <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#iterable\" target=\"_blank\">iterable</a>\n * object into an Observable that emits the items in that promise, array, or iterable. A String, in this context, is treated\n * as an array of characters. Observable-like objects (contains a function named with the ES2015 Symbol for Observable) can also be\n * converted through this operator.\n *\n * ## Examples\n *\n * Converts an array to an Observable\n *\n * ```ts\n * import { from } from 'rxjs';\n *\n * const array = [10, 20, 30];\n * const result = from(array);\n *\n * result.subscribe(x => console.log(x));\n *\n * // Logs:\n * // 10\n * // 20\n * // 30\n * ```\n *\n * Convert an infinite iterable (from a generator) to an Observable\n *\n * ```ts\n * import { from, take } from 'rxjs';\n *\n * function* generateDoubles(seed) {\n *    let i = seed;\n *    while (true) {\n *      yield i;\n *      i = 2 * i; // double it\n *    }\n * }\n *\n * const iterator = generateDoubles(3);\n * const result = from(iterator).pipe(take(10));\n *\n * result.subscribe(x => console.log(x));\n *\n * // Logs:\n * // 3\n * // 6\n * // 12\n * // 24\n * // 48\n * // 96\n * // 192\n * // 384\n * // 768\n * // 1536\n * ```\n *\n * With `asyncScheduler`\n *\n * ```ts\n * import { from, asyncScheduler } from 'rxjs';\n *\n * console.log('start');\n *\n * const array = [10, 20, 30];\n * const result = from(array, asyncScheduler);\n *\n * result.subscribe(x => console.log(x));\n *\n * console.log('end');\n *\n * // Logs:\n * // 'start'\n * // 'end'\n * // 10\n * // 20\n * // 30\n * ```\n *\n * @see {@link fromEvent}\n * @see {@link fromEventPattern}\n *\n * @param {ObservableInput<T>} A subscription object, a Promise, an Observable-like,\n * an Array, an iterable, or an array-like object to be converted.\n * @param {SchedulerLike} An optional {@link SchedulerLike} on which to schedule the emission of values.\n * @return {Observable<T>}\n */\nexport function from<T>(input: ObservableInput<T>, scheduler?: SchedulerLike): Observable<T> {\n  return scheduler ? scheduled(input, scheduler) : innerFrom(input);\n}\n","import { innerFrom } from '../observable/innerFrom';\nimport { Observable } from '../Observable';\nimport { mergeMap } from '../operators/mergeMap';\nimport { isArrayLike } from '../util/isArrayLike';\nimport { isFunction } from '../util/isFunction';\nimport { mapOneOrManyArgs } from '../util/mapOneOrManyArgs';\n\n// These constants are used to create handler registry functions using array mapping below.\nconst nodeEventEmitterMethods = ['addListener', 'removeListener'] as const;\nconst eventTargetMethods = ['addEventListener', 'removeEventListener'] as const;\nconst jqueryMethods = ['on', 'off'] as const;\n\nexport interface NodeStyleEventEmitter {\n  addListener(eventName: string | symbol, handler: NodeEventHandler): this;\n  removeListener(eventName: string | symbol, handler: NodeEventHandler): this;\n}\n\nexport type NodeEventHandler = (...args: any[]) => void;\n\n// For APIs that implement `addListener` and `removeListener` methods that may\n// not use the same arguments or return EventEmitter values\n// such as React Native\nexport interface NodeCompatibleEventEmitter {\n  addListener(eventName: string, handler: NodeEventHandler): void | {};\n  removeListener(eventName: string, handler: NodeEventHandler): void | {};\n}\n\n// Use handler types like those in @types/jquery. See:\n// https://github.com/DefinitelyTyped/DefinitelyTyped/blob/847731ba1d7fa6db6b911c0e43aa0afe596e7723/types/jquery/misc.d.ts#L6395\nexport interface JQueryStyleEventEmitter<TContext, T> {\n  on(eventName: string, handler: (this: TContext, t: T, ...args: any[]) => any): void;\n  off(eventName: string, handler: (this: TContext, t: T, ...args: any[]) => any): void;\n}\n\nexport interface EventListenerObject<E> {\n  handleEvent(evt: E): void;\n}\n\nexport interface HasEventTargetAddRemove<E> {\n  addEventListener(\n    type: string,\n    listener: ((evt: E) => void) | EventListenerObject<E> | null,\n    options?: boolean | AddEventListenerOptions\n  ): void;\n  removeEventListener(\n    type: string,\n    listener: ((evt: E) => void) | EventListenerObject<E> | null,\n    options?: EventListenerOptions | boolean\n  ): void;\n}\n\nexport interface EventListenerOptions {\n  capture?: boolean;\n  passive?: boolean;\n  once?: boolean;\n}\n\nexport interface AddEventListenerOptions extends EventListenerOptions {\n  once?: boolean;\n  passive?: boolean;\n}\n\nexport function fromEvent<T>(target: HasEventTargetAddRemove<T> | ArrayLike<HasEventTargetAddRemove<T>>, eventName: string): Observable<T>;\nexport function fromEvent<T, R>(\n  target: HasEventTargetAddRemove<T> | ArrayLike<HasEventTargetAddRemove<T>>,\n  eventName: string,\n  resultSelector: (event: T) => R\n): Observable<R>;\nexport function fromEvent<T>(\n  target: HasEventTargetAddRemove<T> | ArrayLike<HasEventTargetAddRemove<T>>,\n  eventName: string,\n  options: EventListenerOptions\n): Observable<T>;\nexport function fromEvent<T, R>(\n  target: HasEventTargetAddRemove<T> | ArrayLike<HasEventTargetAddRemove<T>>,\n  eventName: string,\n  options: EventListenerOptions,\n  resultSelector: (event: T) => R\n): Observable<R>;\n\nexport function fromEvent(target: NodeStyleEventEmitter | ArrayLike<NodeStyleEventEmitter>, eventName: string): Observable<unknown>;\n/** @deprecated Do not specify explicit type parameters. Signatures with type parameters that cannot be inferred will be removed in v8. */\nexport function fromEvent<T>(target: NodeStyleEventEmitter | ArrayLike<NodeStyleEventEmitter>, eventName: string): Observable<T>;\nexport function fromEvent<R>(\n  target: NodeStyleEventEmitter | ArrayLike<NodeStyleEventEmitter>,\n  eventName: string,\n  resultSelector: (...args: any[]) => R\n): Observable<R>;\n\nexport function fromEvent(\n  target: NodeCompatibleEventEmitter | ArrayLike<NodeCompatibleEventEmitter>,\n  eventName: string\n): Observable<unknown>;\n/** @deprecated Do not specify explicit type parameters. Signatures with type parameters that cannot be inferred will be removed in v8. */\nexport function fromEvent<T>(target: NodeCompatibleEventEmitter | ArrayLike<NodeCompatibleEventEmitter>, eventName: string): Observable<T>;\nexport function fromEvent<R>(\n  target: NodeCompatibleEventEmitter | ArrayLike<NodeCompatibleEventEmitter>,\n  eventName: string,\n  resultSelector: (...args: any[]) => R\n): Observable<R>;\n\nexport function fromEvent<T>(\n  target: JQueryStyleEventEmitter<any, T> | ArrayLike<JQueryStyleEventEmitter<any, T>>,\n  eventName: string\n): Observable<T>;\nexport function fromEvent<T, R>(\n  target: JQueryStyleEventEmitter<any, T> | ArrayLike<JQueryStyleEventEmitter<any, T>>,\n  eventName: string,\n  resultSelector: (value: T, ...args: any[]) => R\n): Observable<R>;\n\n/**\n * Creates an Observable that emits events of a specific type coming from the\n * given event target.\n *\n * <span class=\"informal\">Creates an Observable from DOM events, or Node.js\n * EventEmitter events or others.</span>\n *\n * ![](fromEvent.png)\n *\n * `fromEvent` accepts as a first argument event target, which is an object with methods\n * for registering event handler functions. As a second argument it takes string that indicates\n * type of event we want to listen for. `fromEvent` supports selected types of event targets,\n * which are described in detail below. If your event target does not match any of the ones listed,\n * you should use {@link fromEventPattern}, which can be used on arbitrary APIs.\n * When it comes to APIs supported by `fromEvent`, their methods for adding and removing event\n * handler functions have different names, but they all accept a string describing event type\n * and function itself, which will be called whenever said event happens.\n *\n * Every time resulting Observable is subscribed, event handler function will be registered\n * to event target on given event type. When that event fires, value\n * passed as a first argument to registered function will be emitted by output Observable.\n * When Observable is unsubscribed, function will be unregistered from event target.\n *\n * Note that if event target calls registered function with more than one argument, second\n * and following arguments will not appear in resulting stream. In order to get access to them,\n * you can pass to `fromEvent` optional project function, which will be called with all arguments\n * passed to event handler. Output Observable will then emit value returned by project function,\n * instead of the usual value.\n *\n * Remember that event targets listed below are checked via duck typing. It means that\n * no matter what kind of object you have and no matter what environment you work in,\n * you can safely use `fromEvent` on that object if it exposes described methods (provided\n * of course they behave as was described above). So for example if Node.js library exposes\n * event target which has the same method names as DOM EventTarget, `fromEvent` is still\n * a good choice.\n *\n * If the API you use is more callback then event handler oriented (subscribed\n * callback function fires only once and thus there is no need to manually\n * unregister it), you should use {@link bindCallback} or {@link bindNodeCallback}\n * instead.\n *\n * `fromEvent` supports following types of event targets:\n *\n * **DOM EventTarget**\n *\n * This is an object with `addEventListener` and `removeEventListener` methods.\n *\n * In the browser, `addEventListener` accepts - apart from event type string and event\n * handler function arguments - optional third parameter, which is either an object or boolean,\n * both used for additional configuration how and when passed function will be called. When\n * `fromEvent` is used with event target of that type, you can provide this values\n * as third parameter as well.\n *\n * **Node.js EventEmitter**\n *\n * An object with `addListener` and `removeListener` methods.\n *\n * **JQuery-style event target**\n *\n * An object with `on` and `off` methods\n *\n * **DOM NodeList**\n *\n * List of DOM Nodes, returned for example by `document.querySelectorAll` or `Node.childNodes`.\n *\n * Although this collection is not event target in itself, `fromEvent` will iterate over all Nodes\n * it contains and install event handler function in every of them. When returned Observable\n * is unsubscribed, function will be removed from all Nodes.\n *\n * **DOM HtmlCollection**\n *\n * Just as in case of NodeList it is a collection of DOM nodes. Here as well event handler function is\n * installed and removed in each of elements.\n *\n *\n * ## Examples\n *\n * Emit clicks happening on the DOM document\n *\n * ```ts\n * import { fromEvent } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * clicks.subscribe(x => console.log(x));\n *\n * // Results in:\n * // MouseEvent object logged to console every time a click\n * // occurs on the document.\n * ```\n *\n * Use `addEventListener` with capture option\n *\n * ```ts\n * import { fromEvent } from 'rxjs';\n *\n * const div = document.createElement('div');\n * div.style.cssText = 'width: 200px; height: 200px; background: #09c;';\n * document.body.appendChild(div);\n *\n * // note optional configuration parameter which will be passed to addEventListener\n * const clicksInDocument = fromEvent(document, 'click', { capture: true });\n * const clicksInDiv = fromEvent(div, 'click');\n *\n * clicksInDocument.subscribe(() => console.log('document'));\n * clicksInDiv.subscribe(() => console.log('div'));\n *\n * // By default events bubble UP in DOM tree, so normally\n * // when we would click on div in document\n * // \"div\" would be logged first and then \"document\".\n * // Since we specified optional `capture` option, document\n * // will catch event when it goes DOWN DOM tree, so console\n * // will log \"document\" and then \"div\".\n * ```\n *\n * @see {@link bindCallback}\n * @see {@link bindNodeCallback}\n * @see {@link fromEventPattern}\n *\n * @param {FromEventTarget<T>} target The DOM EventTarget, Node.js\n * EventEmitter, JQuery-like event target, NodeList or HTMLCollection to attach the event handler to.\n * @param {string} eventName The event name of interest, being emitted by the\n * `target`.\n * @param {EventListenerOptions} [options] Options to pass through to addEventListener\n * @return {Observable<T>}\n */\nexport function fromEvent<T>(\n  target: any,\n  eventName: string,\n  options?: EventListenerOptions | ((...args: any[]) => T),\n  resultSelector?: (...args: any[]) => T\n): Observable<T> {\n  if (isFunction(options)) {\n    resultSelector = options;\n    options = undefined;\n  }\n  if (resultSelector) {\n    return fromEvent<T>(target, eventName, options as EventListenerOptions).pipe(mapOneOrManyArgs(resultSelector));\n  }\n\n  // Figure out our add and remove methods. In order to do this,\n  // we are going to analyze the target in a preferred order, if\n  // the target matches a given signature, we take the two \"add\" and \"remove\"\n  // method names and apply them to a map to create opposite versions of the\n  // same function. This is because they all operate in duplicate pairs,\n  // `addListener(name, handler)`, `removeListener(name, handler)`, for example.\n  // The call only differs by method name, as to whether or not you're adding or removing.\n  const [add, remove] =\n    // If it is an EventTarget, we need to use a slightly different method than the other two patterns.\n    isEventTarget(target)\n      ? eventTargetMethods.map((methodName) => (handler: any) => target[methodName](eventName, handler, options as EventListenerOptions))\n      : // In all other cases, the call pattern is identical with the exception of the method names.\n      isNodeStyleEventEmitter(target)\n      ? nodeEventEmitterMethods.map(toCommonHandlerRegistry(target, eventName))\n      : isJQueryStyleEventEmitter(target)\n      ? jqueryMethods.map(toCommonHandlerRegistry(target, eventName))\n      : [];\n\n  // If add is falsy, it's because we didn't match a pattern above.\n  // Check to see if it is an ArrayLike, because if it is, we want to\n  // try to apply fromEvent to all of it's items. We do this check last,\n  // because there are may be some types that are both ArrayLike *and* implement\n  // event registry points, and we'd rather delegate to that when possible.\n  if (!add) {\n    if (isArrayLike(target)) {\n      return mergeMap((subTarget: any) => fromEvent(subTarget, eventName, options as EventListenerOptions))(\n        innerFrom(target)\n      ) as Observable<T>;\n    }\n  }\n\n  // If add is falsy and we made it here, it's because we didn't\n  // match any valid target objects above.\n  if (!add) {\n    throw new TypeError('Invalid event target');\n  }\n\n  return new Observable<T>((subscriber) => {\n    // The handler we are going to register. Forwards the event object, by itself, or\n    // an array of arguments to the event handler, if there is more than one argument,\n    // to the consumer.\n    const handler = (...args: any[]) => subscriber.next(1 < args.length ? args : args[0]);\n    // Do the work of adding the handler to the target.\n    add(handler);\n    // When we finalize, we want to remove the handler and free up memory.\n    return () => remove!(handler);\n  });\n}\n\n/**\n * Used to create `add` and `remove` functions to register and unregister event handlers\n * from a target in the most common handler pattern, where there are only two arguments.\n * (e.g.  `on(name, fn)`, `off(name, fn)`, `addListener(name, fn)`, or `removeListener(name, fn)`)\n * @param target The target we're calling methods on\n * @param eventName The event name for the event we're creating register or unregister functions for\n */\nfunction toCommonHandlerRegistry(target: any, eventName: string) {\n  return (methodName: string) => (handler: any) => target[methodName](eventName, handler);\n}\n\n/**\n * Checks to see if the target implements the required node-style EventEmitter methods\n * for adding and removing event handlers.\n * @param target the object to check\n */\nfunction isNodeStyleEventEmitter(target: any): target is NodeStyleEventEmitter {\n  return isFunction(target.addListener) && isFunction(target.removeListener);\n}\n\n/**\n * Checks to see if the target implements the required jQuery-style EventEmitter methods\n * for adding and removing event handlers.\n * @param target the object to check\n */\nfunction isJQueryStyleEventEmitter(target: any): target is JQueryStyleEventEmitter<any, any> {\n  return isFunction(target.on) && isFunction(target.off);\n}\n\n/**\n * Checks to see if the target implements the required EventTarget methods\n * for adding and removing event handlers.\n * @param target the object to check\n */\nfunction isEventTarget(target: any): target is HasEventTargetAddRemove<any> {\n  return isFunction(target.addEventListener) && isFunction(target.removeEventListener);\n}\n","import { Observable } from '../Observable';\nimport { isFunction } from '../util/isFunction';\nimport { NodeEventHandler } from './fromEvent';\nimport { mapOneOrManyArgs } from '../util/mapOneOrManyArgs';\n\n/* tslint:disable:max-line-length */\nexport function fromEventPattern<T>(\n  addHandler: (handler: NodeEventHandler) => any,\n  removeHandler?: (handler: NodeEventHandler, signal?: any) => void\n): Observable<T>;\nexport function fromEventPattern<T>(\n  addHandler: (handler: NodeEventHandler) => any,\n  removeHandler?: (handler: NodeEventHandler, signal?: any) => void,\n  resultSelector?: (...args: any[]) => T\n): Observable<T>;\n/* tslint:enable:max-line-length */\n\n/**\n * Creates an Observable from an arbitrary API for registering event handlers.\n *\n * <span class=\"informal\">When that method for adding event handler was something {@link fromEvent}\n * was not prepared for.</span>\n *\n * ![](fromEventPattern.png)\n *\n * `fromEventPattern` allows you to convert into an Observable any API that supports registering handler functions\n * for events. It is similar to {@link fromEvent}, but far\n * more flexible. In fact, all use cases of {@link fromEvent} could be easily handled by\n * `fromEventPattern` (although in slightly more verbose way).\n *\n * This operator accepts as a first argument an `addHandler` function, which will be injected with\n * handler parameter. That handler is actually an event handler function that you now can pass\n * to API expecting it. `addHandler` will be called whenever Observable\n * returned by the operator is subscribed, so registering handler in API will not\n * necessarily happen when `fromEventPattern` is called.\n *\n * After registration, every time an event that we listen to happens,\n * Observable returned by `fromEventPattern` will emit value that event handler\n * function was called with. Note that if event handler was called with more\n * than one argument, second and following arguments will not appear in the Observable.\n *\n * If API you are using allows to unregister event handlers as well, you can pass to `fromEventPattern`\n * another function - `removeHandler` - as a second parameter. It will be injected\n * with the same handler function as before, which now you can use to unregister\n * it from the API. `removeHandler` will be called when consumer of resulting Observable\n * unsubscribes from it.\n *\n * In some APIs unregistering is actually handled differently. Method registering an event handler\n * returns some kind of token, which is later used to identify which function should\n * be unregistered or it itself has method that unregisters event handler.\n * If that is the case with your API, make sure token returned\n * by registering method is returned by `addHandler`. Then it will be passed\n * as a second argument to `removeHandler`, where you will be able to use it.\n *\n * If you need access to all event handler parameters (not only the first one),\n * or you need to transform them in any way, you can call `fromEventPattern` with optional\n * third parameter - project function which will accept all arguments passed to\n * event handler when it is called. Whatever is returned from project function will appear on\n * resulting stream instead of usual event handlers first argument. This means\n * that default project can be thought of as function that takes its first parameter\n * and ignores the rest.\n *\n * ## Examples\n *\n * Emits clicks happening on the DOM document\n *\n * ```ts\n * import { fromEventPattern } from 'rxjs';\n *\n * function addClickHandler(handler) {\n *   document.addEventListener('click', handler);\n * }\n *\n * function removeClickHandler(handler) {\n *   document.removeEventListener('click', handler);\n * }\n *\n * const clicks = fromEventPattern(\n *   addClickHandler,\n *   removeClickHandler\n * );\n * clicks.subscribe(x => console.log(x));\n *\n * // Whenever you click anywhere in the browser, DOM MouseEvent\n * // object will be logged.\n * ```\n *\n * Use with API that returns cancellation token\n *\n * ```ts\n * import { fromEventPattern } from 'rxjs';\n *\n * const token = someAPI.registerEventHandler(function() {});\n * someAPI.unregisterEventHandler(token); // this APIs cancellation method accepts\n *                                        // not handler itself, but special token.\n *\n * const someAPIObservable = fromEventPattern(\n *   function(handler) { return someAPI.registerEventHandler(handler); }, // Note that we return the token here...\n *   function(handler, token) { someAPI.unregisterEventHandler(token); }  // ...to then use it here.\n * );\n * ```\n *\n * Use with project function\n *\n * ```ts\n * import { fromEventPattern } from 'rxjs';\n *\n * someAPI.registerEventHandler((eventType, eventMessage) => {\n *   console.log(eventType, eventMessage); // Logs 'EVENT_TYPE' 'EVENT_MESSAGE' to console.\n * });\n *\n * const someAPIObservable = fromEventPattern(\n *   handler => someAPI.registerEventHandler(handler),\n *   handler => someAPI.unregisterEventHandler(handler)\n *   (eventType, eventMessage) => eventType + ' --- ' + eventMessage // without that function only 'EVENT_TYPE'\n * );                                                                // would be emitted by the Observable\n *\n * someAPIObservable.subscribe(value => console.log(value));\n *\n * // Logs:\n * // 'EVENT_TYPE --- EVENT_MESSAGE'\n * ```\n *\n * @see {@link fromEvent}\n * @see {@link bindCallback}\n * @see {@link bindNodeCallback}\n *\n * @param {function(handler: Function): any} addHandler A function that takes\n * a `handler` function as argument and attaches it somehow to the actual\n * source of events.\n * @param {function(handler: Function, token?: any): void} [removeHandler] A function that\n * takes a `handler` function as an argument and removes it from the event source. If `addHandler`\n * returns some kind of token, `removeHandler` function will have it as a second parameter.\n * @param {function(...args: any): T} [project] A function to\n * transform results. It takes the arguments from the event handler and\n * should return a single value.\n * @return {Observable<T>} Observable which, when an event happens, emits first parameter\n * passed to registered event handler. Alternatively it emits whatever project function returns\n * at that moment.\n */\nexport function fromEventPattern<T>(\n  addHandler: (handler: NodeEventHandler) => any,\n  removeHandler?: (handler: NodeEventHandler, signal?: any) => void,\n  resultSelector?: (...args: any[]) => T\n): Observable<T | T[]> {\n  if (resultSelector) {\n    return fromEventPattern<T>(addHandler, removeHandler).pipe(mapOneOrManyArgs(resultSelector));\n  }\n\n  return new Observable<T | T[]>((subscriber) => {\n    const handler = (...e: T[]) => subscriber.next(e.length === 1 ? e[0] : e);\n    const retValue = addHandler(handler);\n    return isFunction(removeHandler) ? () => removeHandler(handler, retValue) : undefined;\n  });\n}\n","import { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { Subscribable } from '../types';\n\n/**\n * Used to convert a subscribable to an observable.\n *\n * Currently, this is only used within internals.\n *\n * TODO: Discuss ObservableInput supporting \"Subscribable\".\n * https://github.com/ReactiveX/rxjs/issues/5909\n *\n * @param subscribable A subscribable\n */\nexport function fromSubscribable<T>(subscribable: Subscribable<T>) {\n  return new Observable((subscriber: Subscriber<T>) => subscribable.subscribe(subscriber));\n}\n","import { Observable } from '../Observable';\nimport { identity } from '../util/identity';\nimport { ObservableInput, SchedulerLike } from '../types';\nimport { isScheduler } from '../util/isScheduler';\nimport { defer } from './defer';\nimport { scheduleIterable } from '../scheduled/scheduleIterable';\n\ntype ConditionFunc<S> = (state: S) => boolean;\ntype IterateFunc<S> = (state: S) => S;\ntype ResultFunc<S, T> = (state: S) => T;\n\nexport interface GenerateBaseOptions<S> {\n  /**\n   * Initial state.\n   */\n  initialState: S;\n  /**\n   * Condition function that accepts state and returns boolean.\n   * When it returns false, the generator stops.\n   * If not specified, a generator never stops.\n   */\n  condition?: ConditionFunc<S>;\n  /**\n   * Iterate function that accepts state and returns new state.\n   */\n  iterate: IterateFunc<S>;\n  /**\n   * SchedulerLike to use for generation process.\n   * By default, a generator starts immediately.\n   */\n  scheduler?: SchedulerLike;\n}\n\nexport interface GenerateOptions<T, S> extends GenerateBaseOptions<S> {\n  /**\n   * Result selection function that accepts state and returns a value to emit.\n   */\n  resultSelector: ResultFunc<S, T>;\n}\n\n/**\n * Generates an observable sequence by running a state-driven loop\n * producing the sequence's elements, using the specified scheduler\n * to send out observer messages.\n *\n * ![](generate.png)\n *\n * ## Examples\n *\n * Produces sequence of numbers\n *\n * ```ts\n * import { generate } from 'rxjs';\n *\n * const result = generate(0, x => x < 3, x => x + 1, x => x);\n *\n * result.subscribe(x => console.log(x));\n *\n * // Logs:\n * // 0\n * // 1\n * // 2\n * ```\n *\n * Use `asapScheduler`\n *\n * ```ts\n * import { generate, asapScheduler } from 'rxjs';\n *\n * const result = generate(1, x => x < 5, x => x * 2, x => x + 1, asapScheduler);\n *\n * result.subscribe(x => console.log(x));\n *\n * // Logs:\n * // 2\n * // 3\n * // 5\n * ```\n *\n * @see {@link from}\n * @see {@link Observable}\n *\n * @param {S} initialState Initial state.\n * @param {function (state: S): boolean} condition Condition to terminate generation (upon returning false).\n * @param {function (state: S): S} iterate Iteration step function.\n * @param {function (state: S): T} resultSelector Selector function for results produced in the sequence. (deprecated)\n * @param {SchedulerLike} [scheduler] A {@link SchedulerLike} on which to run the generator loop. If not provided, defaults to emit immediately.\n * @returns {Observable<T>} The generated sequence.\n * @deprecated Instead of passing separate arguments, use the options argument. Signatures taking separate arguments will be removed in v8.\n */\nexport function generate<T, S>(\n  initialState: S,\n  condition: ConditionFunc<S>,\n  iterate: IterateFunc<S>,\n  resultSelector: ResultFunc<S, T>,\n  scheduler?: SchedulerLike\n): Observable<T>;\n\n/**\n * Generates an Observable by running a state-driven loop\n * that emits an element on each iteration.\n *\n * <span class=\"informal\">Use it instead of nexting values in a for loop.</span>\n *\n * ![](generate.png)\n *\n * `generate` allows you to create a stream of values generated with a loop very similar to\n * a traditional for loop. The first argument of `generate` is a beginning value. The second argument\n * is a function that accepts this value and tests if some condition still holds. If it does,\n * then the loop continues, if not, it stops. The third value is a function which takes the\n * previously defined value and modifies it in some way on each iteration. Note how these three parameters\n * are direct equivalents of three expressions in a traditional for loop: the first expression\n * initializes some state (for example, a numeric index), the second tests if the loop can perform the next\n * iteration (for example, if the index is lower than 10) and the third states how the defined value\n * will be modified on every step (for example, the index will be incremented by one).\n *\n * Return value of a `generate` operator is an Observable that on each loop iteration\n * emits a value. First of all, the condition function is ran. If it returns true, then the Observable\n * emits the currently stored value (initial value at the first iteration) and finally updates\n * that value with iterate function. If at some point the condition returns false, then the Observable\n * completes at that moment.\n *\n * Optionally you can pass a fourth parameter to `generate` - a result selector function which allows you\n * to immediately map the value that would normally be emitted by an Observable.\n *\n * If you find three anonymous functions in `generate` call hard to read, you can provide\n * a single object to the operator instead where the object has the properties: `initialState`,\n * `condition`, `iterate` and `resultSelector`, which should have respective values that you\n * would normally pass to `generate`. `resultSelector` is still optional, but that form\n * of calling `generate` allows you to omit `condition` as well. If you omit it, that means\n * condition always holds, or in other words the resulting Observable will never complete.\n *\n * Both forms of `generate` can optionally accept a scheduler. In case of a multi-parameter call,\n * scheduler simply comes as a last argument (no matter if there is a `resultSelector`\n * function or not). In case of a single-parameter call, you can provide it as a\n * `scheduler` property on the object passed to the operator. In both cases, a scheduler decides when\n * the next iteration of the loop will happen and therefore when the next value will be emitted\n * by the Observable. For example, to ensure that each value is pushed to the Observer\n * on a separate task in the event loop, you could use the `async` scheduler. Note that\n * by default (when no scheduler is passed) values are simply emitted synchronously.\n *\n *\n * ## Examples\n *\n * Use with condition and iterate functions\n *\n * ```ts\n * import { generate } from 'rxjs';\n *\n * const result = generate(0, x => x < 3, x => x + 1);\n *\n * result.subscribe({\n *   next: value => console.log(value),\n *   complete: () => console.log('Complete!')\n * });\n *\n * // Logs:\n * // 0\n * // 1\n * // 2\n * // 'Complete!'\n * ```\n *\n * Use with condition, iterate and resultSelector functions\n *\n * ```ts\n * import { generate } from 'rxjs';\n *\n * const result = generate(0, x => x < 3, x => x + 1, x => x * 1000);\n *\n * result.subscribe({\n *   next: value => console.log(value),\n *   complete: () => console.log('Complete!')\n * });\n *\n * // Logs:\n * // 0\n * // 1000\n * // 2000\n * // 'Complete!'\n * ```\n *\n * Use with options object\n *\n * ```ts\n * import { generate } from 'rxjs';\n *\n * const result = generate({\n *   initialState: 0,\n *   condition(value) { return value < 3; },\n *   iterate(value) { return value + 1; },\n *   resultSelector(value) { return value * 1000; }\n * });\n *\n * result.subscribe({\n *   next: value => console.log(value),\n *   complete: () => console.log('Complete!')\n * });\n *\n * // Logs:\n * // 0\n * // 1000\n * // 2000\n * // 'Complete!'\n * ```\n *\n * Use options object without condition function\n *\n * ```ts\n * import { generate } from 'rxjs';\n *\n * const result = generate({\n *   initialState: 0,\n *   iterate(value) { return value + 1; },\n *   resultSelector(value) { return value * 1000; }\n * });\n *\n * result.subscribe({\n *   next: value => console.log(value),\n *   complete: () => console.log('Complete!') // This will never run\n * });\n *\n * // Logs:\n * // 0\n * // 1000\n * // 2000\n * // 3000\n * // ...and never stops.\n * ```\n *\n * @see {@link from}\n *\n * @param {S} initialState Initial state.\n * @param {function (state: S): boolean} condition Condition to terminate generation (upon returning false).\n * @param {function (state: S): S} iterate Iteration step function.\n * @param {function (state: S): T} [resultSelector] Selector function for results produced in the sequence.\n * @param {Scheduler} [scheduler] A {@link Scheduler} on which to run the generator loop. If not provided, defaults to emitting immediately.\n * @return {Observable<T>} The generated sequence.\n * @deprecated Instead of passing separate arguments, use the options argument. Signatures taking separate arguments will be removed in v8.\n */\nexport function generate<S>(\n  initialState: S,\n  condition: ConditionFunc<S>,\n  iterate: IterateFunc<S>,\n  scheduler?: SchedulerLike\n): Observable<S>;\n\n/**\n * Generates an observable sequence by running a state-driven loop\n * producing the sequence's elements, using the specified scheduler\n * to send out observer messages.\n * The overload accepts options object that might contain initial state, iterate,\n * condition and scheduler.\n *\n * ![](generate.png)\n *\n * ## Examples\n *\n * Use options object with condition function\n *\n * ```ts\n * import { generate } from 'rxjs';\n *\n * const result = generate({\n *   initialState: 0,\n *   condition: x => x < 3,\n *   iterate: x => x + 1\n * });\n *\n * result.subscribe({\n *   next: value => console.log(value),\n *   complete: () => console.log('Complete!')\n * });\n *\n * // Logs:\n * // 0\n * // 1\n * // 2\n * // 'Complete!'\n * ```\n *\n * @see {@link from}\n * @see {@link Observable}\n *\n * @param {GenerateBaseOptions<S>} options Object that must contain initialState, iterate and might contain condition and scheduler.\n * @returns {Observable<S>} The generated sequence.\n */\nexport function generate<S>(options: GenerateBaseOptions<S>): Observable<S>;\n\n/**\n * Generates an observable sequence by running a state-driven loop\n * producing the sequence's elements, using the specified scheduler\n * to send out observer messages.\n * The overload accepts options object that might contain initial state, iterate,\n * condition, result selector and scheduler.\n *\n * ![](generate.png)\n *\n * ## Examples\n *\n * Use options object with condition and iterate function\n *\n * ```ts\n * import { generate } from 'rxjs';\n *\n * const result = generate({\n *   initialState: 0,\n *   condition: x => x < 3,\n *   iterate: x => x + 1,\n *   resultSelector: x => x\n * });\n *\n * result.subscribe({\n *   next: value => console.log(value),\n *   complete: () => console.log('Complete!')\n * });\n *\n * // Logs:\n * // 0\n * // 1\n * // 2\n * // 'Complete!'\n * ```\n *\n * @see {@link from}\n * @see {@link Observable}\n *\n * @param {GenerateOptions<T, S>} options Object that must contain initialState, iterate, resultSelector and might contain condition and scheduler.\n * @returns {Observable<T>} The generated sequence.\n */\nexport function generate<T, S>(options: GenerateOptions<T, S>): Observable<T>;\n\nexport function generate<T, S>(\n  initialStateOrOptions: S | GenerateOptions<T, S>,\n  condition?: ConditionFunc<S>,\n  iterate?: IterateFunc<S>,\n  resultSelectorOrScheduler?: ResultFunc<S, T> | SchedulerLike,\n  scheduler?: SchedulerLike\n): Observable<T> {\n  let resultSelector: ResultFunc<S, T>;\n  let initialState: S;\n\n  // TODO: Remove this as we move away from deprecated signatures\n  // and move towards a configuration object argument.\n  if (arguments.length === 1) {\n    // If we only have one argument, we can assume it is a configuration object.\n    // Note that folks not using TypeScript may trip over this.\n    ({\n      initialState,\n      condition,\n      iterate,\n      resultSelector = identity as ResultFunc<S, T>,\n      scheduler,\n    } = initialStateOrOptions as GenerateOptions<T, S>);\n  } else {\n    // Deprecated arguments path. Figure out what the user\n    // passed and set it here.\n    initialState = initialStateOrOptions as S;\n    if (!resultSelectorOrScheduler || isScheduler(resultSelectorOrScheduler)) {\n      resultSelector = identity as ResultFunc<S, T>;\n      scheduler = resultSelectorOrScheduler as SchedulerLike;\n    } else {\n      resultSelector = resultSelectorOrScheduler as ResultFunc<S, T>;\n    }\n  }\n\n  // The actual generator used to \"generate\" values.\n  function* gen() {\n    for (let state = initialState; !condition || condition(state); state = iterate!(state)) {\n      yield resultSelector(state);\n    }\n  }\n\n  // We use `defer` because we want to defer the creation of the iterator from the iterable.\n  return defer(\n    (scheduler\n      ? // If a scheduler was provided, use `scheduleIterable` to ensure that iteration/generation\n        // happens on the scheduler.\n        () => scheduleIterable(gen(), scheduler!)\n      : // Otherwise, if there's no scheduler, we can just use the generator function directly in\n        // `defer` and executing it will return the generator (which is iterable).\n        gen) as () => ObservableInput<T>\n  );\n}\n","import { Observable } from '../Observable';\nimport { defer } from './defer';\nimport { ObservableInput } from '../types';\n\n/**\n * Checks a boolean at subscription time, and chooses between one of two observable sources\n *\n * `iif` expects a function that returns a boolean (the `condition` function), and two sources,\n * the `trueResult` and the `falseResult`, and returns an Observable.\n *\n * At the moment of subscription, the `condition` function is called. If the result is `true`, the\n * subscription will be to the source passed as the `trueResult`, otherwise, the subscription will be\n * to the source passed as the `falseResult`.\n *\n * If you need to check more than two options to choose between more than one observable, have a look at the {@link defer} creation method.\n *\n * ## Examples\n *\n * Change at runtime which Observable will be subscribed\n *\n * ```ts\n * import { iif, of } from 'rxjs';\n *\n * let subscribeToFirst;\n * const firstOrSecond = iif(\n *   () => subscribeToFirst,\n *   of('first'),\n *   of('second')\n * );\n *\n * subscribeToFirst = true;\n * firstOrSecond.subscribe(value => console.log(value));\n *\n * // Logs:\n * // 'first'\n *\n * subscribeToFirst = false;\n * firstOrSecond.subscribe(value => console.log(value));\n *\n * // Logs:\n * // 'second'\n * ```\n *\n * Control access to an Observable\n *\n * ```ts\n * import { iif, of, EMPTY } from 'rxjs';\n *\n * let accessGranted;\n * const observableIfYouHaveAccess = iif(\n *   () => accessGranted,\n *   of('It seems you have an access...'),\n *   EMPTY\n * );\n *\n * accessGranted = true;\n * observableIfYouHaveAccess.subscribe({\n *   next: value => console.log(value),\n *   complete: () => console.log('The end')\n * });\n *\n * // Logs:\n * // 'It seems you have an access...'\n * // 'The end'\n *\n * accessGranted = false;\n * observableIfYouHaveAccess.subscribe({\n *   next: value => console.log(value),\n *   complete: () => console.log('The end')\n * });\n *\n * // Logs:\n * // 'The end'\n * ```\n *\n * @see {@link defer}\n *\n * @param condition Condition which Observable should be chosen.\n * @param trueResult An Observable that will be subscribed if condition is true.\n * @param falseResult An Observable that will be subscribed if condition is false.\n * @return An observable that proxies to `trueResult` or `falseResult`, depending on the result of the `condition` function.\n */\nexport function iif<T, F>(condition: () => boolean, trueResult: ObservableInput<T>, falseResult: ObservableInput<F>): Observable<T | F> {\n  return defer(() => (condition() ? trueResult : falseResult));\n}\n","import { isArrayLike } from '../util/isArrayLike';\nimport { isPromise } from '../util/isPromise';\nimport { Observable } from '../Observable';\nimport { ObservableInput, ObservedValueOf, ReadableStreamLike } from '../types';\nimport { isInteropObservable } from '../util/isInteropObservable';\nimport { isAsyncIterable } from '../util/isAsyncIterable';\nimport { createInvalidObservableTypeError } from '../util/throwUnobservableError';\nimport { isIterable } from '../util/isIterable';\nimport { isReadableStreamLike, readableStreamLikeToAsyncGenerator } from '../util/isReadableStreamLike';\nimport { Subscriber } from '../Subscriber';\nimport { isFunction } from '../util/isFunction';\nimport { reportUnhandledError } from '../util/reportUnhandledError';\nimport { observable as Symbol_observable } from '../symbol/observable';\n\nexport function innerFrom<O extends ObservableInput<any>>(input: O): Observable<ObservedValueOf<O>>;\nexport function innerFrom<T>(input: ObservableInput<T>): Observable<T> {\n  if (input instanceof Observable) {\n    return input;\n  }\n  if (input != null) {\n    if (isInteropObservable(input)) {\n      return fromInteropObservable(input);\n    }\n    if (isArrayLike(input)) {\n      return fromArrayLike(input);\n    }\n    if (isPromise(input)) {\n      return fromPromise(input);\n    }\n    if (isAsyncIterable(input)) {\n      return fromAsyncIterable(input);\n    }\n    if (isIterable(input)) {\n      return fromIterable(input);\n    }\n    if (isReadableStreamLike(input)) {\n      return fromReadableStreamLike(input);\n    }\n  }\n\n  throw createInvalidObservableTypeError(input);\n}\n\n/**\n * Creates an RxJS Observable from an object that implements `Symbol.observable`.\n * @param obj An object that properly implements `Symbol.observable`.\n */\nexport function fromInteropObservable<T>(obj: any) {\n  return new Observable((subscriber: Subscriber<T>) => {\n    const obs = obj[Symbol_observable]();\n    if (isFunction(obs.subscribe)) {\n      return obs.subscribe(subscriber);\n    }\n    // Should be caught by observable subscribe function error handling.\n    throw new TypeError('Provided object does not correctly implement Symbol.observable');\n  });\n}\n\n/**\n * Synchronously emits the values of an array like and completes.\n * This is exported because there are creation functions and operators that need to\n * make direct use of the same logic, and there's no reason to make them run through\n * `from` conditionals because we *know* they're dealing with an array.\n * @param array The array to emit values from\n */\nexport function fromArrayLike<T>(array: ArrayLike<T>) {\n  return new Observable((subscriber: Subscriber<T>) => {\n    // Loop over the array and emit each value. Note two things here:\n    // 1. We're making sure that the subscriber is not closed on each loop.\n    //    This is so we don't continue looping over a very large array after\n    //    something like a `take`, `takeWhile`, or other synchronous unsubscription\n    //    has already unsubscribed.\n    // 2. In this form, reentrant code can alter that array we're looping over.\n    //    This is a known issue, but considered an edge case. The alternative would\n    //    be to copy the array before executing the loop, but this has\n    //    performance implications.\n    for (let i = 0; i < array.length && !subscriber.closed; i++) {\n      subscriber.next(array[i]);\n    }\n    subscriber.complete();\n  });\n}\n\nexport function fromPromise<T>(promise: PromiseLike<T>) {\n  return new Observable((subscriber: Subscriber<T>) => {\n    promise\n      .then(\n        (value) => {\n          if (!subscriber.closed) {\n            subscriber.next(value);\n            subscriber.complete();\n          }\n        },\n        (err: any) => subscriber.error(err)\n      )\n      .then(null, reportUnhandledError);\n  });\n}\n\nexport function fromIterable<T>(iterable: Iterable<T>) {\n  return new Observable((subscriber: Subscriber<T>) => {\n    for (const value of iterable) {\n      subscriber.next(value);\n      if (subscriber.closed) {\n        return;\n      }\n    }\n    subscriber.complete();\n  });\n}\n\nexport function fromAsyncIterable<T>(asyncIterable: AsyncIterable<T>) {\n  return new Observable((subscriber: Subscriber<T>) => {\n    process(asyncIterable, subscriber).catch((err) => subscriber.error(err));\n  });\n}\n\nexport function fromReadableStreamLike<T>(readableStream: ReadableStreamLike<T>) {\n  return fromAsyncIterable(readableStreamLikeToAsyncGenerator(readableStream));\n}\n\nasync function process<T>(asyncIterable: AsyncIterable<T>, subscriber: Subscriber<T>) {\n  for await (const value of asyncIterable) {\n    subscriber.next(value);\n    // A side-effect may have closed our subscriber,\n    // check before the next iteration.\n    if (subscriber.closed) {\n      return;\n    }\n  }\n  subscriber.complete();\n}\n","import { Observable } from '../Observable';\nimport { asyncScheduler } from '../scheduler/async';\nimport { SchedulerLike } from '../types';\nimport { timer } from './timer';\n\n/**\n * Creates an Observable that emits sequential numbers every specified\n * interval of time, on a specified {@link SchedulerLike}.\n *\n * <span class=\"informal\">Emits incremental numbers periodically in time.</span>\n *\n * ![](interval.png)\n *\n * `interval` returns an Observable that emits an infinite sequence of\n * ascending integers, with a constant interval of time of your choosing\n * between those emissions. The first emission is not sent immediately, but\n * only after the first period has passed. By default, this operator uses the\n * `async` {@link SchedulerLike} to provide a notion of time, but you may pass any\n * {@link SchedulerLike} to it.\n *\n * ## Example\n *\n * Emits ascending numbers, one every second (1000ms) up to the number 3\n *\n * ```ts\n * import { interval, take } from 'rxjs';\n *\n * const numbers = interval(1000);\n *\n * const takeFourNumbers = numbers.pipe(take(4));\n *\n * takeFourNumbers.subscribe(x => console.log('Next: ', x));\n *\n * // Logs:\n * // Next: 0\n * // Next: 1\n * // Next: 2\n * // Next: 3\n * ```\n *\n * @see {@link timer}\n * @see {@link delay}\n *\n * @param {number} [period=0] The interval size in milliseconds (by default)\n * or the time unit determined by the scheduler's clock.\n * @param {SchedulerLike} [scheduler=async] The {@link SchedulerLike} to use for scheduling\n * the emission of values, and providing a notion of \"time\".\n * @return {Observable} An Observable that emits a sequential number each time\n * interval.\n */\nexport function interval(period = 0, scheduler: SchedulerLike = asyncScheduler): Observable<number> {\n  if (period < 0) {\n    // We cannot schedule an interval in the past.\n    period = 0;\n  }\n\n  return timer(period, period, scheduler);\n}\n","import { Observable } from '../Observable';\nimport { ObservableInput, ObservableInputTuple, SchedulerLike } from '../types';\nimport { mergeAll } from '../operators/mergeAll';\nimport { innerFrom } from './innerFrom';\nimport { EMPTY } from './empty';\nimport { popNumber, popScheduler } from '../util/args';\nimport { from } from './from';\n\nexport function merge<A extends readonly unknown[]>(...sources: [...ObservableInputTuple<A>]): Observable<A[number]>;\nexport function merge<A extends readonly unknown[]>(...sourcesAndConcurrency: [...ObservableInputTuple<A>, number?]): Observable<A[number]>;\n/** @deprecated The `scheduler` parameter will be removed in v8. Use `scheduled` and `mergeAll`. Details: https://rxjs.dev/deprecations/scheduler-argument */\nexport function merge<A extends readonly unknown[]>(\n  ...sourcesAndScheduler: [...ObservableInputTuple<A>, SchedulerLike?]\n): Observable<A[number]>;\n/** @deprecated The `scheduler` parameter will be removed in v8. Use `scheduled` and `mergeAll`. Details: https://rxjs.dev/deprecations/scheduler-argument */\nexport function merge<A extends readonly unknown[]>(\n  ...sourcesAndConcurrencyAndScheduler: [...ObservableInputTuple<A>, number?, SchedulerLike?]\n): Observable<A[number]>;\n\n/**\n * Creates an output Observable which concurrently emits all values from every\n * given input Observable.\n *\n * <span class=\"informal\">Flattens multiple Observables together by blending\n * their values into one Observable.</span>\n *\n * ![](merge.png)\n *\n * `merge` subscribes to each given input Observable (as arguments), and simply\n * forwards (without doing any transformation) all the values from all the input\n * Observables to the output Observable. The output Observable only completes\n * once all input Observables have completed. Any error delivered by an input\n * Observable will be immediately emitted on the output Observable.\n *\n * ## Examples\n *\n * Merge together two Observables: 1s interval and clicks\n *\n * ```ts\n * import { merge, fromEvent, interval } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const timer = interval(1000);\n * const clicksOrTimer = merge(clicks, timer);\n * clicksOrTimer.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // timer will emit ascending values, one every second(1000ms) to console\n * // clicks logs MouseEvents to console every time the \"document\" is clicked\n * // Since the two streams are merged you see these happening\n * // as they occur.\n * ```\n *\n * Merge together 3 Observables, but run only 2 concurrently\n *\n * ```ts\n * import { interval, take, merge } from 'rxjs';\n *\n * const timer1 = interval(1000).pipe(take(10));\n * const timer2 = interval(2000).pipe(take(6));\n * const timer3 = interval(500).pipe(take(10));\n *\n * const concurrent = 2; // the argument\n * const merged = merge(timer1, timer2, timer3, concurrent);\n * merged.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // - First timer1 and timer2 will run concurrently\n * // - timer1 will emit a value every 1000ms for 10 iterations\n * // - timer2 will emit a value every 2000ms for 6 iterations\n * // - after timer1 hits its max iteration, timer2 will\n * //   continue, and timer3 will start to run concurrently with timer2\n * // - when timer2 hits its max iteration it terminates, and\n * //   timer3 will continue to emit a value every 500ms until it is complete\n * ```\n *\n * @see {@link mergeAll}\n * @see {@link mergeMap}\n * @see {@link mergeMapTo}\n * @see {@link mergeScan}\n *\n * @param {...ObservableInput} observables Input Observables to merge together.\n * @param {number} [concurrent=Infinity] Maximum number of input\n * Observables being subscribed to concurrently.\n * @param {SchedulerLike} [scheduler=null] The {@link SchedulerLike} to use for managing\n * concurrency of input Observables.\n * @return {Observable} an Observable that emits items that are the result of\n * every input Observable.\n */\nexport function merge(...args: (ObservableInput<unknown> | number | SchedulerLike)[]): Observable<unknown> {\n  const scheduler = popScheduler(args);\n  const concurrent = popNumber(args, Infinity);\n  const sources = args as ObservableInput<unknown>[];\n  return !sources.length\n    ? // No source provided\n      EMPTY\n    : sources.length === 1\n    ? // One source? Just return it.\n      innerFrom(sources[0])\n    : // Merge all sources\n      mergeAll(concurrent)(from(sources, scheduler));\n}\n","import { Observable } from '../Observable';\nimport { noop } from '../util/noop';\n\n/**\n * An Observable that emits no items to the Observer and never completes.\n *\n * ![](never.png)\n *\n * A simple Observable that emits neither values nor errors nor the completion\n * notification. It can be used for testing purposes or for composing with other\n * Observables. Please note that by never emitting a complete notification, this\n * Observable keeps the subscription from being disposed automatically.\n * Subscriptions need to be manually disposed.\n *\n * ##  Example\n *\n * Emit the number 7, then never emit anything else (not even complete)\n *\n * ```ts\n * import { NEVER, startWith } from 'rxjs';\n *\n * const info = () => console.log('Will not be called');\n *\n * const result = NEVER.pipe(startWith(7));\n * result.subscribe({\n *   next: x => console.log(x),\n *   error: info,\n *   complete: info\n * });\n * ```\n *\n * @see {@link Observable}\n * @see {@link EMPTY}\n * @see {@link of}\n * @see {@link throwError}\n */\nexport const NEVER = new Observable<never>(noop);\n\n/**\n * @deprecated Replaced with the {@link NEVER} constant. Will be removed in v8.\n */\nexport function never() {\n  return NEVER;\n}\n","import { SchedulerLike, ValueFromArray } from '../types';\nimport { Observable } from '../Observable';\nimport { popScheduler } from '../util/args';\nimport { from } from './from';\n\n// Devs are more likely to pass null or undefined than they are a scheduler\n// without accompanying values. To make things easier for (naughty) devs who\n// use the `strictNullChecks: false` TypeScript compiler option, these\n// overloads with explicit null and undefined values are included.\n\nexport function of(value: null): Observable<null>;\nexport function of(value: undefined): Observable<undefined>;\n\n/** @deprecated The `scheduler` parameter will be removed in v8. Use `scheduled`. Details: https://rxjs.dev/deprecations/scheduler-argument */\nexport function of(scheduler: SchedulerLike): Observable<never>;\n/** @deprecated The `scheduler` parameter will be removed in v8. Use `scheduled`. Details: https://rxjs.dev/deprecations/scheduler-argument */\nexport function of<A extends readonly unknown[]>(...valuesAndScheduler: [...A, SchedulerLike]): Observable<ValueFromArray<A>>;\n\nexport function of(): Observable<never>;\n/** @deprecated Do not specify explicit type parameters. Signatures with type parameters that cannot be inferred will be removed in v8. */\nexport function of<T>(): Observable<T>;\nexport function of<T>(value: T): Observable<T>;\nexport function of<A extends readonly unknown[]>(...values: A): Observable<ValueFromArray<A>>;\n\n/**\n * Converts the arguments to an observable sequence.\n *\n * <span class=\"informal\">Each argument becomes a `next` notification.</span>\n *\n * ![](of.png)\n *\n * Unlike {@link from}, it does not do any flattening and emits each argument in whole\n * as a separate `next` notification.\n *\n * ## Examples\n *\n * Emit the values `10, 20, 30`\n *\n * ```ts\n * import { of } from 'rxjs';\n *\n * of(10, 20, 30)\n *   .subscribe({\n *     next: value => console.log('next:', value),\n *     error: err => console.log('error:', err),\n *     complete: () => console.log('the end'),\n *   });\n *\n * // Outputs\n * // next: 10\n * // next: 20\n * // next: 30\n * // the end\n * ```\n *\n * Emit the array `[1, 2, 3]`\n *\n * ```ts\n * import { of } from 'rxjs';\n *\n * of([1, 2, 3])\n *   .subscribe({\n *     next: value => console.log('next:', value),\n *     error: err => console.log('error:', err),\n *     complete: () => console.log('the end'),\n *   });\n *\n * // Outputs\n * // next: [1, 2, 3]\n * // the end\n * ```\n *\n * @see {@link from}\n * @see {@link range}\n *\n * @param {...T} values A comma separated list of arguments you want to be emitted\n * @return {Observable} An Observable that emits the arguments\n * described above and then completes.\n */\nexport function of<T>(...args: Array<T | SchedulerLike>): Observable<T> {\n  const scheduler = popScheduler(args);\n  return from(args as T[], scheduler);\n}\n","import { Observable } from '../Observable';\nimport { ObservableInputTuple } from '../types';\nimport { argsOrArgArray } from '../util/argsOrArgArray';\nimport { OperatorSubscriber } from '../operators/OperatorSubscriber';\nimport { noop } from '../util/noop';\nimport { innerFrom } from './innerFrom';\n\n/* tslint:disable:max-line-length */\nexport function onErrorResumeNext<A extends readonly unknown[]>(sources: [...ObservableInputTuple<A>]): Observable<A[number]>;\nexport function onErrorResumeNext<A extends readonly unknown[]>(...sources: [...ObservableInputTuple<A>]): Observable<A[number]>;\n\n/* tslint:enable:max-line-length */\n\n/**\n * When any of the provided Observable emits a complete or an error notification, it immediately subscribes to the next one\n * that was passed.\n *\n * <span class=\"informal\">Execute series of Observables no matter what, even if it means swallowing errors.</span>\n *\n * ![](onErrorResumeNext.png)\n *\n * `onErrorResumeNext` will subscribe to each observable source it is provided, in order.\n * If the source it's subscribed to emits an error or completes, it will move to the next source\n * without error.\n *\n * If `onErrorResumeNext` is provided no arguments, or a single, empty array, it will return {@link EMPTY}.\n *\n * `onErrorResumeNext` is basically {@link concat}, only it will continue, even if one of its\n * sources emits an error.\n *\n * Note that there is no way to handle any errors thrown by sources via the result of\n * `onErrorResumeNext`. If you want to handle errors thrown in any given source, you can\n * always use the {@link catchError} operator on them before passing them into `onErrorResumeNext`.\n *\n * ## Example\n *\n * Subscribe to the next Observable after map fails\n *\n * ```ts\n * import { onErrorResumeNext, of, map } from 'rxjs';\n *\n * onErrorResumeNext(\n *   of(1, 2, 3, 0).pipe(\n *     map(x => {\n *       if (x === 0) {\n *         throw Error();\n *       }\n *       return 10 / x;\n *     })\n *   ),\n *   of(1, 2, 3)\n * )\n * .subscribe({\n *   next: value => console.log(value),\n *   error: err => console.log(err),     // Will never be called.\n *   complete: () => console.log('done')\n * });\n *\n * // Logs:\n * // 10\n * // 5\n * // 3.3333333333333335\n * // 1\n * // 2\n * // 3\n * // 'done'\n * ```\n *\n * @see {@link concat}\n * @see {@link catchError}\n *\n * @param {...ObservableInput} sources Observables (or anything that *is* observable) passed either directly or as an array.\n * @return {Observable} An Observable that concatenates all sources, one after the other,\n * ignoring all errors, such that any error causes it to move on to the next source.\n */\nexport function onErrorResumeNext<A extends readonly unknown[]>(\n  ...sources: [[...ObservableInputTuple<A>]] | [...ObservableInputTuple<A>]\n): Observable<A[number]> {\n  const nextSources: ObservableInputTuple<A> = argsOrArgArray(sources) as any;\n\n  return new Observable((subscriber) => {\n    let sourceIndex = 0;\n    const subscribeNext = () => {\n      if (sourceIndex < nextSources.length) {\n        let nextSource: Observable<A[number]>;\n        try {\n          nextSource = innerFrom(nextSources[sourceIndex++]);\n        } catch (err) {\n          subscribeNext();\n          return;\n        }\n        const innerSubscriber = new OperatorSubscriber(subscriber, undefined, noop, noop);\n        nextSource.subscribe(innerSubscriber);\n        innerSubscriber.add(subscribeNext);\n      } else {\n        subscriber.complete();\n      }\n    };\n    subscribeNext();\n  });\n}\n","import { Observable } from '../Observable';\nimport { SchedulerLike } from '../types';\nimport { from } from './from';\n\n/**\n * @deprecated Use `from(Object.entries(obj))` instead. Will be removed in v8.\n */\nexport function pairs<T>(arr: readonly T[], scheduler?: SchedulerLike): Observable<[string, T]>;\n/**\n * @deprecated Use `from(Object.entries(obj))` instead. Will be removed in v8.\n */\nexport function pairs<O extends Record<string, unknown>>(obj: O, scheduler?: SchedulerLike): Observable<[keyof O, O[keyof O]]>;\n/**\n * @deprecated Use `from(Object.entries(obj))` instead. Will be removed in v8.\n */\nexport function pairs<T>(iterable: Iterable<T>, scheduler?: SchedulerLike): Observable<[string, T]>;\n/**\n * @deprecated Use `from(Object.entries(obj))` instead. Will be removed in v8.\n */\nexport function pairs(\n  n: number | bigint | boolean | ((...args: any[]) => any) | symbol,\n  scheduler?: SchedulerLike\n): Observable<[never, never]>;\n\n/**\n * Convert an object into an Observable of `[key, value]` pairs.\n *\n * <span class=\"informal\">Turn entries of an object into a stream.</span>\n *\n * ![](pairs.png)\n *\n * `pairs` takes an arbitrary object and returns an Observable that emits arrays. Each\n * emitted array has exactly two elements - the first is a key from the object\n * and the second is a value corresponding to that key. Keys are extracted from\n * an object via `Object.keys` function, which means that they will be only\n * enumerable keys that are present on an object directly - not ones inherited\n * via prototype chain.\n *\n * By default, these arrays are emitted synchronously. To change that you can\n * pass a {@link SchedulerLike} as a second argument to `pairs`.\n *\n * ## Example\n *\n * Converts an object to an Observable\n *\n * ```ts\n * import { pairs } from 'rxjs';\n *\n * const obj = {\n *   foo: 42,\n *   bar: 56,\n *   baz: 78\n * };\n *\n * pairs(obj).subscribe({\n *   next: value => console.log(value),\n *   complete: () => console.log('Complete!')\n * });\n *\n * // Logs:\n * // ['foo', 42]\n * // ['bar', 56]\n * // ['baz', 78]\n * // 'Complete!'\n * ```\n *\n * ### Object.entries required\n *\n * In IE, you will need to polyfill `Object.entries` in order to use this.\n * [MDN has a polyfill here](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries)\n *\n * @param {Object} obj The object to inspect and turn into an\n * Observable sequence.\n * @param {Scheduler} [scheduler] An optional IScheduler to schedule\n * when resulting Observable will emit values.\n * @returns {(Observable<Array<string|T>>)} An observable sequence of\n * [key, value] pairs from the object.\n * @deprecated Use `from(Object.entries(obj))` instead. Will be removed in v8.\n */\nexport function pairs(obj: any, scheduler?: SchedulerLike) {\n  return from(Object.entries(obj), scheduler as any);\n}\n","import { not } from '../util/not';\nimport { filter } from '../operators/filter';\nimport { ObservableInput } from '../types';\nimport { Observable } from '../Observable';\nimport { innerFrom } from './innerFrom';\n\n/** @deprecated Use a closure instead of a `thisArg`. Signatures accepting a `thisArg` will be removed in v8. */\nexport function partition<T, U extends T, A>(\n  source: ObservableInput<T>,\n  predicate: (this: A, value: T, index: number) => value is U,\n  thisArg: A\n): [Observable<U>, Observable<Exclude<T, U>>];\nexport function partition<T, U extends T>(\n  source: ObservableInput<T>,\n  predicate: (value: T, index: number) => value is U\n): [Observable<U>, Observable<Exclude<T, U>>];\n\n/** @deprecated Use a closure instead of a `thisArg`. Signatures accepting a `thisArg` will be removed in v8. */\nexport function partition<T, A>(\n  source: ObservableInput<T>,\n  predicate: (this: A, value: T, index: number) => boolean,\n  thisArg: A\n): [Observable<T>, Observable<T>];\nexport function partition<T>(source: ObservableInput<T>, predicate: (value: T, index: number) => boolean): [Observable<T>, Observable<T>];\n\n/**\n * Splits the source Observable into two, one with values that satisfy a\n * predicate, and another with values that don't satisfy the predicate.\n *\n * <span class=\"informal\">It's like {@link filter}, but returns two Observables:\n * one like the output of {@link filter}, and the other with values that did not\n * pass the condition.</span>\n *\n * ![](partition.png)\n *\n * `partition` outputs an array with two Observables that partition the values\n * from the source Observable through the given `predicate` function. The first\n * Observable in that array emits source values for which the predicate argument\n * returns true. The second Observable emits source values for which the\n * predicate returns false. The first behaves like {@link filter} and the second\n * behaves like {@link filter} with the predicate negated.\n *\n * ## Example\n *\n * Partition a set of numbers into odds and evens observables\n *\n * ```ts\n * import { of, partition } from 'rxjs';\n *\n * const observableValues = of(1, 2, 3, 4, 5, 6);\n * const [evens$, odds$] = partition(observableValues, value => value % 2 === 0);\n *\n * odds$.subscribe(x => console.log('odds', x));\n * evens$.subscribe(x => console.log('evens', x));\n *\n * // Logs:\n * // odds 1\n * // odds 3\n * // odds 5\n * // evens 2\n * // evens 4\n * // evens 6\n * ```\n *\n * @see {@link filter}\n *\n * @param {function(value: T, index: number): boolean} predicate A function that\n * evaluates each value emitted by the source Observable. If it returns `true`,\n * the value is emitted on the first Observable in the returned array, if\n * `false` the value is emitted on the second Observable in the array. The\n * `index` parameter is the number `i` for the i-th source emission that has\n * happened since the subscription, starting from the number `0`.\n * @param {any} [thisArg] An optional argument to determine the value of `this`\n * in the `predicate` function.\n * @return {[Observable<T>, Observable<T>]} An array with two Observables: one\n * with values that passed the predicate, and another with values that did not\n * pass the predicate.\n */\nexport function partition<T>(\n  source: ObservableInput<T>,\n  predicate: (this: any, value: T, index: number) => boolean,\n  thisArg?: any\n): [Observable<T>, Observable<T>] {\n  return [filter(predicate, thisArg)(innerFrom(source)), filter(not(predicate, thisArg))(innerFrom(source))] as [\n    Observable<T>,\n    Observable<T>\n  ];\n}\n","import { Observable } from '../Observable';\nimport { innerFrom } from './innerFrom';\nimport { Subscription } from '../Subscription';\nimport { ObservableInput, ObservableInputTuple } from '../types';\nimport { argsOrArgArray } from '../util/argsOrArgArray';\nimport { createOperatorSubscriber } from '../operators/OperatorSubscriber';\nimport { Subscriber } from '../Subscriber';\n\nexport function race<T extends readonly unknown[]>(inputs: [...ObservableInputTuple<T>]): Observable<T[number]>;\nexport function race<T extends readonly unknown[]>(...inputs: [...ObservableInputTuple<T>]): Observable<T[number]>;\n\n/**\n * Returns an observable that mirrors the first source observable to emit an item.\n *\n * ![](race.png)\n *\n * `race` returns an observable, that when subscribed to, subscribes to all source observables immediately.\n * As soon as one of the source observables emits a value, the result unsubscribes from the other sources.\n * The resulting observable will forward all notifications, including error and completion, from the \"winning\"\n * source observable.\n *\n * If one of the used source observable throws an errors before a first notification\n * the race operator will also throw an error, no matter if another source observable\n * could potentially win the race.\n *\n * `race` can be useful for selecting the response from the fastest network connection for\n * HTTP or WebSockets. `race` can also be useful for switching observable context based on user\n * input.\n *\n * ## Example\n *\n * Subscribes to the observable that was the first to start emitting.\n *\n * ```ts\n * import { interval, map, race } from 'rxjs';\n *\n * const obs1 = interval(7000).pipe(map(() => 'slow one'));\n * const obs2 = interval(3000).pipe(map(() => 'fast one'));\n * const obs3 = interval(5000).pipe(map(() => 'medium one'));\n *\n * race(obs1, obs2, obs3)\n *   .subscribe(winner => console.log(winner));\n *\n * // Outputs\n * // a series of 'fast one'\n * ```\n *\n * @param {...Observables} ...observables sources used to race for which Observable emits first.\n * @return {Observable} an Observable that mirrors the output of the first Observable to emit an item.\n */\nexport function race<T>(...sources: (ObservableInput<T> | ObservableInput<T>[])[]): Observable<any> {\n  sources = argsOrArgArray(sources);\n  // If only one source was passed, just return it. Otherwise return the race.\n  return sources.length === 1 ? innerFrom(sources[0] as ObservableInput<T>) : new Observable<T>(raceInit(sources as ObservableInput<T>[]));\n}\n\n/**\n * An observable initializer function for both the static version and the\n * operator version of race.\n * @param sources The sources to race\n */\nexport function raceInit<T>(sources: ObservableInput<T>[]) {\n  return (subscriber: Subscriber<T>) => {\n    let subscriptions: Subscription[] = [];\n\n    // Subscribe to all of the sources. Note that we are checking `subscriptions` here\n    // Is is an array of all actively \"racing\" subscriptions, and it is `null` after the\n    // race has been won. So, if we have racer that synchronously \"wins\", this loop will\n    // stop before it subscribes to any more.\n    for (let i = 0; subscriptions && !subscriber.closed && i < sources.length; i++) {\n      subscriptions.push(\n        innerFrom(sources[i] as ObservableInput<T>).subscribe(\n          createOperatorSubscriber(subscriber, (value) => {\n            if (subscriptions) {\n              // We're still racing, but we won! So unsubscribe\n              // all other subscriptions that we have, except this one.\n              for (let s = 0; s < subscriptions.length; s++) {\n                s !== i && subscriptions[s].unsubscribe();\n              }\n              subscriptions = null!;\n            }\n            subscriber.next(value);\n          })\n        )\n      );\n    }\n  };\n}\n","import { SchedulerLike } from '../types';\nimport { Observable } from '../Observable';\nimport { EMPTY } from './empty';\n\nexport function range(start: number, count?: number): Observable<number>;\n\n/**\n * @deprecated The `scheduler` parameter will be removed in v8. Use `range(start, count).pipe(observeOn(scheduler))` instead. Details: Details: https://rxjs.dev/deprecations/scheduler-argument\n */\nexport function range(start: number, count: number | undefined, scheduler: SchedulerLike): Observable<number>;\n\n/**\n * Creates an Observable that emits a sequence of numbers within a specified\n * range.\n *\n * <span class=\"informal\">Emits a sequence of numbers in a range.</span>\n *\n * ![](range.png)\n *\n * `range` operator emits a range of sequential integers, in order, where you\n * select the `start` of the range and its `length`. By default, uses no\n * {@link SchedulerLike} and just delivers the notifications synchronously, but may use\n * an optional {@link SchedulerLike} to regulate those deliveries.\n *\n * ## Example\n *\n * Produce a range of numbers\n *\n * ```ts\n * import { range } from 'rxjs';\n *\n * const numbers = range(1, 3);\n *\n * numbers.subscribe({\n *   next: value => console.log(value),\n *   complete: () => console.log('Complete!')\n * });\n *\n * // Logs:\n * // 1\n * // 2\n * // 3\n * // 'Complete!'\n * ```\n *\n * @see {@link timer}\n * @see {@link interval}\n *\n * @param {number} [start=0] The value of the first integer in the sequence.\n * @param {number} count The number of sequential integers to generate.\n * @param {SchedulerLike} [scheduler] A {@link SchedulerLike} to use for scheduling\n * the emissions of the notifications.\n * @return {Observable} An Observable of numbers that emits a finite range of\n * sequential integers.\n */\nexport function range(start: number, count?: number, scheduler?: SchedulerLike): Observable<number> {\n  if (count == null) {\n    // If one argument was passed, it's the count, not the start.\n    count = start;\n    start = 0;\n  }\n\n  if (count <= 0) {\n    // No count? We're going nowhere. Return EMPTY.\n    return EMPTY;\n  }\n\n  // Where the range should stop.\n  const end = count + start;\n\n  return new Observable(\n    scheduler\n      ? // The deprecated scheduled path.\n        (subscriber) => {\n          let n = start;\n          return scheduler.schedule(function () {\n            if (n < end) {\n              subscriber.next(n++);\n              this.schedule();\n            } else {\n              subscriber.complete();\n            }\n          });\n        }\n      : // Standard synchronous range.\n        (subscriber) => {\n          let n = start;\n          while (n < end && !subscriber.closed) {\n            subscriber.next(n++);\n          }\n          subscriber.complete();\n        }\n  );\n}\n","import { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { SchedulerLike } from '../types';\nimport { isFunction } from '../util/isFunction';\n\n/**\n * Creates an observable that will create an error instance and push it to the consumer as an error\n * immediately upon subscription.\n *\n * <span class=\"informal\">Just errors and does nothing else</span>\n *\n * ![](throw.png)\n *\n * This creation function is useful for creating an observable that will create an error and error every\n * time it is subscribed to. Generally, inside of most operators when you might want to return an errored\n * observable, this is unnecessary. In most cases, such as in the inner return of {@link concatMap},\n * {@link mergeMap}, {@link defer}, and many others, you can simply throw the error, and RxJS will pick\n * that up and notify the consumer of the error.\n *\n * ## Example\n *\n * Create a simple observable that will create a new error with a timestamp and log it\n * and the message every time you subscribe to it\n *\n * ```ts\n * import { throwError } from 'rxjs';\n *\n * let errorCount = 0;\n *\n * const errorWithTimestamp$ = throwError(() => {\n *   const error: any = new Error(`This is error number ${ ++errorCount }`);\n *   error.timestamp = Date.now();\n *   return error;\n * });\n *\n * errorWithTimestamp$.subscribe({\n *   error: err => console.log(err.timestamp, err.message)\n * });\n *\n * errorWithTimestamp$.subscribe({\n *   error: err => console.log(err.timestamp, err.message)\n * });\n *\n * // Logs the timestamp and a new error message for each subscription\n * ```\n *\n * ### Unnecessary usage\n *\n * Using `throwError` inside of an operator or creation function\n * with a callback, is usually not necessary\n *\n * ```ts\n * import { of, concatMap, timer, throwError } from 'rxjs';\n *\n * const delays$ = of(1000, 2000, Infinity, 3000);\n *\n * delays$.pipe(\n *   concatMap(ms => {\n *     if (ms < 10000) {\n *       return timer(ms);\n *     } else {\n *       // This is probably overkill.\n *       return throwError(() => new Error(`Invalid time ${ ms }`));\n *     }\n *   })\n * )\n * .subscribe({\n *   next: console.log,\n *   error: console.error\n * });\n * ```\n *\n * You can just throw the error instead\n *\n * ```ts\n * import { of, concatMap, timer } from 'rxjs';\n *\n * const delays$ = of(1000, 2000, Infinity, 3000);\n *\n * delays$.pipe(\n *   concatMap(ms => {\n *     if (ms < 10000) {\n *       return timer(ms);\n *     } else {\n *       // Cleaner and easier to read for most folks.\n *       throw new Error(`Invalid time ${ ms }`);\n *     }\n *   })\n * )\n * .subscribe({\n *   next: console.log,\n *   error: console.error\n * });\n * ```\n *\n * @param errorFactory A factory function that will create the error instance that is pushed.\n */\nexport function throwError(errorFactory: () => any): Observable<never>;\n\n/**\n * Returns an observable that will error with the specified error immediately upon subscription.\n *\n * @param error The error instance to emit\n * @deprecated Support for passing an error value will be removed in v8. Instead, pass a factory function to `throwError(() => new Error('test'))`. This is\n * because it will create the error at the moment it should be created and capture a more appropriate stack trace. If\n * for some reason you need to create the error ahead of time, you can still do that: `const err = new Error('test'); throwError(() => err);`.\n */\nexport function throwError(error: any): Observable<never>;\n\n/**\n * Notifies the consumer of an error using a given scheduler by scheduling it at delay `0` upon subscription.\n *\n * @param errorOrErrorFactory An error instance or error factory\n * @param scheduler A scheduler to use to schedule the error notification\n * @deprecated The `scheduler` parameter will be removed in v8.\n * Use `throwError` in combination with {@link observeOn}: `throwError(() => new Error('test')).pipe(observeOn(scheduler));`.\n * Details: https://rxjs.dev/deprecations/scheduler-argument\n */\nexport function throwError(errorOrErrorFactory: any, scheduler: SchedulerLike): Observable<never>;\n\nexport function throwError(errorOrErrorFactory: any, scheduler?: SchedulerLike): Observable<never> {\n  const errorFactory = isFunction(errorOrErrorFactory) ? errorOrErrorFactory : () => errorOrErrorFactory;\n  const init = (subscriber: Subscriber<never>) => subscriber.error(errorFactory());\n  return new Observable(scheduler ? (subscriber) => scheduler.schedule(init as any, 0, subscriber) : init);\n}\n","import { Observable } from '../Observable';\nimport { SchedulerLike } from '../types';\nimport { async as asyncScheduler } from '../scheduler/async';\nimport { isScheduler } from '../util/isScheduler';\nimport { isValidDate } from '../util/isDate';\n\n/**\n * Creates an observable that will wait for a specified time period, or exact date, before\n * emitting the number 0.\n *\n * <span class=\"informal\">Used to emit a notification after a delay.</span>\n *\n * This observable is useful for creating delays in code, or racing against other values\n * for ad-hoc timeouts.\n *\n * The `delay` is specified by default in milliseconds, however providing a custom scheduler could\n * create a different behavior.\n *\n * ## Examples\n *\n * Wait 3 seconds and start another observable\n *\n * You might want to use `timer` to delay subscription to an\n * observable by a set amount of time. Here we use a timer with\n * {@link concatMapTo} or {@link concatMap} in order to wait\n * a few seconds and start a subscription to a source.\n *\n * ```ts\n * import { of, timer, concatMap } from 'rxjs';\n *\n * // This could be any observable\n * const source = of(1, 2, 3);\n *\n * timer(3000)\n *   .pipe(concatMap(() => source))\n *   .subscribe(console.log);\n * ```\n *\n * Take all values until the start of the next minute\n *\n * Using a `Date` as the trigger for the first emission, you can\n * do things like wait until midnight to fire an event, or in this case,\n * wait until a new minute starts (chosen so the example wouldn't take\n * too long to run) in order to stop watching a stream. Leveraging\n * {@link takeUntil}.\n *\n * ```ts\n * import { interval, takeUntil, timer } from 'rxjs';\n *\n * // Build a Date object that marks the\n * // next minute.\n * const currentDate = new Date();\n * const startOfNextMinute = new Date(\n *   currentDate.getFullYear(),\n *   currentDate.getMonth(),\n *   currentDate.getDate(),\n *   currentDate.getHours(),\n *   currentDate.getMinutes() + 1\n * );\n *\n * // This could be any observable stream\n * const source = interval(1000);\n *\n * const result = source.pipe(\n *   takeUntil(timer(startOfNextMinute))\n * );\n *\n * result.subscribe(console.log);\n * ```\n *\n * ### Known Limitations\n *\n * - The {@link asyncScheduler} uses `setTimeout` which has limitations for how far in the future it can be scheduled.\n *\n * - If a `scheduler` is provided that returns a timestamp other than an epoch from `now()`, and\n * a `Date` object is passed to the `dueTime` argument, the calculation for when the first emission\n * should occur will be incorrect. In this case, it would be best to do your own calculations\n * ahead of time, and pass a `number` in as the `dueTime`.\n *\n * @param due If a `number`, the amount of time in milliseconds to wait before emitting.\n * If a `Date`, the exact time at which to emit.\n * @param scheduler The scheduler to use to schedule the delay. Defaults to {@link asyncScheduler}.\n */\nexport function timer(due: number | Date, scheduler?: SchedulerLike): Observable<0>;\n\n/**\n * Creates an observable that starts an interval after a specified delay, emitting incrementing numbers -- starting at `0` --\n * on each interval after words.\n *\n * The `delay` and `intervalDuration` are specified by default in milliseconds, however providing a custom scheduler could\n * create a different behavior.\n *\n * ## Example\n *\n * ### Start an interval that starts right away\n *\n * Since {@link interval} waits for the passed delay before starting,\n * sometimes that's not ideal. You may want to start an interval immediately.\n * `timer` works well for this. Here we have both side-by-side so you can\n * see them in comparison.\n *\n * Note that this observable will never complete.\n *\n * ```ts\n * import { timer, interval } from 'rxjs';\n *\n * timer(0, 1000).subscribe(n => console.log('timer', n));\n * interval(1000).subscribe(n => console.log('interval', n));\n * ```\n *\n * ### Known Limitations\n *\n * - The {@link asyncScheduler} uses `setTimeout` which has limitations for how far in the future it can be scheduled.\n *\n * - If a `scheduler` is provided that returns a timestamp other than an epoch from `now()`, and\n * a `Date` object is passed to the `dueTime` argument, the calculation for when the first emission\n * should occur will be incorrect. In this case, it would be best to do your own calculations\n * ahead of time, and pass a `number` in as the `startDue`.\n * @param startDue If a `number`, is the time to wait before starting the interval.\n * If a `Date`, is the exact time at which to start the interval.\n * @param intervalDuration The delay between each value emitted in the interval. Passing a\n * negative number here will result in immediate completion after the first value is emitted, as though\n * no `intervalDuration` was passed at all.\n * @param scheduler The scheduler to use to schedule the delay. Defaults to {@link asyncScheduler}.\n */\nexport function timer(startDue: number | Date, intervalDuration: number, scheduler?: SchedulerLike): Observable<number>;\n\n/**\n * @deprecated The signature allowing `undefined` to be passed for `intervalDuration` will be removed in v8. Use the `timer(dueTime, scheduler?)` signature instead.\n */\nexport function timer(dueTime: number | Date, unused: undefined, scheduler?: SchedulerLike): Observable<0>;\n\nexport function timer(\n  dueTime: number | Date = 0,\n  intervalOrScheduler?: number | SchedulerLike,\n  scheduler: SchedulerLike = asyncScheduler\n): Observable<number> {\n  // Since negative intervalDuration is treated as though no\n  // interval was specified at all, we start with a negative number.\n  let intervalDuration = -1;\n\n  if (intervalOrScheduler != null) {\n    // If we have a second argument, and it's a scheduler,\n    // override the scheduler we had defaulted. Otherwise,\n    // it must be an interval.\n    if (isScheduler(intervalOrScheduler)) {\n      scheduler = intervalOrScheduler;\n    } else {\n      // Note that this *could* be negative, in which case\n      // it's like not passing an intervalDuration at all.\n      intervalDuration = intervalOrScheduler;\n    }\n  }\n\n  return new Observable((subscriber) => {\n    // If a valid date is passed, calculate how long to wait before\n    // executing the first value... otherwise, if it's a number just schedule\n    // that many milliseconds (or scheduler-specified unit size) in the future.\n    let due = isValidDate(dueTime) ? +dueTime - scheduler!.now() : dueTime;\n\n    if (due < 0) {\n      // Ensure we don't schedule in the future.\n      due = 0;\n    }\n\n    // The incrementing value we emit.\n    let n = 0;\n\n    // Start the timer.\n    return scheduler.schedule(function () {\n      if (!subscriber.closed) {\n        // Emit the next value and increment.\n        subscriber.next(n++);\n\n        if (0 <= intervalDuration) {\n          // If we have a interval after the initial timer,\n          // reschedule with the period.\n          this.schedule(undefined, intervalDuration);\n        } else {\n          // We didn't have an interval. So just complete.\n          subscriber.complete();\n        }\n      }\n    }, due);\n  });\n}\n","import { Observable } from '../Observable';\nimport { Unsubscribable, ObservableInput, ObservedValueOf } from '../types';\nimport { innerFrom } from './innerFrom';\nimport { EMPTY } from './empty';\n\n/**\n * Creates an Observable that uses a resource which will be disposed at the same time as the Observable.\n *\n * <span class=\"informal\">Use it when you catch yourself cleaning up after an Observable.</span>\n *\n * `using` is a factory operator, which accepts two functions. First function returns a disposable resource.\n * It can be an arbitrary object that implements `unsubscribe` method. Second function will be injected with\n * that object and should return an Observable. That Observable can use resource object during its execution.\n * Both functions passed to `using` will be called every time someone subscribes - neither an Observable nor\n * resource object will be shared in any way between subscriptions.\n *\n * When Observable returned by `using` is subscribed, Observable returned from the second function will be subscribed\n * as well. All its notifications (nexted values, completion and error events) will be emitted unchanged by the output\n * Observable. If however someone unsubscribes from the Observable or source Observable completes or errors by itself,\n * the `unsubscribe` method on resource object will be called. This can be used to do any necessary clean up, which\n * otherwise would have to be handled by hand. Note that complete or error notifications are not emitted when someone\n * cancels subscription to an Observable via `unsubscribe`, so `using` can be used as a hook, allowing you to make\n * sure that all resources which need to exist during an Observable execution will be disposed at appropriate time.\n *\n * @see {@link defer}\n *\n * @param {function(): ISubscription} resourceFactory A function which creates any resource object\n * that implements `unsubscribe` method.\n * @param {function(resource: ISubscription): Observable<T>} observableFactory A function which\n * creates an Observable, that can use injected resource object.\n * @return {Observable<T>} An Observable that behaves the same as Observable returned by `observableFactory`, but\n * which - when completed, errored or unsubscribed - will also call `unsubscribe` on created resource object.\n */\nexport function using<T extends ObservableInput<any>>(\n  resourceFactory: () => Unsubscribable | void,\n  observableFactory: (resource: Unsubscribable | void) => T | void\n): Observable<ObservedValueOf<T>> {\n  return new Observable<ObservedValueOf<T>>((subscriber) => {\n    const resource = resourceFactory();\n    const result = observableFactory(resource);\n    const source = result ? innerFrom(result) : EMPTY;\n    source.subscribe(subscriber);\n    return () => {\n      // NOTE: Optional chaining did not work here.\n      // Related TS Issue: https://github.com/microsoft/TypeScript/issues/40818\n      if (resource) {\n        resource.unsubscribe();\n      }\n    };\n  });\n}\n","import { Observable } from '../Observable';\nimport { ObservableInputTuple } from '../types';\nimport { innerFrom } from './innerFrom';\nimport { argsOrArgArray } from '../util/argsOrArgArray';\nimport { EMPTY } from './empty';\nimport { createOperatorSubscriber } from '../operators/OperatorSubscriber';\nimport { popResultSelector } from '../util/args';\n\nexport function zip<A extends readonly unknown[]>(sources: [...ObservableInputTuple<A>]): Observable<A>;\nexport function zip<A extends readonly unknown[], R>(\n  sources: [...ObservableInputTuple<A>],\n  resultSelector: (...values: A) => R\n): Observable<R>;\nexport function zip<A extends readonly unknown[]>(...sources: [...ObservableInputTuple<A>]): Observable<A>;\nexport function zip<A extends readonly unknown[], R>(\n  ...sourcesAndResultSelector: [...ObservableInputTuple<A>, (...values: A) => R]\n): Observable<R>;\n\n/**\n * Combines multiple Observables to create an Observable whose values are calculated from the values, in order, of each\n * of its input Observables.\n *\n * If the last parameter is a function, this function is used to compute the created value from the input values.\n * Otherwise, an array of the input values is returned.\n *\n * ## Example\n *\n * Combine age and name from different sources\n *\n * ```ts\n * import { of, zip, map } from 'rxjs';\n *\n * const age$ = of(27, 25, 29);\n * const name$ = of('Foo', 'Bar', 'Beer');\n * const isDev$ = of(true, true, false);\n *\n * zip(age$, name$, isDev$).pipe(\n *   map(([age, name, isDev]) => ({ age, name, isDev }))\n * )\n * .subscribe(x => console.log(x));\n *\n * // Outputs\n * // { age: 27, name: 'Foo', isDev: true }\n * // { age: 25, name: 'Bar', isDev: true }\n * // { age: 29, name: 'Beer', isDev: false }\n * ```\n *\n * @param sources\n * @return {Observable<R>}\n */\nexport function zip(...args: unknown[]): Observable<unknown> {\n  const resultSelector = popResultSelector(args);\n\n  const sources = argsOrArgArray(args) as Observable<unknown>[];\n\n  return sources.length\n    ? new Observable<unknown[]>((subscriber) => {\n        // A collection of buffers of values from each source.\n        // Keyed by the same index with which the sources were passed in.\n        let buffers: unknown[][] = sources.map(() => []);\n\n        // An array of flags of whether or not the sources have completed.\n        // This is used to check to see if we should complete the result.\n        // Keyed by the same index with which the sources were passed in.\n        let completed = sources.map(() => false);\n\n        // When everything is done, release the arrays above.\n        subscriber.add(() => {\n          buffers = completed = null!;\n        });\n\n        // Loop over our sources and subscribe to each one. The index `i` is\n        // especially important here, because we use it in closures below to\n        // access the related buffers and completion properties\n        for (let sourceIndex = 0; !subscriber.closed && sourceIndex < sources.length; sourceIndex++) {\n          innerFrom(sources[sourceIndex]).subscribe(\n            createOperatorSubscriber(\n              subscriber,\n              (value) => {\n                buffers[sourceIndex].push(value);\n                // if every buffer has at least one value in it, then we\n                // can shift out the oldest value from each buffer and emit\n                // them as an array.\n                if (buffers.every((buffer) => buffer.length)) {\n                  const result: any = buffers.map((buffer) => buffer.shift()!);\n                  // Emit the array. If theres' a result selector, use that.\n                  subscriber.next(resultSelector ? resultSelector(...result) : result);\n                  // If any one of the sources is both complete and has an empty buffer\n                  // then we complete the result. This is because we cannot possibly have\n                  // any more values to zip together.\n                  if (buffers.some((buffer, i) => !buffer.length && completed[i])) {\n                    subscriber.complete();\n                  }\n                }\n              },\n              () => {\n                // This source completed. Mark it as complete so we can check it later\n                // if we have to.\n                completed[sourceIndex] = true;\n                // But, if this complete source has nothing in its buffer, then we\n                // can complete the result, because we can't possibly have any more\n                // values from this to zip together with the other values.\n                !buffers[sourceIndex].length && subscriber.complete();\n              }\n            )\n          );\n        }\n\n        // When everything is done, release the arrays above.\n        return () => {\n          buffers = completed = null!;\n        };\n      })\n    : EMPTY;\n}\n","import { Subscriber } from '../Subscriber';\n\n/**\n * Creates an instance of an `OperatorSubscriber`.\n * @param destination The downstream subscriber.\n * @param onNext Handles next values, only called if this subscriber is not stopped or closed. Any\n * error that occurs in this function is caught and sent to the `error` method of this subscriber.\n * @param onError Handles errors from the subscription, any errors that occur in this handler are caught\n * and send to the `destination` error handler.\n * @param onComplete Handles completion notification from the subscription. Any errors that occur in\n * this handler are sent to the `destination` error handler.\n * @param onFinalize Additional teardown logic here. This will only be called on teardown if the\n * subscriber itself is not already closed. This is called after all other teardown logic is executed.\n */\nexport function createOperatorSubscriber<T>(\n  destination: Subscriber<any>,\n  onNext?: (value: T) => void,\n  onComplete?: () => void,\n  onError?: (err: any) => void,\n  onFinalize?: () => void\n): Subscriber<T> {\n  return new OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize);\n}\n\n/**\n * A generic helper for allowing operators to be created with a Subscriber and\n * use closures to capture necessary state from the operator function itself.\n */\nexport class OperatorSubscriber<T> extends Subscriber<T> {\n  /**\n   * Creates an instance of an `OperatorSubscriber`.\n   * @param destination The downstream subscriber.\n   * @param onNext Handles next values, only called if this subscriber is not stopped or closed. Any\n   * error that occurs in this function is caught and sent to the `error` method of this subscriber.\n   * @param onError Handles errors from the subscription, any errors that occur in this handler are caught\n   * and send to the `destination` error handler.\n   * @param onComplete Handles completion notification from the subscription. Any errors that occur in\n   * this handler are sent to the `destination` error handler.\n   * @param onFinalize Additional finalization logic here. This will only be called on finalization if the\n   * subscriber itself is not already closed. This is called after all other finalization logic is executed.\n   * @param shouldUnsubscribe An optional check to see if an unsubscribe call should truly unsubscribe.\n   * NOTE: This currently **ONLY** exists to support the strange behavior of {@link groupBy}, where unsubscription\n   * to the resulting observable does not actually disconnect from the source if there are active subscriptions\n   * to any grouped observable. (DO NOT EXPOSE OR USE EXTERNALLY!!!)\n   */\n  constructor(\n    destination: Subscriber<any>,\n    onNext?: (value: T) => void,\n    onComplete?: () => void,\n    onError?: (err: any) => void,\n    private onFinalize?: () => void,\n    private shouldUnsubscribe?: () => boolean\n  ) {\n    // It's important - for performance reasons - that all of this class's\n    // members are initialized and that they are always initialized in the same\n    // order. This will ensure that all OperatorSubscriber instances have the\n    // same hidden class in V8. This, in turn, will help keep the number of\n    // hidden classes involved in property accesses within the base class as\n    // low as possible. If the number of hidden classes involved exceeds four,\n    // the property accesses will become megamorphic and performance penalties\n    // will be incurred - i.e. inline caches won't be used.\n    //\n    // The reasons for ensuring all instances have the same hidden class are\n    // further discussed in this blog post from Benedikt Meurer:\n    // https://benediktmeurer.de/2018/03/23/impact-of-polymorphism-on-component-based-frameworks-like-react/\n    super(destination);\n    this._next = onNext\n      ? function (this: OperatorSubscriber<T>, value: T) {\n          try {\n            onNext(value);\n          } catch (err) {\n            destination.error(err);\n          }\n        }\n      : super._next;\n    this._error = onError\n      ? function (this: OperatorSubscriber<T>, err: any) {\n          try {\n            onError(err);\n          } catch (err) {\n            // Send any errors that occur down stream.\n            destination.error(err);\n          } finally {\n            // Ensure finalization.\n            this.unsubscribe();\n          }\n        }\n      : super._error;\n    this._complete = onComplete\n      ? function (this: OperatorSubscriber<T>) {\n          try {\n            onComplete();\n          } catch (err) {\n            // Send any errors that occur down stream.\n            destination.error(err);\n          } finally {\n            // Ensure finalization.\n            this.unsubscribe();\n          }\n        }\n      : super._complete;\n  }\n\n  unsubscribe() {\n    if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {\n      const { closed } = this;\n      super.unsubscribe();\n      // Execute additional teardown if we have any and we didn't already do so.\n      !closed && this.onFinalize?.();\n    }\n  }\n}\n","import { Subscriber } from '../Subscriber';\nimport { MonoTypeOperatorFunction, ObservableInput } from '../types';\n\nimport { operate } from '../util/lift';\nimport { innerFrom } from '../observable/innerFrom';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\n/**\n * Ignores source values for a duration determined by another Observable, then\n * emits the most recent value from the source Observable, then repeats this\n * process.\n *\n * <span class=\"informal\">It's like {@link auditTime}, but the silencing\n * duration is determined by a second Observable.</span>\n *\n * ![](audit.svg)\n *\n * `audit` is similar to `throttle`, but emits the last value from the silenced\n * time window, instead of the first value. `audit` emits the most recent value\n * from the source Observable on the output Observable as soon as its internal\n * timer becomes disabled, and ignores source values while the timer is enabled.\n * Initially, the timer is disabled. As soon as the first source value arrives,\n * the timer is enabled by calling the `durationSelector` function with the\n * source value, which returns the \"duration\" Observable. When the duration\n * Observable emits a value, the timer is disabled, then the most\n * recent source value is emitted on the output Observable, and this process\n * repeats for the next source value.\n *\n * ## Example\n *\n * Emit clicks at a rate of at most one click per second\n *\n * ```ts\n * import { fromEvent, audit, interval } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(audit(ev => interval(1000)));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link auditTime}\n * @see {@link debounce}\n * @see {@link delayWhen}\n * @see {@link sample}\n * @see {@link throttle}\n *\n * @param durationSelector A function\n * that receives a value from the source Observable, for computing the silencing\n * duration, returned as an Observable or a Promise.\n * @return A function that returns an Observable that performs rate-limiting of\n * emissions from the source Observable.\n */\nexport function audit<T>(durationSelector: (value: T) => ObservableInput<any>): MonoTypeOperatorFunction<T> {\n  return operate((source, subscriber) => {\n    let hasValue = false;\n    let lastValue: T | null = null;\n    let durationSubscriber: Subscriber<any> | null = null;\n    let isComplete = false;\n\n    const endDuration = () => {\n      durationSubscriber?.unsubscribe();\n      durationSubscriber = null;\n      if (hasValue) {\n        hasValue = false;\n        const value = lastValue!;\n        lastValue = null;\n        subscriber.next(value);\n      }\n      isComplete && subscriber.complete();\n    };\n\n    const cleanupDuration = () => {\n      durationSubscriber = null;\n      isComplete && subscriber.complete();\n    };\n\n    source.subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        (value) => {\n          hasValue = true;\n          lastValue = value;\n          if (!durationSubscriber) {\n            innerFrom(durationSelector(value)).subscribe(\n              (durationSubscriber = createOperatorSubscriber(subscriber, endDuration, cleanupDuration))\n            );\n          }\n        },\n        () => {\n          isComplete = true;\n          (!hasValue || !durationSubscriber || durationSubscriber.closed) && subscriber.complete();\n        }\n      )\n    );\n  });\n}\n","import { asyncScheduler } from '../scheduler/async';\nimport { audit } from './audit';\nimport { timer } from '../observable/timer';\nimport { MonoTypeOperatorFunction, SchedulerLike } from '../types';\n\n/**\n * Ignores source values for `duration` milliseconds, then emits the most recent\n * value from the source Observable, then repeats this process.\n *\n * <span class=\"informal\">When it sees a source value, it ignores that plus\n * the next ones for `duration` milliseconds, and then it emits the most recent\n * value from the source.</span>\n *\n * ![](auditTime.png)\n *\n * `auditTime` is similar to `throttleTime`, but emits the last value from the\n * silenced time window, instead of the first value. `auditTime` emits the most\n * recent value from the source Observable on the output Observable as soon as\n * its internal timer becomes disabled, and ignores source values while the\n * timer is enabled. Initially, the timer is disabled. As soon as the first\n * source value arrives, the timer is enabled. After `duration` milliseconds (or\n * the time unit determined internally by the optional `scheduler`) has passed,\n * the timer is disabled, then the most recent source value is emitted on the\n * output Observable, and this process repeats for the next source value.\n * Optionally takes a {@link SchedulerLike} for managing timers.\n *\n * ## Example\n *\n * Emit clicks at a rate of at most one click per second\n *\n * ```ts\n * import { fromEvent, auditTime } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(auditTime(1000));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link audit}\n * @see {@link debounceTime}\n * @see {@link delay}\n * @see {@link sampleTime}\n * @see {@link throttleTime}\n *\n * @param {number} duration Time to wait before emitting the most recent source\n * value, measured in milliseconds or the time unit determined internally\n * by the optional `scheduler`.\n * @param {SchedulerLike} [scheduler=async] The {@link SchedulerLike} to use for\n * managing the timers that handle the rate-limiting behavior.\n * @return A function that returns an Observable that performs rate-limiting of\n * emissions from the source Observable.\n */\nexport function auditTime<T>(duration: number, scheduler: SchedulerLike = asyncScheduler): MonoTypeOperatorFunction<T> {\n  return audit(() => timer(duration, scheduler));\n}\n","import { OperatorFunction, ObservableInput } from '../types';\nimport { operate } from '../util/lift';\nimport { noop } from '../util/noop';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nimport { innerFrom } from '../observable/innerFrom';\n\n/**\n * Buffers the source Observable values until `closingNotifier` emits.\n *\n * <span class=\"informal\">Collects values from the past as an array, and emits\n * that array only when another Observable emits.</span>\n *\n * ![](buffer.png)\n *\n * Buffers the incoming Observable values until the given `closingNotifier`\n * `ObservableInput` (that internally gets converted to an Observable)\n * emits a value, at which point it emits the buffer on the output\n * Observable and starts a new buffer internally, awaiting the next time\n * `closingNotifier` emits.\n *\n * ## Example\n *\n * On every click, emit array of most recent interval events\n *\n * ```ts\n * import { fromEvent, interval, buffer } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const intervalEvents = interval(1000);\n * const buffered = intervalEvents.pipe(buffer(clicks));\n * buffered.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link bufferCount}\n * @see {@link bufferTime}\n * @see {@link bufferToggle}\n * @see {@link bufferWhen}\n * @see {@link window}\n *\n * @param closingNotifier An `ObservableInput` that signals the\n * buffer to be emitted on the output Observable.\n * @return A function that returns an Observable of buffers, which are arrays\n * of values.\n */\nexport function buffer<T>(closingNotifier: ObservableInput<any>): OperatorFunction<T, T[]> {\n  return operate((source, subscriber) => {\n    // The current buffered values.\n    let currentBuffer: T[] = [];\n\n    // Subscribe to our source.\n    source.subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        (value) => currentBuffer.push(value),\n        () => {\n          subscriber.next(currentBuffer);\n          subscriber.complete();\n        }\n      )\n    );\n\n    // Subscribe to the closing notifier.\n    innerFrom(closingNotifier).subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        () => {\n          // Start a new buffer and emit the previous one.\n          const b = currentBuffer;\n          currentBuffer = [];\n          subscriber.next(b);\n        },\n        noop\n      )\n    );\n\n    return () => {\n      // Ensure buffered values are released on finalization.\n      currentBuffer = null!;\n    };\n  });\n}\n","import { OperatorFunction } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nimport { arrRemove } from '../util/arrRemove';\n\n/**\n * Buffers the source Observable values until the size hits the maximum\n * `bufferSize` given.\n *\n * <span class=\"informal\">Collects values from the past as an array, and emits\n * that array only when its size reaches `bufferSize`.</span>\n *\n * ![](bufferCount.png)\n *\n * Buffers a number of values from the source Observable by `bufferSize` then\n * emits the buffer and clears it, and starts a new buffer each\n * `startBufferEvery` values. If `startBufferEvery` is not provided or is\n * `null`, then new buffers are started immediately at the start of the source\n * and when each buffer closes and is emitted.\n *\n * ## Examples\n *\n * Emit the last two click events as an array\n *\n * ```ts\n * import { fromEvent, bufferCount } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const buffered = clicks.pipe(bufferCount(2));\n * buffered.subscribe(x => console.log(x));\n * ```\n *\n * On every click, emit the last two click events as an array\n *\n * ```ts\n * import { fromEvent, bufferCount } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const buffered = clicks.pipe(bufferCount(2, 1));\n * buffered.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link buffer}\n * @see {@link bufferTime}\n * @see {@link bufferToggle}\n * @see {@link bufferWhen}\n * @see {@link pairwise}\n * @see {@link windowCount}\n *\n * @param {number} bufferSize The maximum size of the buffer emitted.\n * @param {number} [startBufferEvery] Interval at which to start a new buffer.\n * For example if `startBufferEvery` is `2`, then a new buffer will be started\n * on every other value from the source. A new buffer is started at the\n * beginning of the source by default.\n * @return A function that returns an Observable of arrays of buffered values.\n */\nexport function bufferCount<T>(bufferSize: number, startBufferEvery: number | null = null): OperatorFunction<T, T[]> {\n  // If no `startBufferEvery` value was supplied, then we're\n  // opening and closing on the bufferSize itself.\n  startBufferEvery = startBufferEvery ?? bufferSize;\n\n  return operate((source, subscriber) => {\n    let buffers: T[][] = [];\n    let count = 0;\n\n    source.subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        (value) => {\n          let toEmit: T[][] | null = null;\n\n          // Check to see if we need to start a buffer.\n          // This will start one at the first value, and then\n          // a new one every N after that.\n          if (count++ % startBufferEvery! === 0) {\n            buffers.push([]);\n          }\n\n          // Push our value into our active buffers.\n          for (const buffer of buffers) {\n            buffer.push(value);\n            // Check to see if we're over the bufferSize\n            // if we are, record it so we can emit it later.\n            // If we emitted it now and removed it, it would\n            // mutate the `buffers` array while we're looping\n            // over it.\n            if (bufferSize <= buffer.length) {\n              toEmit = toEmit ?? [];\n              toEmit.push(buffer);\n            }\n          }\n\n          if (toEmit) {\n            // We have found some buffers that are over the\n            // `bufferSize`. Emit them, and remove them from our\n            // buffers list.\n            for (const buffer of toEmit) {\n              arrRemove(buffers, buffer);\n              subscriber.next(buffer);\n            }\n          }\n        },\n        () => {\n          // When the source completes, emit all of our\n          // active buffers.\n          for (const buffer of buffers) {\n            subscriber.next(buffer);\n          }\n          subscriber.complete();\n        },\n        // Pass all errors through to consumer.\n        undefined,\n        () => {\n          // Clean up our memory when we finalize\n          buffers = null!;\n        }\n      )\n    );\n  });\n}\n","import { Subscription } from '../Subscription';\nimport { OperatorFunction, SchedulerLike } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nimport { arrRemove } from '../util/arrRemove';\nimport { asyncScheduler } from '../scheduler/async';\nimport { popScheduler } from '../util/args';\nimport { executeSchedule } from '../util/executeSchedule';\n\n/* tslint:disable:max-line-length */\nexport function bufferTime<T>(bufferTimeSpan: number, scheduler?: SchedulerLike): OperatorFunction<T, T[]>;\nexport function bufferTime<T>(\n  bufferTimeSpan: number,\n  bufferCreationInterval: number | null | undefined,\n  scheduler?: SchedulerLike\n): OperatorFunction<T, T[]>;\nexport function bufferTime<T>(\n  bufferTimeSpan: number,\n  bufferCreationInterval: number | null | undefined,\n  maxBufferSize: number,\n  scheduler?: SchedulerLike\n): OperatorFunction<T, T[]>;\n/* tslint:enable:max-line-length */\n\n/**\n * Buffers the source Observable values for a specific time period.\n *\n * <span class=\"informal\">Collects values from the past as an array, and emits\n * those arrays periodically in time.</span>\n *\n * ![](bufferTime.png)\n *\n * Buffers values from the source for a specific time duration `bufferTimeSpan`.\n * Unless the optional argument `bufferCreationInterval` is given, it emits and\n * resets the buffer every `bufferTimeSpan` milliseconds. If\n * `bufferCreationInterval` is given, this operator opens the buffer every\n * `bufferCreationInterval` milliseconds and closes (emits and resets) the\n * buffer every `bufferTimeSpan` milliseconds. When the optional argument\n * `maxBufferSize` is specified, the buffer will be closed either after\n * `bufferTimeSpan` milliseconds or when it contains `maxBufferSize` elements.\n *\n * ## Examples\n *\n * Every second, emit an array of the recent click events\n *\n * ```ts\n * import { fromEvent, bufferTime } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const buffered = clicks.pipe(bufferTime(1000));\n * buffered.subscribe(x => console.log(x));\n * ```\n *\n * Every 5 seconds, emit the click events from the next 2 seconds\n *\n * ```ts\n * import { fromEvent, bufferTime } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const buffered = clicks.pipe(bufferTime(2000, 5000));\n * buffered.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link buffer}\n * @see {@link bufferCount}\n * @see {@link bufferToggle}\n * @see {@link bufferWhen}\n * @see {@link windowTime}\n *\n * @param {number} bufferTimeSpan The amount of time to fill each buffer array.\n * @param {number} [bufferCreationInterval] The interval at which to start new\n * buffers.\n * @param {number} [maxBufferSize] The maximum buffer size.\n * @param {SchedulerLike} [scheduler=async] The scheduler on which to schedule the\n * intervals that determine buffer boundaries.\n * @return A function that returns an Observable of arrays of buffered values.\n */\nexport function bufferTime<T>(bufferTimeSpan: number, ...otherArgs: any[]): OperatorFunction<T, T[]> {\n  const scheduler = popScheduler(otherArgs) ?? asyncScheduler;\n  const bufferCreationInterval = (otherArgs[0] as number) ?? null;\n  const maxBufferSize = (otherArgs[1] as number) || Infinity;\n\n  return operate((source, subscriber) => {\n    // The active buffers, their related subscriptions, and removal functions.\n    let bufferRecords: { buffer: T[]; subs: Subscription }[] | null = [];\n    // If true, it means that every time we emit a buffer, we want to start a new buffer\n    // this is only really used for when *just* the buffer time span is passed.\n    let restartOnEmit = false;\n\n    /**\n     * Does the work of emitting the buffer from the record, ensuring that the\n     * record is removed before the emission so reentrant code (from some custom scheduling, perhaps)\n     * does not alter the buffer. Also checks to see if a new buffer needs to be started\n     * after the emit.\n     */\n    const emit = (record: { buffer: T[]; subs: Subscription }) => {\n      const { buffer, subs } = record;\n      subs.unsubscribe();\n      arrRemove(bufferRecords, record);\n      subscriber.next(buffer);\n      restartOnEmit && startBuffer();\n    };\n\n    /**\n     * Called every time we start a new buffer. This does\n     * the work of scheduling a job at the requested bufferTimeSpan\n     * that will emit the buffer (if it's not unsubscribed before then).\n     */\n    const startBuffer = () => {\n      if (bufferRecords) {\n        const subs = new Subscription();\n        subscriber.add(subs);\n        const buffer: T[] = [];\n        const record = {\n          buffer,\n          subs,\n        };\n        bufferRecords.push(record);\n        executeSchedule(subs, scheduler, () => emit(record), bufferTimeSpan);\n      }\n    };\n\n    if (bufferCreationInterval !== null && bufferCreationInterval >= 0) {\n      // The user passed both a bufferTimeSpan (required), and a creation interval\n      // That means we need to start new buffers on the interval, and those buffers need\n      // to wait the required time span before emitting.\n      executeSchedule(subscriber, scheduler, startBuffer, bufferCreationInterval, true);\n    } else {\n      restartOnEmit = true;\n    }\n\n    startBuffer();\n\n    const bufferTimeSubscriber = createOperatorSubscriber(\n      subscriber,\n      (value: T) => {\n        // Copy the records, so if we need to remove one we\n        // don't mutate the array. It's hard, but not impossible to\n        // set up a buffer time that could mutate the array and\n        // cause issues here.\n        const recordsCopy = bufferRecords!.slice();\n        for (const record of recordsCopy) {\n          // Loop over all buffers and\n          const { buffer } = record;\n          buffer.push(value);\n          // If the buffer is over the max size, we need to emit it.\n          maxBufferSize <= buffer.length && emit(record);\n        }\n      },\n      () => {\n        // The source completed, emit all of the active\n        // buffers we have before we complete.\n        while (bufferRecords?.length) {\n          subscriber.next(bufferRecords.shift()!.buffer);\n        }\n        bufferTimeSubscriber?.unsubscribe();\n        subscriber.complete();\n        subscriber.unsubscribe();\n      },\n      // Pass all errors through to consumer.\n      undefined,\n      // Clean up\n      () => (bufferRecords = null)\n    );\n\n    source.subscribe(bufferTimeSubscriber);\n  });\n}\n","import { Subscription } from '../Subscription';\nimport { OperatorFunction, ObservableInput } from '../types';\nimport { operate } from '../util/lift';\nimport { innerFrom } from '../observable/innerFrom';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nimport { noop } from '../util/noop';\nimport { arrRemove } from '../util/arrRemove';\n\n/**\n * Buffers the source Observable values starting from an emission from\n * `openings` and ending when the output of `closingSelector` emits.\n *\n * <span class=\"informal\">Collects values from the past as an array. Starts\n * collecting only when `opening` emits, and calls the `closingSelector`\n * function to get an Observable that tells when to close the buffer.</span>\n *\n * ![](bufferToggle.png)\n *\n * Buffers values from the source by opening the buffer via signals from an\n * Observable provided to `openings`, and closing and sending the buffers when\n * a Subscribable or Promise returned by the `closingSelector` function emits.\n *\n * ## Example\n *\n * Every other second, emit the click events from the next 500ms\n *\n * ```ts\n * import { fromEvent, interval, bufferToggle, EMPTY } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const openings = interval(1000);\n * const buffered = clicks.pipe(bufferToggle(openings, i =>\n *   i % 2 ? interval(500) : EMPTY\n * ));\n * buffered.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link buffer}\n * @see {@link bufferCount}\n * @see {@link bufferTime}\n * @see {@link bufferWhen}\n * @see {@link windowToggle}\n *\n * @param openings A Subscribable or Promise of notifications to start new\n * buffers.\n * @param closingSelector A function that takes\n * the value emitted by the `openings` observable and returns a Subscribable or Promise,\n * which, when it emits, signals that the associated buffer should be emitted\n * and cleared.\n * @return A function that returns an Observable of arrays of buffered values.\n */\nexport function bufferToggle<T, O>(\n  openings: ObservableInput<O>,\n  closingSelector: (value: O) => ObservableInput<any>\n): OperatorFunction<T, T[]> {\n  return operate((source, subscriber) => {\n    const buffers: T[][] = [];\n\n    // Subscribe to the openings notifier first\n    innerFrom(openings).subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        (openValue) => {\n          const buffer: T[] = [];\n          buffers.push(buffer);\n          // We use this composite subscription, so that\n          // when the closing notifier emits, we can tear it down.\n          const closingSubscription = new Subscription();\n\n          const emitBuffer = () => {\n            arrRemove(buffers, buffer);\n            subscriber.next(buffer);\n            closingSubscription.unsubscribe();\n          };\n\n          // The line below will add the subscription to the parent subscriber *and* the closing subscription.\n          closingSubscription.add(innerFrom(closingSelector(openValue)).subscribe(createOperatorSubscriber(subscriber, emitBuffer, noop)));\n        },\n        noop\n      )\n    );\n\n    source.subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        (value) => {\n          // Value from our source. Add it to all pending buffers.\n          for (const buffer of buffers) {\n            buffer.push(value);\n          }\n        },\n        () => {\n          // Source complete. Emit all pending buffers.\n          while (buffers.length > 0) {\n            subscriber.next(buffers.shift()!);\n          }\n          subscriber.complete();\n        }\n      )\n    );\n  });\n}\n","import { Subscriber } from '../Subscriber';\nimport { ObservableInput, OperatorFunction } from '../types';\nimport { operate } from '../util/lift';\nimport { noop } from '../util/noop';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nimport { innerFrom } from '../observable/innerFrom';\n\n/**\n * Buffers the source Observable values, using a factory function of closing\n * Observables to determine when to close, emit, and reset the buffer.\n *\n * <span class=\"informal\">Collects values from the past as an array. When it\n * starts collecting values, it calls a function that returns an Observable that\n * tells when to close the buffer and restart collecting.</span>\n *\n * ![](bufferWhen.svg)\n *\n * Opens a buffer immediately, then closes the buffer when the observable\n * returned by calling `closingSelector` function emits a value. When it closes\n * the buffer, it immediately opens a new buffer and repeats the process.\n *\n * ## Example\n *\n * Emit an array of the last clicks every [1-5] random seconds\n *\n * ```ts\n * import { fromEvent, bufferWhen, interval } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const buffered = clicks.pipe(\n *   bufferWhen(() => interval(1000 + Math.random() * 4000))\n * );\n * buffered.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link buffer}\n * @see {@link bufferCount}\n * @see {@link bufferTime}\n * @see {@link bufferToggle}\n * @see {@link windowWhen}\n *\n * @param {function(): Observable} closingSelector A function that takes no\n * arguments and returns an Observable that signals buffer closure.\n * @return A function that returns an Observable of arrays of buffered values.\n */\nexport function bufferWhen<T>(closingSelector: () => ObservableInput<any>): OperatorFunction<T, T[]> {\n  return operate((source, subscriber) => {\n    // The buffer we keep and emit.\n    let buffer: T[] | null = null;\n    // A reference to the subscriber used to subscribe to\n    // the closing notifier. We need to hold this so we can\n    // end the subscription after the first notification.\n    let closingSubscriber: Subscriber<T> | null = null;\n\n    // Ends the previous closing notifier subscription, so it\n    // terminates after the first emission, then emits\n    // the current buffer  if there is one, starts a new buffer, and starts a\n    // new closing notifier.\n    const openBuffer = () => {\n      // Make sure to finalize the closing subscription, we only cared\n      // about one notification.\n      closingSubscriber?.unsubscribe();\n      // emit the buffer if we have one, and start a new buffer.\n      const b = buffer;\n      buffer = [];\n      b && subscriber.next(b);\n\n      // Get a new closing notifier and subscribe to it.\n      innerFrom(closingSelector()).subscribe((closingSubscriber = createOperatorSubscriber(subscriber, openBuffer, noop)));\n    };\n\n    // Start the first buffer.\n    openBuffer();\n\n    // Subscribe to our source.\n    source.subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        // Add every new value to the current buffer.\n        (value) => buffer?.push(value),\n        // When we complete, emit the buffer if we have one,\n        // then complete the result.\n        () => {\n          buffer && subscriber.next(buffer);\n          subscriber.complete();\n        },\n        // Pass all errors through to consumer.\n        undefined,\n        // Release memory on finalization\n        () => (buffer = closingSubscriber = null!)\n      )\n    );\n  });\n}\n","import { Observable } from '../Observable';\n\nimport { ObservableInput, OperatorFunction, ObservedValueOf } from '../types';\nimport { Subscription } from '../Subscription';\nimport { innerFrom } from '../observable/innerFrom';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nimport { operate } from '../util/lift';\n\n/* tslint:disable:max-line-length */\nexport function catchError<T, O extends ObservableInput<any>>(\n  selector: (err: any, caught: Observable<T>) => O\n): OperatorFunction<T, T | ObservedValueOf<O>>;\n/* tslint:enable:max-line-length */\n\n/**\n * Catches errors on the observable to be handled by returning a new observable or throwing an error.\n *\n * <span class=\"informal\">\n * It only listens to the error channel and ignores notifications.\n * Handles errors from the source observable, and maps them to a new observable.\n * The error may also be rethrown, or a new error can be thrown to emit an error from the result.\n * </span>\n *\n * ![](catch.png)\n *\n * This operator handles errors, but forwards along all other events to the resulting observable.\n * If the source observable terminates with an error, it will map that error to a new observable,\n * subscribe to it, and forward all of its events to the resulting observable.\n *\n * ## Examples\n *\n * Continue with a different Observable when there's an error\n *\n * ```ts\n * import { of, map, catchError } from 'rxjs';\n *\n * of(1, 2, 3, 4, 5)\n *   .pipe(\n *     map(n => {\n *       if (n === 4) {\n *         throw 'four!';\n *       }\n *       return n;\n *     }),\n *     catchError(err => of('I', 'II', 'III', 'IV', 'V'))\n *   )\n *   .subscribe(x => console.log(x));\n *   // 1, 2, 3, I, II, III, IV, V\n * ```\n *\n * Retry the caught source Observable again in case of error, similar to `retry()` operator\n *\n * ```ts\n * import { of, map, catchError, take } from 'rxjs';\n *\n * of(1, 2, 3, 4, 5)\n *   .pipe(\n *     map(n => {\n *       if (n === 4) {\n *         throw 'four!';\n *       }\n *       return n;\n *     }),\n *     catchError((err, caught) => caught),\n *     take(30)\n *   )\n *   .subscribe(x => console.log(x));\n *   // 1, 2, 3, 1, 2, 3, ...\n * ```\n *\n * Throw a new error when the source Observable throws an error\n *\n * ```ts\n * import { of, map, catchError } from 'rxjs';\n *\n * of(1, 2, 3, 4, 5)\n *   .pipe(\n *     map(n => {\n *       if (n === 4) {\n *         throw 'four!';\n *       }\n *       return n;\n *     }),\n *     catchError(err => {\n *       throw 'error in source. Details: ' + err;\n *     })\n *   )\n *   .subscribe({\n *     next: x => console.log(x),\n *     error: err => console.log(err)\n *   });\n *   // 1, 2, 3, error in source. Details: four!\n * ```\n *\n * @see {@link onErrorResumeNext}\n * @see {@link repeat}\n * @see {@link repeatWhen}\n * @see {@link retry }\n * @see {@link retryWhen}\n *\n * @param {function} selector a function that takes as arguments `err`, which is the error, and `caught`, which\n * is the source observable, in case you'd like to \"retry\" that observable by returning it again. Whatever observable\n * is returned by the `selector` will be used to continue the observable chain.\n * @return A function that returns an Observable that originates from either\n * the source or the Observable returned by the `selector` function.\n */\nexport function catchError<T, O extends ObservableInput<any>>(\n  selector: (err: any, caught: Observable<T>) => O\n): OperatorFunction<T, T | ObservedValueOf<O>> {\n  return operate((source, subscriber) => {\n    let innerSub: Subscription | null = null;\n    let syncUnsub = false;\n    let handledResult: Observable<ObservedValueOf<O>>;\n\n    innerSub = source.subscribe(\n      createOperatorSubscriber(subscriber, undefined, undefined, (err) => {\n        handledResult = innerFrom(selector(err, catchError(selector)(source)));\n        if (innerSub) {\n          innerSub.unsubscribe();\n          innerSub = null;\n          handledResult.subscribe(subscriber);\n        } else {\n          // We don't have an innerSub yet, that means the error was synchronous\n          // because the subscribe call hasn't returned yet.\n          syncUnsub = true;\n        }\n      })\n    );\n\n    if (syncUnsub) {\n      // We have a synchronous error, we need to make sure to\n      // finalize right away. This ensures that callbacks in the `finalize` operator are called\n      // at the right time, and that finalization occurs at the expected\n      // time between the source error and the subscription to the\n      // next observable.\n      innerSub.unsubscribe();\n      innerSub = null;\n      handledResult!.subscribe(subscriber);\n    }\n  });\n}\n","import { combineLatestAll } from './combineLatestAll';\n\n/**\n * @deprecated Renamed to {@link combineLatestAll}. Will be removed in v8.\n */\nexport const combineAll = combineLatestAll;\n","import { combineLatestInit } from '../observable/combineLatest';\nimport { ObservableInput, ObservableInputTuple, OperatorFunction } from '../types';\nimport { operate } from '../util/lift';\nimport { argsOrArgArray } from '../util/argsOrArgArray';\nimport { mapOneOrManyArgs } from '../util/mapOneOrManyArgs';\nimport { pipe } from '../util/pipe';\nimport { popResultSelector } from '../util/args';\n\n/** @deprecated Replaced with {@link combineLatestWith}. Will be removed in v8. */\nexport function combineLatest<T, A extends readonly unknown[], R>(\n  sources: [...ObservableInputTuple<A>],\n  project: (...values: [T, ...A]) => R\n): OperatorFunction<T, R>;\n/** @deprecated Replaced with {@link combineLatestWith}. Will be removed in v8. */\nexport function combineLatest<T, A extends readonly unknown[], R>(sources: [...ObservableInputTuple<A>]): OperatorFunction<T, [T, ...A]>;\n\n/** @deprecated Replaced with {@link combineLatestWith}. Will be removed in v8. */\nexport function combineLatest<T, A extends readonly unknown[], R>(\n  ...sourcesAndProject: [...ObservableInputTuple<A>, (...values: [T, ...A]) => R]\n): OperatorFunction<T, R>;\n/** @deprecated Replaced with {@link combineLatestWith}. Will be removed in v8. */\nexport function combineLatest<T, A extends readonly unknown[], R>(...sources: [...ObservableInputTuple<A>]): OperatorFunction<T, [T, ...A]>;\n\n/**\n * @deprecated Replaced with {@link combineLatestWith}. Will be removed in v8.\n */\nexport function combineLatest<T, R>(...args: (ObservableInput<any> | ((...values: any[]) => R))[]): OperatorFunction<T, unknown> {\n  const resultSelector = popResultSelector(args);\n  return resultSelector\n    ? pipe(combineLatest(...(args as Array<ObservableInput<any>>)), mapOneOrManyArgs(resultSelector))\n    : operate((source, subscriber) => {\n        combineLatestInit([source, ...argsOrArgArray(args)])(subscriber);\n      });\n}\n","import { combineLatest } from '../observable/combineLatest';\nimport { OperatorFunction, ObservableInput } from '../types';\nimport { joinAllInternals } from './joinAllInternals';\n\nexport function combineLatestAll<T>(): OperatorFunction<ObservableInput<T>, T[]>;\nexport function combineLatestAll<T>(): OperatorFunction<any, T[]>;\nexport function combineLatestAll<T, R>(project: (...values: T[]) => R): OperatorFunction<ObservableInput<T>, R>;\nexport function combineLatestAll<R>(project: (...values: Array<any>) => R): OperatorFunction<any, R>;\n\n/**\n * Flattens an Observable-of-Observables by applying {@link combineLatest} when the Observable-of-Observables completes.\n *\n * `combineLatestAll` takes an Observable of Observables, and collects all Observables from it. Once the outer Observable completes,\n * it subscribes to all collected Observables and combines their values using the {@link combineLatest} strategy, such that:\n *\n * * Every time an inner Observable emits, the output Observable emits\n * * When the returned observable emits, it emits all of the latest values by:\n *    * If a `project` function is provided, it is called with each recent value from each inner Observable in whatever order they\n *      arrived, and the result of the `project` function is what is emitted by the output Observable.\n *    * If there is no `project` function, an array of all the most recent values is emitted by the output Observable.\n *\n * ## Example\n *\n * Map two click events to a finite interval Observable, then apply `combineLatestAll`\n *\n * ```ts\n * import { fromEvent, map, interval, take, combineLatestAll } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const higherOrder = clicks.pipe(\n *   map(() => interval(Math.random() * 2000).pipe(take(3))),\n *   take(2)\n * );\n * const result = higherOrder.pipe(combineLatestAll());\n *\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link combineLatest}\n * @see {@link combineLatestWith}\n * @see {@link mergeAll}\n *\n * @param project optional function to map the most recent values from each inner Observable into a new result.\n * Takes each of the most recent values from each collected inner Observable as arguments, in order.\n * @return A function that returns an Observable that flattens Observables\n * emitted by the source Observable.\n */\nexport function combineLatestAll<R>(project?: (...values: Array<any>) => R) {\n  return joinAllInternals(combineLatest, project);\n}\n","import { ObservableInputTuple, OperatorFunction, Cons } from '../types';\nimport { combineLatest } from './combineLatest';\n\n/**\n * Create an observable that combines the latest values from all passed observables and the source\n * into arrays and emits them.\n *\n * Returns an observable, that when subscribed to, will subscribe to the source observable and all\n * sources provided as arguments. Once all sources emit at least one value, all of the latest values\n * will be emitted as an array. After that, every time any source emits a value, all of the latest values\n * will be emitted as an array.\n *\n * This is a useful operator for eagerly calculating values based off of changed inputs.\n *\n * ## Example\n *\n * Simple concatenation of values from two inputs\n *\n * ```ts\n * import { fromEvent, combineLatestWith, map } from 'rxjs';\n *\n * // Setup: Add two inputs to the page\n * const input1 = document.createElement('input');\n * document.body.appendChild(input1);\n * const input2 = document.createElement('input');\n * document.body.appendChild(input2);\n *\n * // Get streams of changes\n * const input1Changes$ = fromEvent(input1, 'change');\n * const input2Changes$ = fromEvent(input2, 'change');\n *\n * // Combine the changes by adding them together\n * input1Changes$.pipe(\n *   combineLatestWith(input2Changes$),\n *   map(([e1, e2]) => (<HTMLInputElement>e1.target).value + ' - ' + (<HTMLInputElement>e2.target).value)\n * )\n * .subscribe(x => console.log(x));\n * ```\n *\n * @param otherSources the other sources to subscribe to.\n * @return A function that returns an Observable that emits the latest\n * emissions from both source and provided Observables.\n */\nexport function combineLatestWith<T, A extends readonly unknown[]>(\n  ...otherSources: [...ObservableInputTuple<A>]\n): OperatorFunction<T, Cons<T, A>> {\n  return combineLatest(...otherSources);\n}\n","import { ObservableInputTuple, OperatorFunction, SchedulerLike } from '../types';\nimport { operate } from '../util/lift';\nimport { concatAll } from './concatAll';\nimport { popScheduler } from '../util/args';\nimport { from } from '../observable/from';\n\n/** @deprecated Replaced with {@link concatWith}. Will be removed in v8. */\nexport function concat<T, A extends readonly unknown[]>(...sources: [...ObservableInputTuple<A>]): OperatorFunction<T, T | A[number]>;\n/** @deprecated Replaced with {@link concatWith}. Will be removed in v8. */\nexport function concat<T, A extends readonly unknown[]>(\n  ...sourcesAndScheduler: [...ObservableInputTuple<A>, SchedulerLike]\n): OperatorFunction<T, T | A[number]>;\n\n/**\n * @deprecated Replaced with {@link concatWith}. Will be removed in v8.\n */\nexport function concat<T, R>(...args: any[]): OperatorFunction<T, R> {\n  const scheduler = popScheduler(args);\n  return operate((source, subscriber) => {\n    concatAll()(from([source, ...args], scheduler)).subscribe(subscriber);\n  });\n}\n","import { mergeAll } from './mergeAll';\nimport { OperatorFunction, ObservableInput, ObservedValueOf } from '../types';\n\n/**\n * Converts a higher-order Observable into a first-order Observable by\n * concatenating the inner Observables in order.\n *\n * <span class=\"informal\">Flattens an Observable-of-Observables by putting one\n * inner Observable after the other.</span>\n *\n * ![](concatAll.svg)\n *\n * Joins every Observable emitted by the source (a higher-order Observable), in\n * a serial fashion. It subscribes to each inner Observable only after the\n * previous inner Observable has completed, and merges all of their values into\n * the returned observable.\n *\n * __Warning:__ If the source Observable emits Observables quickly and\n * endlessly, and the inner Observables it emits generally complete slower than\n * the source emits, you can run into memory issues as the incoming Observables\n * collect in an unbounded buffer.\n *\n * Note: `concatAll` is equivalent to `mergeAll` with concurrency parameter set\n * to `1`.\n *\n * ## Example\n *\n * For each click event, tick every second from 0 to 3, with no concurrency\n *\n * ```ts\n * import { fromEvent, map, interval, take, concatAll } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const higherOrder = clicks.pipe(\n *   map(() => interval(1000).pipe(take(4)))\n * );\n * const firstOrder = higherOrder.pipe(concatAll());\n * firstOrder.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // (results are not concurrent)\n * // For every click on the \"document\" it will emit values 0 to 3 spaced\n * // on a 1000ms interval\n * // one click = 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3\n * ```\n *\n * @see {@link combineLatestAll}\n * @see {@link concat}\n * @see {@link concatMap}\n * @see {@link concatMapTo}\n * @see {@link exhaustAll}\n * @see {@link mergeAll}\n * @see {@link switchAll}\n * @see {@link switchMap}\n * @see {@link zipAll}\n *\n * @return A function that returns an Observable emitting values from all the\n * inner Observables concatenated.\n */\nexport function concatAll<O extends ObservableInput<any>>(): OperatorFunction<O, ObservedValueOf<O>> {\n  return mergeAll(1);\n}\n","import { mergeMap } from './mergeMap';\nimport { ObservableInput, OperatorFunction, ObservedValueOf } from '../types';\nimport { isFunction } from '../util/isFunction';\n\n/* tslint:disable:max-line-length */\nexport function concatMap<T, O extends ObservableInput<any>>(\n  project: (value: T, index: number) => O\n): OperatorFunction<T, ObservedValueOf<O>>;\n/** @deprecated The `resultSelector` parameter will be removed in v8. Use an inner `map` instead. Details: https://rxjs.dev/deprecations/resultSelector */\nexport function concatMap<T, O extends ObservableInput<any>>(\n  project: (value: T, index: number) => O,\n  resultSelector: undefined\n): OperatorFunction<T, ObservedValueOf<O>>;\n/** @deprecated The `resultSelector` parameter will be removed in v8. Use an inner `map` instead. Details: https://rxjs.dev/deprecations/resultSelector */\nexport function concatMap<T, R, O extends ObservableInput<any>>(\n  project: (value: T, index: number) => O,\n  resultSelector: (outerValue: T, innerValue: ObservedValueOf<O>, outerIndex: number, innerIndex: number) => R\n): OperatorFunction<T, R>;\n/* tslint:enable:max-line-length */\n\n/**\n * Projects each source value to an Observable which is merged in the output\n * Observable, in a serialized fashion waiting for each one to complete before\n * merging the next.\n *\n * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n * these inner Observables using {@link concatAll}.</span>\n *\n * ![](concatMap.png)\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an (so-called \"inner\") Observable. Each new inner Observable is\n * concatenated with the previous inner Observable.\n *\n * __Warning:__ if source values arrive endlessly and faster than their\n * corresponding inner Observables can complete, it will result in memory issues\n * as inner Observables amass in an unbounded buffer waiting for their turn to\n * be subscribed to.\n *\n * Note: `concatMap` is equivalent to `mergeMap` with concurrency parameter set\n * to `1`.\n *\n * ## Example\n *\n * For each click event, tick every second from 0 to 3, with no concurrency\n *\n * ```ts\n * import { fromEvent, concatMap, interval, take } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(\n *   concatMap(ev => interval(1000).pipe(take(4)))\n * );\n * result.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // (results are not concurrent)\n * // For every click on the \"document\" it will emit values 0 to 3 spaced\n * // on a 1000ms interval\n * // one click = 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3\n * ```\n *\n * @see {@link concat}\n * @see {@link concatAll}\n * @see {@link concatMapTo}\n * @see {@link exhaustMap}\n * @see {@link mergeMap}\n * @see {@link switchMap}\n *\n * @param {function(value: T, ?index: number): ObservableInput} project A function\n * that, when applied to an item emitted by the source Observable, returns an\n * Observable.\n * @return A function that returns an Observable that emits the result of\n * applying the projection function (and the optional deprecated\n * `resultSelector`) to each item emitted by the source Observable and taking\n * values from each projected inner Observable sequentially.\n */\nexport function concatMap<T, R, O extends ObservableInput<any>>(\n  project: (value: T, index: number) => O,\n  resultSelector?: (outerValue: T, innerValue: ObservedValueOf<O>, outerIndex: number, innerIndex: number) => R\n): OperatorFunction<T, ObservedValueOf<O> | R> {\n  return isFunction(resultSelector) ? mergeMap(project, resultSelector, 1) : mergeMap(project, 1);\n}\n","import { concatMap } from './concatMap';\nimport { ObservableInput, OperatorFunction, ObservedValueOf } from '../types';\nimport { isFunction } from '../util/isFunction';\n\n/** @deprecated Will be removed in v9. Use {@link concatMap} instead: `concatMap(() => result)` */\nexport function concatMapTo<O extends ObservableInput<unknown>>(observable: O): OperatorFunction<unknown, ObservedValueOf<O>>;\n/** @deprecated The `resultSelector` parameter will be removed in v8. Use an inner `map` instead. Details: https://rxjs.dev/deprecations/resultSelector */\nexport function concatMapTo<O extends ObservableInput<unknown>>(\n  observable: O,\n  resultSelector: undefined\n): OperatorFunction<unknown, ObservedValueOf<O>>;\n/** @deprecated The `resultSelector` parameter will be removed in v8. Use an inner `map` instead. Details: https://rxjs.dev/deprecations/resultSelector */\nexport function concatMapTo<T, R, O extends ObservableInput<unknown>>(\n  observable: O,\n  resultSelector: (outerValue: T, innerValue: ObservedValueOf<O>, outerIndex: number, innerIndex: number) => R\n): OperatorFunction<T, R>;\n\n/**\n * Projects each source value to the same Observable which is merged multiple\n * times in a serialized fashion on the output Observable.\n *\n * <span class=\"informal\">It's like {@link concatMap}, but maps each value\n * always to the same inner Observable.</span>\n *\n * ![](concatMapTo.png)\n *\n * Maps each source value to the given Observable `innerObservable` regardless\n * of the source value, and then flattens those resulting Observables into one\n * single Observable, which is the output Observable. Each new `innerObservable`\n * instance emitted on the output Observable is concatenated with the previous\n * `innerObservable` instance.\n *\n * __Warning:__ if source values arrive endlessly and faster than their\n * corresponding inner Observables can complete, it will result in memory issues\n * as inner Observables amass in an unbounded buffer waiting for their turn to\n * be subscribed to.\n *\n * Note: `concatMapTo` is equivalent to `mergeMapTo` with concurrency parameter\n * set to `1`.\n *\n * ## Example\n *\n * For each click event, tick every second from 0 to 3, with no concurrency\n *\n * ```ts\n * import { fromEvent, concatMapTo, interval, take } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(\n *   concatMapTo(interval(1000).pipe(take(4)))\n * );\n * result.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // (results are not concurrent)\n * // For every click on the \"document\" it will emit values 0 to 3 spaced\n * // on a 1000ms interval\n * // one click = 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3\n * ```\n *\n * @see {@link concat}\n * @see {@link concatAll}\n * @see {@link concatMap}\n * @see {@link mergeMapTo}\n * @see {@link switchMapTo}\n *\n * @param {ObservableInput} innerObservable An Observable to replace each value from\n * the source Observable.\n * @return A function that returns an Observable of values merged together by\n * joining the passed Observable with itself, one after the other, for each\n * value emitted from the source.\n * @deprecated Will be removed in v9. Use {@link concatMap} instead: `concatMap(() => result)`\n */\nexport function concatMapTo<T, R, O extends ObservableInput<unknown>>(\n  innerObservable: O,\n  resultSelector?: (outerValue: T, innerValue: ObservedValueOf<O>, outerIndex: number, innerIndex: number) => R\n): OperatorFunction<T, ObservedValueOf<O> | R> {\n  return isFunction(resultSelector) ? concatMap(() => innerObservable, resultSelector) : concatMap(() => innerObservable);\n}\n","import { ObservableInputTuple, OperatorFunction } from '../types';\nimport { concat } from './concat';\n\n/**\n * Emits all of the values from the source observable, then, once it completes, subscribes\n * to each observable source provided, one at a time, emitting all of their values, and not subscribing\n * to the next one until it completes.\n *\n * `concat(a$, b$, c$)` is the same as `a$.pipe(concatWith(b$, c$))`.\n *\n * ## Example\n *\n * Listen for one mouse click, then listen for all mouse moves.\n *\n * ```ts\n * import { fromEvent, map, take, concatWith } from 'rxjs';\n *\n * const clicks$ = fromEvent(document, 'click');\n * const moves$ = fromEvent(document, 'mousemove');\n *\n * clicks$.pipe(\n *   map(() => 'click'),\n *   take(1),\n *   concatWith(\n *     moves$.pipe(\n *       map(() => 'move')\n *     )\n *   )\n * )\n * .subscribe(x => console.log(x));\n *\n * // 'click'\n * // 'move'\n * // 'move'\n * // 'move'\n * // ...\n * ```\n *\n * @param otherSources Other observable sources to subscribe to, in sequence, after the original source is complete.\n * @return A function that returns an Observable that concatenates\n * subscriptions to the source and provided Observables subscribing to the next\n * only once the current subscription completes.\n */\nexport function concatWith<T, A extends readonly unknown[]>(\n  ...otherSources: [...ObservableInputTuple<A>]\n): OperatorFunction<T, T | A[number]> {\n  return concat(...otherSources);\n}\n","import { OperatorFunction, ObservableInput, ObservedValueOf, SubjectLike } from '../types';\nimport { Observable } from '../Observable';\nimport { Subject } from '../Subject';\nimport { innerFrom } from '../observable/innerFrom';\nimport { operate } from '../util/lift';\nimport { fromSubscribable } from '../observable/fromSubscribable';\n\n/**\n * An object used to configure {@link connect} operator.\n */\nexport interface ConnectConfig<T> {\n  /**\n   * A factory function used to create the Subject through which the source\n   * is multicast. By default, this creates a {@link Subject}.\n   */\n  connector: () => SubjectLike<T>;\n}\n\n/**\n * The default configuration for `connect`.\n */\nconst DEFAULT_CONFIG: ConnectConfig<unknown> = {\n  connector: () => new Subject<unknown>(),\n};\n\n/**\n * Creates an observable by multicasting the source within a function that\n * allows the developer to define the usage of the multicast prior to connection.\n *\n * This is particularly useful if the observable source you wish to multicast could\n * be synchronous or asynchronous. This sets it apart from {@link share}, which, in the\n * case of totally synchronous sources will fail to share a single subscription with\n * multiple consumers, as by the time the subscription to the result of {@link share}\n * has returned, if the source is synchronous its internal reference count will jump from\n * 0 to 1 back to 0 and reset.\n *\n * To use `connect`, you provide a `selector` function that will give you\n * a multicast observable that is not yet connected. You then use that multicast observable\n * to create a resulting observable that, when subscribed, will set up your multicast. This is\n * generally, but not always, accomplished with {@link merge}.\n *\n * Note that using a {@link takeUntil} inside of `connect`'s `selector` _might_ mean you were looking\n * to use the {@link takeWhile} operator instead.\n *\n * When you subscribe to the result of `connect`, the `selector` function will be called. After\n * the `selector` function returns, the observable it returns will be subscribed to, _then_ the\n * multicast will be connected to the source.\n *\n * ## Example\n *\n * Sharing a totally synchronous observable\n *\n * ```ts\n * import { of, tap, connect, merge, map, filter } from 'rxjs';\n *\n * const source$ = of(1, 2, 3, 4, 5).pipe(\n *   tap({\n *     subscribe: () => console.log('subscription started'),\n *     next: n => console.log(`source emitted ${ n }`)\n *   })\n * );\n *\n * source$.pipe(\n *   // Notice in here we're merging 3 subscriptions to `shared$`.\n *   connect(shared$ => merge(\n *     shared$.pipe(map(n => `all ${ n }`)),\n *     shared$.pipe(filter(n => n % 2 === 0), map(n => `even ${ n }`)),\n *     shared$.pipe(filter(n => n % 2 === 1), map(n => `odd ${ n }`))\n *   ))\n * )\n * .subscribe(console.log);\n *\n * // Expected output: (notice only one subscription)\n * 'subscription started'\n * 'source emitted 1'\n * 'all 1'\n * 'odd 1'\n * 'source emitted 2'\n * 'all 2'\n * 'even 2'\n * 'source emitted 3'\n * 'all 3'\n * 'odd 3'\n * 'source emitted 4'\n * 'all 4'\n * 'even 4'\n * 'source emitted 5'\n * 'all 5'\n * 'odd 5'\n * ```\n *\n * @param selector A function used to set up the multicast. Gives you a multicast observable\n * that is not yet connected. With that, you're expected to create and return\n * and Observable, that when subscribed to, will utilize the multicast observable.\n * After this function is executed -- and its return value subscribed to -- the\n * operator will subscribe to the source, and the connection will be made.\n * @param config The configuration object for `connect`.\n */\nexport function connect<T, O extends ObservableInput<unknown>>(\n  selector: (shared: Observable<T>) => O,\n  config: ConnectConfig<T> = DEFAULT_CONFIG\n): OperatorFunction<T, ObservedValueOf<O>> {\n  const { connector } = config;\n  return operate((source, subscriber) => {\n    const subject = connector();\n    innerFrom(selector(fromSubscribable(subject))).subscribe(subscriber);\n    subscriber.add(source.subscribe(subject));\n  });\n}\n","import { OperatorFunction } from '../types';\nimport { reduce } from './reduce';\n\n/**\n * Counts the number of emissions on the source and emits that number when the\n * source completes.\n *\n * <span class=\"informal\">Tells how many values were emitted, when the source\n * completes.</span>\n *\n * ![](count.png)\n *\n * `count` transforms an Observable that emits values into an Observable that\n * emits a single value that represents the number of values emitted by the\n * source Observable. If the source Observable terminates with an error, `count`\n * will pass this error notification along without emitting a value first. If\n * the source Observable does not terminate at all, `count` will neither emit\n * a value nor terminate. This operator takes an optional `predicate` function\n * as argument, in which case the output emission will represent the number of\n * source values that matched `true` with the `predicate`.\n *\n * ## Examples\n *\n * Counts how many seconds have passed before the first click happened\n *\n * ```ts\n * import { interval, fromEvent, takeUntil, count } from 'rxjs';\n *\n * const seconds = interval(1000);\n * const clicks = fromEvent(document, 'click');\n * const secondsBeforeClick = seconds.pipe(takeUntil(clicks));\n * const result = secondsBeforeClick.pipe(count());\n * result.subscribe(x => console.log(x));\n * ```\n *\n * Counts how many odd numbers are there between 1 and 7\n *\n * ```ts\n * import { range, count } from 'rxjs';\n *\n * const numbers = range(1, 7);\n * const result = numbers.pipe(count(i => i % 2 === 1));\n * result.subscribe(x => console.log(x));\n * // Results in:\n * // 4\n * ```\n *\n * @see {@link max}\n * @see {@link min}\n * @see {@link reduce}\n *\n * @param predicate A function that is used to analyze the value and the index and\n * determine whether or not to increment the count. Return `true` to increment the count,\n * and return `false` to keep the count the same.\n * If the predicate is not provided, every value will be counted.\n * @return A function that returns an Observable that emits one number that\n * represents the count of emissions.\n */\nexport function count<T>(predicate?: (value: T, index: number) => boolean): OperatorFunction<T, number> {\n  return reduce((total, value, i) => (!predicate || predicate(value, i) ? total + 1 : total), 0);\n}\n","import { Subscriber } from '../Subscriber';\nimport { MonoTypeOperatorFunction, ObservableInput } from '../types';\nimport { operate } from '../util/lift';\nimport { noop } from '../util/noop';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nimport { innerFrom } from '../observable/innerFrom';\n\n/**\n * Emits a notification from the source Observable only after a particular time span\n * determined by another Observable has passed without another source emission.\n *\n * <span class=\"informal\">It's like {@link debounceTime}, but the time span of\n * emission silence is determined by a second Observable.</span>\n *\n * ![](debounce.svg)\n *\n * `debounce` delays notifications emitted by the source Observable, but drops previous\n * pending delayed emissions if a new notification arrives on the source Observable.\n * This operator keeps track of the most recent notification from the source\n * Observable, and spawns a duration Observable by calling the\n * `durationSelector` function. The notification is emitted only when the duration\n * Observable emits a next notification, and if no other notification was emitted on\n * the source Observable since the duration Observable was spawned. If a new\n * notification appears before the duration Observable emits, the previous notification will\n * not be emitted and a new duration is scheduled from `durationSelector` is scheduled.\n * If the completing event happens during the scheduled duration the last cached notification\n * is emitted before the completion event is forwarded to the output observable.\n * If the error event happens during the scheduled duration or after it only the error event is\n * forwarded to the output observable. The cache notification is not emitted in this case.\n *\n * Like {@link debounceTime}, this is a rate-limiting operator, and also a\n * delay-like operator since output emissions do not necessarily occur at the\n * same time as they did on the source Observable.\n *\n * ## Example\n *\n * Emit the most recent click after a burst of clicks\n *\n * ```ts\n * import { fromEvent, scan, debounce, interval } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(\n *   scan(i => ++i, 1),\n *   debounce(i => interval(200 * i))\n * );\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link audit}\n * @see {@link auditTime}\n * @see {@link debounceTime}\n * @see {@link delay}\n * @see {@link sample}\n * @see {@link sampleTime}\n * @see {@link throttle}\n * @see {@link throttleTime}\n *\n * @param durationSelector A function\n * that receives a value from the source Observable, for computing the timeout\n * duration for each source value, returned as an Observable or a Promise.\n * @return A function that returns an Observable that delays the emissions of\n * the source Observable by the specified duration Observable returned by\n * `durationSelector`, and may drop some values if they occur too frequently.\n */\nexport function debounce<T>(durationSelector: (value: T) => ObservableInput<any>): MonoTypeOperatorFunction<T> {\n  return operate((source, subscriber) => {\n    let hasValue = false;\n    let lastValue: T | null = null;\n    // The subscriber/subscription for the current debounce, if there is one.\n    let durationSubscriber: Subscriber<any> | null = null;\n\n    const emit = () => {\n      // Unsubscribe any current debounce subscription we have,\n      // we only cared about the first notification from it, and we\n      // want to clean that subscription up as soon as possible.\n      durationSubscriber?.unsubscribe();\n      durationSubscriber = null;\n      if (hasValue) {\n        // We have a value! Free up memory first, then emit the value.\n        hasValue = false;\n        const value = lastValue!;\n        lastValue = null;\n        subscriber.next(value);\n      }\n    };\n\n    source.subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        (value: T) => {\n          // Cancel any pending debounce duration. We don't\n          // need to null it out here yet tho, because we're just going\n          // to create another one in a few lines.\n          durationSubscriber?.unsubscribe();\n          hasValue = true;\n          lastValue = value;\n          // Capture our duration subscriber, so we can unsubscribe it when we're notified\n          // and we're going to emit the value.\n          durationSubscriber = createOperatorSubscriber(subscriber, emit, noop);\n          // Subscribe to the duration.\n          innerFrom(durationSelector(value)).subscribe(durationSubscriber);\n        },\n        () => {\n          // Source completed.\n          // Emit any pending debounced values then complete\n          emit();\n          subscriber.complete();\n        },\n        // Pass all errors through to consumer\n        undefined,\n        () => {\n          // Finalization.\n          lastValue = durationSubscriber = null;\n        }\n      )\n    );\n  });\n}\n","import { asyncScheduler } from '../scheduler/async';\nimport { Subscription } from '../Subscription';\nimport { MonoTypeOperatorFunction, SchedulerAction, SchedulerLike } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\n/**\n * Emits a notification from the source Observable only after a particular time span\n * has passed without another source emission.\n *\n * <span class=\"informal\">It's like {@link delay}, but passes only the most\n * recent notification from each burst of emissions.</span>\n *\n * ![](debounceTime.png)\n *\n * `debounceTime` delays notifications emitted by the source Observable, but drops\n * previous pending delayed emissions if a new notification arrives on the source\n * Observable. This operator keeps track of the most recent notification from the\n * source Observable, and emits that only when `dueTime` has passed\n * without any other notification appearing on the source Observable. If a new value\n * appears before `dueTime` silence occurs, the previous notification will be dropped\n * and will not be emitted and a new `dueTime` is scheduled.\n * If the completing event happens during `dueTime` the last cached notification\n * is emitted before the completion event is forwarded to the output observable.\n * If the error event happens during `dueTime` or after it only the error event is\n * forwarded to the output observable. The cache notification is not emitted in this case.\n *\n * This is a rate-limiting operator, because it is impossible for more than one\n * notification to be emitted in any time window of duration `dueTime`, but it is also\n * a delay-like operator since output emissions do not occur at the same time as\n * they did on the source Observable. Optionally takes a {@link SchedulerLike} for\n * managing timers.\n *\n * ## Example\n *\n * Emit the most recent click after a burst of clicks\n *\n * ```ts\n * import { fromEvent, debounceTime } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(debounceTime(1000));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link audit}\n * @see {@link auditTime}\n * @see {@link debounce}\n * @see {@link sample}\n * @see {@link sampleTime}\n * @see {@link throttle}\n * @see {@link throttleTime}\n *\n * @param {number} dueTime The timeout duration in milliseconds (or the time\n * unit determined internally by the optional `scheduler`) for the window of\n * time required to wait for emission silence before emitting the most recent\n * source value.\n * @param {SchedulerLike} [scheduler=async] The {@link SchedulerLike} to use for\n * managing the timers that handle the timeout for each value.\n * @return A function that returns an Observable that delays the emissions of\n * the source Observable by the specified `dueTime`, and may drop some values\n * if they occur too frequently.\n */\nexport function debounceTime<T>(dueTime: number, scheduler: SchedulerLike = asyncScheduler): MonoTypeOperatorFunction<T> {\n  return operate((source, subscriber) => {\n    let activeTask: Subscription | null = null;\n    let lastValue: T | null = null;\n    let lastTime: number | null = null;\n\n    const emit = () => {\n      if (activeTask) {\n        // We have a value! Free up memory first, then emit the value.\n        activeTask.unsubscribe();\n        activeTask = null;\n        const value = lastValue!;\n        lastValue = null;\n        subscriber.next(value);\n      }\n    };\n    function emitWhenIdle(this: SchedulerAction<unknown>) {\n      // This is called `dueTime` after the first value\n      // but we might have received new values during this window!\n\n      const targetTime = lastTime! + dueTime;\n      const now = scheduler.now();\n      if (now < targetTime) {\n        // On that case, re-schedule to the new target\n        activeTask = this.schedule(undefined, targetTime - now);\n        subscriber.add(activeTask);\n        return;\n      }\n\n      emit();\n    }\n\n    source.subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        (value: T) => {\n          lastValue = value;\n          lastTime = scheduler.now();\n\n          // Only set up a task if it's not already up\n          if (!activeTask) {\n            activeTask = scheduler.schedule(emitWhenIdle, dueTime);\n            subscriber.add(activeTask);\n          }\n        },\n        () => {\n          // Source completed.\n          // Emit any pending debounced values then complete\n          emit();\n          subscriber.complete();\n        },\n        // Pass all errors through to consumer.\n        undefined,\n        () => {\n          // Finalization.\n          lastValue = activeTask = null;\n        }\n      )\n    );\n  });\n}\n","import { OperatorFunction } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\n/**\n * Emits a given value if the source Observable completes without emitting any\n * `next` value, otherwise mirrors the source Observable.\n *\n * <span class=\"informal\">If the source Observable turns out to be empty, then\n * this operator will emit a default value.</span>\n *\n * ![](defaultIfEmpty.png)\n *\n * `defaultIfEmpty` emits the values emitted by the source Observable or a\n * specified default value if the source Observable is empty (completes without\n * having emitted any `next` value).\n *\n * ## Example\n *\n * If no clicks happen in 5 seconds, then emit 'no clicks'\n *\n * ```ts\n * import { fromEvent, takeUntil, interval, defaultIfEmpty } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const clicksBeforeFive = clicks.pipe(takeUntil(interval(5000)));\n * const result = clicksBeforeFive.pipe(defaultIfEmpty('no clicks'));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link empty}\n * @see {@link last}\n *\n * @param defaultValue The default value used if the source\n * Observable is empty.\n * @return A function that returns an Observable that emits either the\n * specified `defaultValue` if the source Observable emits no items, or the\n * values emitted by the source Observable.\n */\nexport function defaultIfEmpty<T, R>(defaultValue: R): OperatorFunction<T, T | R> {\n  return operate((source, subscriber) => {\n    let hasValue = false;\n    source.subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        (value) => {\n          hasValue = true;\n          subscriber.next(value);\n        },\n        () => {\n          if (!hasValue) {\n            subscriber.next(defaultValue!);\n          }\n          subscriber.complete();\n        }\n      )\n    );\n  });\n}\n","import { asyncScheduler } from '../scheduler/async';\nimport { MonoTypeOperatorFunction, SchedulerLike } from '../types';\nimport { delayWhen } from './delayWhen';\nimport { timer } from '../observable/timer';\n\n/**\n * Delays the emission of items from the source Observable by a given timeout or\n * until a given Date.\n *\n * <span class=\"informal\">Time shifts each item by some specified amount of\n * milliseconds.</span>\n *\n * ![](delay.svg)\n *\n * If the delay argument is a Number, this operator time shifts the source\n * Observable by that amount of time expressed in milliseconds. The relative\n * time intervals between the values are preserved.\n *\n * If the delay argument is a Date, this operator time shifts the start of the\n * Observable execution until the given date occurs.\n *\n * ## Examples\n *\n * Delay each click by one second\n *\n * ```ts\n * import { fromEvent, delay } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const delayedClicks = clicks.pipe(delay(1000)); // each click emitted after 1 second\n * delayedClicks.subscribe(x => console.log(x));\n * ```\n *\n * Delay all clicks until a future date happens\n *\n * ```ts\n * import { fromEvent, delay } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const date = new Date('March 15, 2050 12:00:00'); // in the future\n * const delayedClicks = clicks.pipe(delay(date)); // click emitted only after that date\n * delayedClicks.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link delayWhen}\n * @see {@link throttle}\n * @see {@link throttleTime}\n * @see {@link debounce}\n * @see {@link debounceTime}\n * @see {@link sample}\n * @see {@link sampleTime}\n * @see {@link audit}\n * @see {@link auditTime}\n *\n * @param {number|Date} due The delay duration in milliseconds (a `number`) or\n * a `Date` until which the emission of the source items is delayed.\n * @param {SchedulerLike} [scheduler=async] The {@link SchedulerLike} to use for\n * managing the timers that handle the time-shift for each item.\n * @return A function that returns an Observable that delays the emissions of\n * the source Observable by the specified timeout or Date.\n */\nexport function delay<T>(due: number | Date, scheduler: SchedulerLike = asyncScheduler): MonoTypeOperatorFunction<T> {\n  const duration = timer(due, scheduler);\n  return delayWhen(() => duration);\n}\n","import { Observable } from '../Observable';\nimport { MonoTypeOperatorFunction, ObservableInput } from '../types';\nimport { concat } from '../observable/concat';\nimport { take } from './take';\nimport { ignoreElements } from './ignoreElements';\nimport { mapTo } from './mapTo';\nimport { mergeMap } from './mergeMap';\nimport { innerFrom } from '../observable/innerFrom';\n\n/** @deprecated The `subscriptionDelay` parameter will be removed in v8. */\nexport function delayWhen<T>(\n  delayDurationSelector: (value: T, index: number) => ObservableInput<any>,\n  subscriptionDelay: Observable<any>\n): MonoTypeOperatorFunction<T>;\nexport function delayWhen<T>(delayDurationSelector: (value: T, index: number) => ObservableInput<any>): MonoTypeOperatorFunction<T>;\n\n/**\n * Delays the emission of items from the source Observable by a given time span\n * determined by the emissions of another Observable.\n *\n * <span class=\"informal\">It's like {@link delay}, but the time span of the\n * delay duration is determined by a second Observable.</span>\n *\n * ![](delayWhen.png)\n *\n * `delayWhen` operator shifts each emitted value from the source Observable by\n * a time span determined by another Observable. When the source emits a value,\n * the `delayDurationSelector` function is called with the value emitted from\n * the source Observable as the first argument to the `delayDurationSelector`.\n * The `delayDurationSelector` function should return an {@link ObservableInput},\n * that is internally converted to an Observable that is called the \"duration\"\n * Observable.\n *\n * The source value is emitted on the output Observable only when the \"duration\"\n * Observable emits ({@link guide/glossary-and-semantics#next next}s) any value.\n * Upon that, the \"duration\" Observable gets unsubscribed.\n *\n * Before RxJS V7, the {@link guide/glossary-and-semantics#complete completion}\n * of the \"duration\" Observable would have been triggering the emission of the\n * source value to the output Observable, but with RxJS V7, this is not the case\n * anymore.\n *\n * Only next notifications (from the \"duration\" Observable) trigger values from\n * the source Observable to be passed to the output Observable. If the \"duration\"\n * Observable only emits the complete notification (without next), the value\n * emitted by the source Observable will never get to the output Observable - it\n * will be swallowed. If the \"duration\" Observable errors, the error will be\n * propagated to the output Observable.\n *\n * Optionally, `delayWhen` takes a second argument, `subscriptionDelay`, which\n * is an Observable. When `subscriptionDelay` emits its first value or\n * completes, the source Observable is subscribed to and starts behaving like\n * described in the previous paragraph. If `subscriptionDelay` is not provided,\n * `delayWhen` will subscribe to the source Observable as soon as the output\n * Observable is subscribed.\n *\n * ## Example\n *\n * Delay each click by a random amount of time, between 0 and 5 seconds\n *\n * ```ts\n * import { fromEvent, delayWhen, interval } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const delayedClicks = clicks.pipe(\n *   delayWhen(() => interval(Math.random() * 5000))\n * );\n * delayedClicks.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link delay}\n * @see {@link throttle}\n * @see {@link throttleTime}\n * @see {@link debounce}\n * @see {@link debounceTime}\n * @see {@link sample}\n * @see {@link sampleTime}\n * @see {@link audit}\n * @see {@link auditTime}\n *\n * @param delayDurationSelector A function that returns an `ObservableInput` for\n * each `value` emitted by the source Observable, which is then used to delay the\n * emission of that `value` on the output Observable until the `ObservableInput`\n * returned from this function emits a next value. When called, beside `value`,\n * this function receives a zero-based `index` of the emission order.\n * @param subscriptionDelay An Observable that triggers the subscription to the\n * source Observable once it emits any value.\n * @return A function that returns an Observable that delays the emissions of\n * the source Observable by an amount of time specified by the Observable\n * returned by `delayDurationSelector`.\n */\nexport function delayWhen<T>(\n  delayDurationSelector: (value: T, index: number) => ObservableInput<any>,\n  subscriptionDelay?: Observable<any>\n): MonoTypeOperatorFunction<T> {\n  if (subscriptionDelay) {\n    // DEPRECATED PATH\n    return (source: Observable<T>) =>\n      concat(subscriptionDelay.pipe(take(1), ignoreElements()), source.pipe(delayWhen(delayDurationSelector)));\n  }\n\n  return mergeMap((value, index) => innerFrom(delayDurationSelector(value, index)).pipe(take(1), mapTo(value)));\n}\n","import { observeNotification } from '../Notification';\nimport { OperatorFunction, ObservableNotification, ValueFromNotification } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\n/**\n * Converts an Observable of {@link ObservableNotification} objects into the emissions\n * that they represent.\n *\n * <span class=\"informal\">Unwraps {@link ObservableNotification} objects as actual `next`,\n * `error` and `complete` emissions. The opposite of {@link materialize}.</span>\n *\n * ![](dematerialize.png)\n *\n * `dematerialize` is assumed to operate an Observable that only emits\n * {@link ObservableNotification} objects as `next` emissions, and does not emit any\n * `error`. Such Observable is the output of a `materialize` operation. Those\n * notifications are then unwrapped using the metadata they contain, and emitted\n * as `next`, `error`, and `complete` on the output Observable.\n *\n * Use this operator in conjunction with {@link materialize}.\n *\n * ## Example\n *\n * Convert an Observable of Notifications to an actual Observable\n *\n * ```ts\n * import { NextNotification, ErrorNotification, of, dematerialize } from 'rxjs';\n *\n * const notifA: NextNotification<string> = { kind: 'N', value: 'A' };\n * const notifB: NextNotification<string> = { kind: 'N', value: 'B' };\n * const notifE: ErrorNotification = { kind: 'E', error: new TypeError('x.toUpperCase is not a function') };\n *\n * const materialized = of(notifA, notifB, notifE);\n *\n * const upperCase = materialized.pipe(dematerialize());\n * upperCase.subscribe({\n *   next: x => console.log(x),\n *   error: e => console.error(e)\n * });\n *\n * // Results in:\n * // A\n * // B\n * // TypeError: x.toUpperCase is not a function\n * ```\n *\n * @see {@link materialize}\n *\n * @return A function that returns an Observable that emits items and\n * notifications embedded in Notification objects emitted by the source\n * Observable.\n */\nexport function dematerialize<N extends ObservableNotification<any>>(): OperatorFunction<N, ValueFromNotification<N>> {\n  return operate((source, subscriber) => {\n    source.subscribe(createOperatorSubscriber(subscriber, (notification) => observeNotification(notification, subscriber)));\n  });\n}\n","import { MonoTypeOperatorFunction, ObservableInput } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nimport { noop } from '../util/noop';\nimport { innerFrom } from '../observable/innerFrom';\n\n/**\n * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from previous items.\n *\n * If a `keySelector` function is provided, then it will project each value from the source observable into a new value that it will\n * check for equality with previously projected values. If the `keySelector` function is not provided, it will use each value from the\n * source observable directly with an equality check against previous values.\n *\n * In JavaScript runtimes that support `Set`, this operator will use a `Set` to improve performance of the distinct value checking.\n *\n * In other runtimes, this operator will use a minimal implementation of `Set` that relies on an `Array` and `indexOf` under the\n * hood, so performance will degrade as more values are checked for distinction. Even in newer browsers, a long-running `distinct`\n * use might result in memory leaks. To help alleviate this in some scenarios, an optional `flushes` parameter is also provided so\n * that the internal `Set` can be \"flushed\", basically clearing it of values.\n *\n * ## Examples\n *\n * A simple example with numbers\n *\n * ```ts\n * import { of, distinct } from 'rxjs';\n *\n * of(1, 1, 2, 2, 2, 1, 2, 3, 4, 3, 2, 1)\n *   .pipe(distinct())\n *   .subscribe(x => console.log(x));\n *\n * // Outputs\n * // 1\n * // 2\n * // 3\n * // 4\n * ```\n *\n * An example using the `keySelector` function\n *\n * ```ts\n * import { of, distinct } from 'rxjs';\n *\n * of(\n *   { age: 4, name: 'Foo'},\n *   { age: 7, name: 'Bar'},\n *   { age: 5, name: 'Foo'}\n * )\n * .pipe(distinct(({ name }) => name))\n * .subscribe(x => console.log(x));\n *\n * // Outputs\n * // { age: 4, name: 'Foo' }\n * // { age: 7, name: 'Bar' }\n * ```\n * @see {@link distinctUntilChanged}\n * @see {@link distinctUntilKeyChanged}\n *\n * @param keySelector Optional `function` to select which value you want to check as distinct.\n * @param flushes Optional `ObservableInput` for flushing the internal HashSet of the operator.\n * @return A function that returns an Observable that emits items from the\n * source Observable with distinct values.\n */\nexport function distinct<T, K>(keySelector?: (value: T) => K, flushes?: ObservableInput<any>): MonoTypeOperatorFunction<T> {\n  return operate((source, subscriber) => {\n    const distinctKeys = new Set();\n    source.subscribe(\n      createOperatorSubscriber(subscriber, (value) => {\n        const key = keySelector ? keySelector(value) : value;\n        if (!distinctKeys.has(key)) {\n          distinctKeys.add(key);\n          subscriber.next(value);\n        }\n      })\n    );\n\n    flushes && innerFrom(flushes).subscribe(createOperatorSubscriber(subscriber, () => distinctKeys.clear(), noop));\n  });\n}\n","import { MonoTypeOperatorFunction } from '../types';\nimport { identity } from '../util/identity';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\nexport function distinctUntilChanged<T>(comparator?: (previous: T, current: T) => boolean): MonoTypeOperatorFunction<T>;\nexport function distinctUntilChanged<T, K>(\n  comparator: (previous: K, current: K) => boolean,\n  keySelector: (value: T) => K\n): MonoTypeOperatorFunction<T>;\n\n/**\n * Returns a result {@link Observable} that emits all values pushed by the source observable if they\n * are distinct in comparison to the last value the result observable emitted.\n *\n * When provided without parameters or with the first parameter (`{@link distinctUntilChanged#comparator comparator}`),\n * it behaves like this:\n *\n * 1. It will always emit the first value from the source.\n * 2. For all subsequent values pushed by the source, they will be compared to the previously emitted values\n *    using the provided `comparator` or an `===` equality check.\n * 3. If the value pushed by the source is determined to be unequal by this check, that value is emitted and\n *    becomes the new \"previously emitted value\" internally.\n *\n * When the second parameter (`{@link distinctUntilChanged#keySelector keySelector}`) is provided, the behavior\n * changes:\n *\n * 1. It will always emit the first value from the source.\n * 2. The `keySelector` will be run against all values, including the first value.\n * 3. For all values after the first, the selected key will be compared against the key selected from\n *    the previously emitted value using the `comparator`.\n * 4. If the keys are determined to be unequal by this check, the value (not the key), is emitted\n *    and the selected key from that value is saved for future comparisons against other keys.\n *\n * ## Examples\n *\n * A very basic example with no `{@link distinctUntilChanged#comparator comparator}`. Note that `1` is emitted more than once,\n * because it's distinct in comparison to the _previously emitted_ value,\n * not in comparison to _all other emitted values_.\n *\n * ```ts\n * import { of, distinctUntilChanged } from 'rxjs';\n *\n * of(1, 1, 1, 2, 2, 2, 1, 1, 3, 3)\n *   .pipe(distinctUntilChanged())\n *   .subscribe(console.log);\n * // Logs: 1, 2, 1, 3\n * ```\n *\n * With a `{@link distinctUntilChanged#comparator comparator}`, you can do custom comparisons. Let's say\n * you only want to emit a value when all of its components have\n * changed:\n *\n * ```ts\n * import { of, distinctUntilChanged } from 'rxjs';\n *\n * const totallyDifferentBuilds$ = of(\n *   { engineVersion: '1.1.0', transmissionVersion: '1.2.0' },\n *   { engineVersion: '1.1.0', transmissionVersion: '1.4.0' },\n *   { engineVersion: '1.3.0', transmissionVersion: '1.4.0' },\n *   { engineVersion: '1.3.0', transmissionVersion: '1.5.0' },\n *   { engineVersion: '2.0.0', transmissionVersion: '1.5.0' }\n * ).pipe(\n *   distinctUntilChanged((prev, curr) => {\n *     return (\n *       prev.engineVersion === curr.engineVersion ||\n *       prev.transmissionVersion === curr.transmissionVersion\n *     );\n *   })\n * );\n *\n * totallyDifferentBuilds$.subscribe(console.log);\n *\n * // Logs:\n * // { engineVersion: '1.1.0', transmissionVersion: '1.2.0' }\n * // { engineVersion: '1.3.0', transmissionVersion: '1.4.0' }\n * // { engineVersion: '2.0.0', transmissionVersion: '1.5.0' }\n * ```\n *\n * You can also provide a custom `{@link distinctUntilChanged#comparator comparator}` to check that emitted\n * changes are only in one direction. Let's say you only want to get\n * the next record temperature:\n *\n * ```ts\n * import { of, distinctUntilChanged } from 'rxjs';\n *\n * const temps$ = of(30, 31, 20, 34, 33, 29, 35, 20);\n *\n * const recordHighs$ = temps$.pipe(\n *   distinctUntilChanged((prevHigh, temp) => {\n *     // If the current temp is less than\n *     // or the same as the previous record,\n *     // the record hasn't changed.\n *     return temp <= prevHigh;\n *   })\n * );\n *\n * recordHighs$.subscribe(console.log);\n * // Logs: 30, 31, 34, 35\n * ```\n *\n * Selecting update events only when the `updatedBy` field shows\n * the account changed hands.\n *\n * ```ts\n * import { of, distinctUntilChanged } from 'rxjs';\n *\n * // A stream of updates to a given account\n * const accountUpdates$ = of(\n *   { updatedBy: 'blesh', data: [] },\n *   { updatedBy: 'blesh', data: [] },\n *   { updatedBy: 'ncjamieson', data: [] },\n *   { updatedBy: 'ncjamieson', data: [] },\n *   { updatedBy: 'blesh', data: [] }\n * );\n *\n * // We only want the events where it changed hands\n * const changedHands$ = accountUpdates$.pipe(\n *   distinctUntilChanged(undefined, update => update.updatedBy)\n * );\n *\n * changedHands$.subscribe(console.log);\n * // Logs:\n * // { updatedBy: 'blesh', data: Array[0] }\n * // { updatedBy: 'ncjamieson', data: Array[0] }\n * // { updatedBy: 'blesh', data: Array[0] }\n * ```\n *\n * @see {@link distinct}\n * @see {@link distinctUntilKeyChanged}\n *\n * @param comparator A function used to compare the previous and current keys for\n * equality. Defaults to a `===` check.\n * @param keySelector Used to select a key value to be passed to the `comparator`.\n *\n * @return A function that returns an Observable that emits items from the\n * source Observable with distinct values.\n */\nexport function distinctUntilChanged<T, K>(\n  comparator?: (previous: K, current: K) => boolean,\n  keySelector: (value: T) => K = identity as (value: T) => K\n): MonoTypeOperatorFunction<T> {\n  // We've been allowing `null` do be passed as the `compare`, so we can't do\n  // a default value for the parameter, because that will only work\n  // for `undefined`.\n  comparator = comparator ?? defaultCompare;\n\n  return operate((source, subscriber) => {\n    // The previous key, used to compare against keys selected\n    // from new arrivals to determine \"distinctiveness\".\n    let previousKey: K;\n    // Whether or not this is the first value we've gotten.\n    let first = true;\n\n    source.subscribe(\n      createOperatorSubscriber(subscriber, (value) => {\n        // We always call the key selector.\n        const currentKey = keySelector(value);\n\n        // If it's the first value, we always emit it.\n        // Otherwise, we compare this key to the previous key, and\n        // if the comparer returns false, we emit.\n        if (first || !comparator!(previousKey, currentKey)) {\n          // Update our state *before* we emit the value\n          // as emission can be the source of re-entrant code\n          // in functional libraries like this. We only really\n          // need to do this if it's the first value, or if the\n          // key we're tracking in previous needs to change.\n          first = false;\n          previousKey = currentKey;\n\n          // Emit the value!\n          subscriber.next(value);\n        }\n      })\n    );\n  });\n}\n\nfunction defaultCompare(a: any, b: any) {\n  return a === b;\n}\n","import { distinctUntilChanged } from './distinctUntilChanged';\nimport { MonoTypeOperatorFunction } from '../types';\n\n/* tslint:disable:max-line-length */\nexport function distinctUntilKeyChanged<T>(key: keyof T): MonoTypeOperatorFunction<T>;\nexport function distinctUntilKeyChanged<T, K extends keyof T>(key: K, compare: (x: T[K], y: T[K]) => boolean): MonoTypeOperatorFunction<T>;\n/* tslint:enable:max-line-length */\n\n/**\n * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from the previous item,\n * using a property accessed by using the key provided to check if the two items are distinct.\n *\n * If a comparator function is provided, then it will be called for each item to test for whether or not that value should be emitted.\n *\n * If a comparator function is not provided, an equality check is used by default.\n *\n * ## Examples\n *\n * An example comparing the name of persons\n *\n * ```ts\n * import { of, distinctUntilKeyChanged } from 'rxjs';\n *\n * of(\n *   { age: 4, name: 'Foo' },\n *   { age: 7, name: 'Bar' },\n *   { age: 5, name: 'Foo' },\n *   { age: 6, name: 'Foo' }\n * ).pipe(\n *   distinctUntilKeyChanged('name')\n * )\n * .subscribe(x => console.log(x));\n *\n * // displays:\n * // { age: 4, name: 'Foo' }\n * // { age: 7, name: 'Bar' }\n * // { age: 5, name: 'Foo' }\n * ```\n *\n * An example comparing the first letters of the name\n *\n * ```ts\n * import { of, distinctUntilKeyChanged } from 'rxjs';\n *\n * of(\n *   { age: 4, name: 'Foo1' },\n *   { age: 7, name: 'Bar' },\n *   { age: 5, name: 'Foo2' },\n *   { age: 6, name: 'Foo3' }\n * ).pipe(\n *   distinctUntilKeyChanged('name', (x, y) => x.substring(0, 3) === y.substring(0, 3))\n * )\n * .subscribe(x => console.log(x));\n *\n * // displays:\n * // { age: 4, name: 'Foo1' }\n * // { age: 7, name: 'Bar' }\n * // { age: 5, name: 'Foo2' }\n * ```\n *\n * @see {@link distinct}\n * @see {@link distinctUntilChanged}\n *\n * @param {string} key String key for object property lookup on each item.\n * @param {function} [compare] Optional comparison function called to test if an item is distinct from the previous item in the source.\n * @return A function that returns an Observable that emits items from the\n * source Observable with distinct values based on the key specified.\n */\nexport function distinctUntilKeyChanged<T, K extends keyof T>(key: K, compare?: (x: T[K], y: T[K]) => boolean): MonoTypeOperatorFunction<T> {\n  return distinctUntilChanged((x: T, y: T) => compare ? compare(x[key], y[key]) : x[key] === y[key]);\n}\n","import { ArgumentOutOfRangeError } from '../util/ArgumentOutOfRangeError';\nimport { Observable } from '../Observable';\nimport { OperatorFunction } from '../types';\nimport { filter } from './filter';\nimport { throwIfEmpty } from './throwIfEmpty';\nimport { defaultIfEmpty } from './defaultIfEmpty';\nimport { take } from './take';\n\n/**\n * Emits the single value at the specified `index` in a sequence of emissions\n * from the source Observable.\n *\n * <span class=\"informal\">Emits only the i-th value, then completes.</span>\n *\n * ![](elementAt.png)\n *\n * `elementAt` returns an Observable that emits the item at the specified\n * `index` in the source Observable, or a default value if that `index` is out\n * of range and the `default` argument is provided. If the `default` argument is\n * not given and the `index` is out of range, the output Observable will emit an\n * `ArgumentOutOfRangeError` error.\n *\n * ## Example\n *\n * Emit only the third click event\n *\n * ```ts\n * import { fromEvent, elementAt } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(elementAt(2));\n * result.subscribe(x => console.log(x));\n *\n * // Results in:\n * // click 1 = nothing\n * // click 2 = nothing\n * // click 3 = MouseEvent object logged to console\n * ```\n *\n * @see {@link first}\n * @see {@link last}\n * @see {@link skip}\n * @see {@link single}\n * @see {@link take}\n *\n * @throws {ArgumentOutOfRangeError} When using `elementAt(i)`, it delivers an\n * ArgumentOutOfRangeError to the Observer's `error` callback if `i < 0` or the\n * Observable has completed before emitting the i-th `next` notification.\n *\n * @param {number} index Is the number `i` for the i-th source emission that has\n * happened since the subscription, starting from the number `0`.\n * @param {T} [defaultValue] The default value returned for missing indices.\n * @return A function that returns an Observable that emits a single item, if\n * it is found. Otherwise, it will emit the default value if given. If not, it\n * emits an error.\n */\nexport function elementAt<T, D = T>(index: number, defaultValue?: D): OperatorFunction<T, T | D> {\n  if (index < 0) {\n    throw new ArgumentOutOfRangeError();\n  }\n  const hasDefaultValue = arguments.length >= 2;\n  return (source: Observable<T>) =>\n    source.pipe(\n      filter((v, i) => i === index),\n      take(1),\n      hasDefaultValue ? defaultIfEmpty(defaultValue!) : throwIfEmpty(() => new ArgumentOutOfRangeError())\n    );\n}\n","/** prettier */\nimport { Observable } from '../Observable';\nimport { concat } from '../observable/concat';\nimport { of } from '../observable/of';\nimport { MonoTypeOperatorFunction, SchedulerLike, OperatorFunction, ValueFromArray } from '../types';\n\n/** @deprecated The `scheduler` parameter will be removed in v8. Use `scheduled` and `concatAll`. Details: https://rxjs.dev/deprecations/scheduler-argument */\nexport function endWith<T>(scheduler: SchedulerLike): MonoTypeOperatorFunction<T>;\n/** @deprecated The `scheduler` parameter will be removed in v8. Use `scheduled` and `concatAll`. Details: https://rxjs.dev/deprecations/scheduler-argument */\nexport function endWith<T, A extends unknown[] = T[]>(\n  ...valuesAndScheduler: [...A, SchedulerLike]\n): OperatorFunction<T, T | ValueFromArray<A>>;\n\nexport function endWith<T, A extends unknown[] = T[]>(...values: A): OperatorFunction<T, T | ValueFromArray<A>>;\n\n/**\n * Returns an observable that will emit all values from the source, then synchronously emit\n * the provided value(s) immediately after the source completes.\n *\n * NOTE: Passing a last argument of a Scheduler is _deprecated_, and may result in incorrect\n * types in TypeScript.\n *\n * This is useful for knowing when an observable ends. Particularly when paired with an\n * operator like {@link takeUntil}\n *\n * ![](endWith.png)\n *\n * ## Example\n *\n * Emit values to know when an interval starts and stops. The interval will\n * stop when a user clicks anywhere on the document.\n *\n * ```ts\n * import { interval, map, fromEvent, startWith, takeUntil, endWith } from 'rxjs';\n *\n * const ticker$ = interval(5000).pipe(\n *   map(() => 'tick')\n * );\n *\n * const documentClicks$ = fromEvent(document, 'click');\n *\n * ticker$.pipe(\n *   startWith('interval started'),\n *   takeUntil(documentClicks$),\n *   endWith('interval ended by click')\n * )\n * .subscribe(x => console.log(x));\n *\n * // Result (assuming a user clicks after 15 seconds)\n * // 'interval started'\n * // 'tick'\n * // 'tick'\n * // 'tick'\n * // 'interval ended by click'\n * ```\n *\n * @see {@link startWith}\n * @see {@link concat}\n * @see {@link takeUntil}\n *\n * @param values Items you want the modified Observable to emit last.\n * @return A function that returns an Observable that emits all values from the\n * source, then synchronously emits the provided value(s) immediately after the\n * source completes.\n */\nexport function endWith<T>(...values: Array<T | SchedulerLike>): MonoTypeOperatorFunction<T> {\n  return (source: Observable<T>) => concat(source, of(...values)) as Observable<T>;\n}\n","import { Observable } from '../Observable';\nimport { Falsy, OperatorFunction } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\nexport function every<T>(predicate: BooleanConstructor): OperatorFunction<T, Exclude<T, Falsy> extends never ? false : boolean>;\n/** @deprecated Use a closure instead of a `thisArg`. Signatures accepting a `thisArg` will be removed in v8. */\nexport function every<T>(\n  predicate: BooleanConstructor,\n  thisArg: any\n): OperatorFunction<T, Exclude<T, Falsy> extends never ? false : boolean>;\n/** @deprecated Use a closure instead of a `thisArg`. Signatures accepting a `thisArg` will be removed in v8. */\nexport function every<T, A>(\n  predicate: (this: A, value: T, index: number, source: Observable<T>) => boolean,\n  thisArg: A\n): OperatorFunction<T, boolean>;\nexport function every<T>(predicate: (value: T, index: number, source: Observable<T>) => boolean): OperatorFunction<T, boolean>;\n\n/**\n * Returns an Observable that emits whether or not every item of the source satisfies the condition specified.\n *\n * <span class=\"informal\">If all values pass predicate before the source completes, emits true before completion,\n * otherwise emit false, then complete.</span>\n *\n * ![](every.png)\n *\n * ## Example\n *\n * A simple example emitting true if all elements are less than 5, false otherwise\n *\n * ```ts\n * import { of, every } from 'rxjs';\n *\n * of(1, 2, 3, 4, 5, 6)\n *   .pipe(every(x => x < 5))\n *   .subscribe(x => console.log(x)); // -> false\n * ```\n *\n * @param {function} predicate A function for determining if an item meets a specified condition.\n * @param {any} [thisArg] Optional object to use for `this` in the callback.\n * @return A function that returns an Observable of booleans that determines if\n * all items of the source Observable meet the condition specified.\n */\nexport function every<T>(\n  predicate: (value: T, index: number, source: Observable<T>) => boolean,\n  thisArg?: any\n): OperatorFunction<T, boolean> {\n  return operate((source, subscriber) => {\n    let index = 0;\n    source.subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        (value) => {\n          if (!predicate.call(thisArg, value, index++, source)) {\n            subscriber.next(false);\n            subscriber.complete();\n          }\n        },\n        () => {\n          subscriber.next(true);\n          subscriber.complete();\n        }\n      )\n    );\n  });\n}\n","import { exhaustAll } from './exhaustAll';\n\n/**\n * @deprecated Renamed to {@link exhaustAll}. Will be removed in v8.\n */\nexport const exhaust = exhaustAll;\n","import { OperatorFunction, ObservableInput, ObservedValueOf } from '../types';\nimport { exhaustMap } from './exhaustMap';\nimport { identity } from '../util/identity';\n\n/**\n * Converts a higher-order Observable into a first-order Observable by dropping\n * inner Observables while the previous inner Observable has not yet completed.\n *\n * <span class=\"informal\">Flattens an Observable-of-Observables by dropping the\n * next inner Observables while the current inner is still executing.</span>\n *\n * ![](exhaustAll.svg)\n *\n * `exhaustAll` subscribes to an Observable that emits Observables, also known as a\n * higher-order Observable. Each time it observes one of these emitted inner\n * Observables, the output Observable begins emitting the items emitted by that\n * inner Observable. So far, it behaves like {@link mergeAll}. However,\n * `exhaustAll` ignores every new inner Observable if the previous Observable has\n * not yet completed. Once that one completes, it will accept and flatten the\n * next inner Observable and repeat this process.\n *\n * ## Example\n *\n * Run a finite timer for each click, only if there is no currently active timer\n *\n * ```ts\n * import { fromEvent, map, interval, take, exhaustAll } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const higherOrder = clicks.pipe(\n *   map(() => interval(1000).pipe(take(5)))\n * );\n * const result = higherOrder.pipe(exhaustAll());\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link combineLatestAll}\n * @see {@link concatAll}\n * @see {@link switchAll}\n * @see {@link switchMap}\n * @see {@link mergeAll}\n * @see {@link exhaustMap}\n * @see {@link zipAll}\n *\n * @return A function that returns an Observable that takes a source of\n * Observables and propagates the first Observable exclusively until it\n * completes before subscribing to the next.\n */\nexport function exhaustAll<O extends ObservableInput<any>>(): OperatorFunction<O, ObservedValueOf<O>> {\n  return exhaustMap(identity);\n}\n","import { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { ObservableInput, OperatorFunction, ObservedValueOf } from '../types';\nimport { map } from './map';\nimport { innerFrom } from '../observable/innerFrom';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\n/* tslint:disable:max-line-length */\nexport function exhaustMap<T, O extends ObservableInput<any>>(\n  project: (value: T, index: number) => O\n): OperatorFunction<T, ObservedValueOf<O>>;\n/** @deprecated The `resultSelector` parameter will be removed in v8. Use an inner `map` instead. Details: https://rxjs.dev/deprecations/resultSelector */\nexport function exhaustMap<T, O extends ObservableInput<any>>(\n  project: (value: T, index: number) => O,\n  resultSelector: undefined\n): OperatorFunction<T, ObservedValueOf<O>>;\n/** @deprecated The `resultSelector` parameter will be removed in v8. Use an inner `map` instead. Details: https://rxjs.dev/deprecations/resultSelector */\nexport function exhaustMap<T, I, R>(\n  project: (value: T, index: number) => ObservableInput<I>,\n  resultSelector: (outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) => R\n): OperatorFunction<T, R>;\n/* tslint:enable:max-line-length */\n\n/**\n * Projects each source value to an Observable which is merged in the output\n * Observable only if the previous projected Observable has completed.\n *\n * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n * these inner Observables using {@link exhaustAll}.</span>\n *\n * ![](exhaustMap.png)\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an (so-called \"inner\") Observable. When it projects a source value to\n * an Observable, the output Observable begins emitting the items emitted by\n * that projected Observable. However, `exhaustMap` ignores every new projected\n * Observable if the previous projected Observable has not yet completed. Once\n * that one completes, it will accept and flatten the next projected Observable\n * and repeat this process.\n *\n * ## Example\n *\n * Run a finite timer for each click, only if there is no currently active timer\n *\n * ```ts\n * import { fromEvent, exhaustMap, interval, take } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(\n *   exhaustMap(() => interval(1000).pipe(take(5)))\n * );\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link concatMap}\n * @see {@link exhaust}\n * @see {@link mergeMap}\n * @see {@link switchMap}\n *\n * @param {function(value: T, ?index: number): ObservableInput} project A function\n * that, when applied to an item emitted by the source Observable, returns an\n * Observable.\n * @return A function that returns an Observable containing projected\n * Observables of each item of the source, ignoring projected Observables that\n * start before their preceding Observable has completed.\n */\nexport function exhaustMap<T, R, O extends ObservableInput<any>>(\n  project: (value: T, index: number) => O,\n  resultSelector?: (outerValue: T, innerValue: ObservedValueOf<O>, outerIndex: number, innerIndex: number) => R\n): OperatorFunction<T, ObservedValueOf<O> | R> {\n  if (resultSelector) {\n    // DEPRECATED PATH\n    return (source: Observable<T>) =>\n      source.pipe(exhaustMap((a, i) => innerFrom(project(a, i)).pipe(map((b: any, ii: any) => resultSelector(a, b, i, ii)))));\n  }\n  return operate((source, subscriber) => {\n    let index = 0;\n    let innerSub: Subscriber<T> | null = null;\n    let isComplete = false;\n    source.subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        (outerValue) => {\n          if (!innerSub) {\n            innerSub = createOperatorSubscriber(subscriber, undefined, () => {\n              innerSub = null;\n              isComplete && subscriber.complete();\n            });\n            innerFrom(project(outerValue, index++)).subscribe(innerSub);\n          }\n        },\n        () => {\n          isComplete = true;\n          !innerSub && subscriber.complete();\n        }\n      )\n    );\n  });\n}\n","import { OperatorFunction, ObservableInput, ObservedValueOf, SchedulerLike } from '../types';\nimport { operate } from '../util/lift';\nimport { mergeInternals } from './mergeInternals';\n\n/* tslint:disable:max-line-length */\nexport function expand<T, O extends ObservableInput<unknown>>(\n  project: (value: T, index: number) => O,\n  concurrent?: number,\n  scheduler?: SchedulerLike\n): OperatorFunction<T, ObservedValueOf<O>>;\n/**\n * @deprecated The `scheduler` parameter will be removed in v8. If you need to schedule the inner subscription,\n * use `subscribeOn` within the projection function: `expand((value) => fn(value).pipe(subscribeOn(scheduler)))`.\n * Details: Details: https://rxjs.dev/deprecations/scheduler-argument\n */\nexport function expand<T, O extends ObservableInput<unknown>>(\n  project: (value: T, index: number) => O,\n  concurrent: number | undefined,\n  scheduler: SchedulerLike\n): OperatorFunction<T, ObservedValueOf<O>>;\n/* tslint:enable:max-line-length */\n\n/**\n * Recursively projects each source value to an Observable which is merged in\n * the output Observable.\n *\n * <span class=\"informal\">It's similar to {@link mergeMap}, but applies the\n * projection function to every source value as well as every output value.\n * It's recursive.</span>\n *\n * ![](expand.png)\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an Observable, and then merging those resulting Observables and\n * emitting the results of this merger. *Expand* will re-emit on the output\n * Observable every source value. Then, each output value is given to the\n * `project` function which returns an inner Observable to be merged on the\n * output Observable. Those output values resulting from the projection are also\n * given to the `project` function to produce new output values. This is how\n * *expand* behaves recursively.\n *\n * ## Example\n *\n * Start emitting the powers of two on every click, at most 10 of them\n *\n * ```ts\n * import { fromEvent, map, expand, of, delay, take } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const powersOfTwo = clicks.pipe(\n *   map(() => 1),\n *   expand(x => of(2 * x).pipe(delay(1000))),\n *   take(10)\n * );\n * powersOfTwo.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link mergeMap}\n * @see {@link mergeScan}\n *\n * @param {function(value: T, index: number) => Observable} project A function\n * that, when applied to an item emitted by the source or the output Observable,\n * returns an Observable.\n * @param {number} [concurrent=Infinity] Maximum number of input\n * Observables being subscribed to concurrently.\n * @param {SchedulerLike} [scheduler=null] The {@link SchedulerLike} to use for subscribing to\n * each projected inner Observable.\n * @return A function that returns an Observable that emits the source values\n * and also result of applying the projection function to each value emitted on\n * the output Observable and merging the results of the Observables obtained\n * from this transformation.\n */\nexport function expand<T, O extends ObservableInput<unknown>>(\n  project: (value: T, index: number) => O,\n  concurrent = Infinity,\n  scheduler?: SchedulerLike\n): OperatorFunction<T, ObservedValueOf<O>> {\n  concurrent = (concurrent || 0) < 1 ? Infinity : concurrent;\n  return operate((source, subscriber) =>\n    mergeInternals(\n      // General merge params\n      source,\n      subscriber,\n      project,\n      concurrent,\n\n      // onBeforeNext\n      undefined,\n\n      // Expand-specific\n      true, // Use expand path\n      scheduler // Inner subscription scheduler\n    )\n  );\n}\n","import { OperatorFunction, MonoTypeOperatorFunction, TruthyTypesOf } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\n/** @deprecated Use a closure instead of a `thisArg`. Signatures accepting a `thisArg` will be removed in v8. */\nexport function filter<T, S extends T, A>(predicate: (this: A, value: T, index: number) => value is S, thisArg: A): OperatorFunction<T, S>;\nexport function filter<T, S extends T>(predicate: (value: T, index: number) => value is S): OperatorFunction<T, S>;\nexport function filter<T>(predicate: BooleanConstructor): OperatorFunction<T, TruthyTypesOf<T>>;\n/** @deprecated Use a closure instead of a `thisArg`. Signatures accepting a `thisArg` will be removed in v8. */\nexport function filter<T, A>(predicate: (this: A, value: T, index: number) => boolean, thisArg: A): MonoTypeOperatorFunction<T>;\nexport function filter<T>(predicate: (value: T, index: number) => boolean): MonoTypeOperatorFunction<T>;\n\n/**\n * Filter items emitted by the source Observable by only emitting those that\n * satisfy a specified predicate.\n *\n * <span class=\"informal\">Like\n * [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter),\n * it only emits a value from the source if it passes a criterion function.</span>\n *\n * ![](filter.png)\n *\n * Similar to the well-known `Array.prototype.filter` method, this operator\n * takes values from the source Observable, passes them through a `predicate`\n * function and only emits those values that yielded `true`.\n *\n * ## Example\n *\n * Emit only click events whose target was a DIV element\n *\n * ```ts\n * import { fromEvent, filter } from 'rxjs';\n *\n * const div = document.createElement('div');\n * div.style.cssText = 'width: 200px; height: 200px; background: #09c;';\n * document.body.appendChild(div);\n *\n * const clicks = fromEvent(document, 'click');\n * const clicksOnDivs = clicks.pipe(filter(ev => (<HTMLElement>ev.target).tagName === 'DIV'));\n * clicksOnDivs.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link distinct}\n * @see {@link distinctUntilChanged}\n * @see {@link distinctUntilKeyChanged}\n * @see {@link ignoreElements}\n * @see {@link partition}\n * @see {@link skip}\n *\n * @param predicate A function that\n * evaluates each value emitted by the source Observable. If it returns `true`,\n * the value is emitted, if `false` the value is not passed to the output\n * Observable. The `index` parameter is the number `i` for the i-th source\n * emission that has happened since the subscription, starting from the number\n * `0`.\n * @param thisArg An optional argument to determine the value of `this`\n * in the `predicate` function.\n * @return A function that returns an Observable that emits items from the\n * source Observable that satisfy the specified `predicate`.\n */\nexport function filter<T>(predicate: (value: T, index: number) => boolean, thisArg?: any): MonoTypeOperatorFunction<T> {\n  return operate((source, subscriber) => {\n    // An index passed to our predicate function on each call.\n    let index = 0;\n\n    // Subscribe to the source, all errors and completions are\n    // forwarded to the consumer.\n    source.subscribe(\n      // Call the predicate with the appropriate `this` context,\n      // if the predicate returns `true`, then send the value\n      // to the consumer.\n      createOperatorSubscriber(subscriber, (value) => predicate.call(thisArg, value, index++) && subscriber.next(value))\n    );\n  });\n}\n","import { MonoTypeOperatorFunction } from '../types';\nimport { operate } from '../util/lift';\n\n/**\n * Returns an Observable that mirrors the source Observable, but will call a specified function when\n * the source terminates on complete or error.\n * The specified function will also be called when the subscriber explicitly unsubscribes.\n *\n * ## Examples\n *\n * Execute callback function when the observable completes\n *\n * ```ts\n * import { interval, take, finalize } from 'rxjs';\n *\n * // emit value in sequence every 1 second\n * const source = interval(1000);\n * const example = source.pipe(\n *   take(5), //take only the first 5 values\n *   finalize(() => console.log('Sequence complete')) // Execute when the observable completes\n * );\n * const subscribe = example.subscribe(val => console.log(val));\n *\n * // results:\n * // 0\n * // 1\n * // 2\n * // 3\n * // 4\n * // 'Sequence complete'\n * ```\n *\n * Execute callback function when the subscriber explicitly unsubscribes\n *\n * ```ts\n * import { interval, finalize, tap, noop, timer } from 'rxjs';\n *\n * const source = interval(100).pipe(\n *   finalize(() => console.log('[finalize] Called')),\n *   tap({\n *     next: () => console.log('[next] Called'),\n *     error: () => console.log('[error] Not called'),\n *     complete: () => console.log('[tap complete] Not called')\n *   })\n * );\n *\n * const sub = source.subscribe({\n *   next: x => console.log(x),\n *   error: noop,\n *   complete: () => console.log('[complete] Not called')\n * });\n *\n * timer(150).subscribe(() => sub.unsubscribe());\n *\n * // results:\n * // '[next] Called'\n * // 0\n * // '[finalize] Called'\n * ```\n *\n * @param {function} callback Function to be called when source terminates.\n * @return A function that returns an Observable that mirrors the source, but\n * will call the specified function on termination.\n */\nexport function finalize<T>(callback: () => void): MonoTypeOperatorFunction<T> {\n  return operate((source, subscriber) => {\n    // TODO: This try/finally was only added for `useDeprecatedSynchronousErrorHandling`.\n    // REMOVE THIS WHEN THAT HOT GARBAGE IS REMOVED IN V8.\n    try {\n      source.subscribe(subscriber);\n    } finally {\n      subscriber.add(callback);\n    }\n  });\n}\n","import { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { OperatorFunction, TruthyTypesOf } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\nexport function find<T>(predicate: BooleanConstructor): OperatorFunction<T, TruthyTypesOf<T>>;\n/** @deprecated Use a closure instead of a `thisArg`. Signatures accepting a `thisArg` will be removed in v8. */\nexport function find<T, S extends T, A>(\n  predicate: (this: A, value: T, index: number, source: Observable<T>) => value is S,\n  thisArg: A\n): OperatorFunction<T, S | undefined>;\nexport function find<T, S extends T>(\n  predicate: (value: T, index: number, source: Observable<T>) => value is S\n): OperatorFunction<T, S | undefined>;\n/** @deprecated Use a closure instead of a `thisArg`. Signatures accepting a `thisArg` will be removed in v8. */\nexport function find<T, A>(\n  predicate: (this: A, value: T, index: number, source: Observable<T>) => boolean,\n  thisArg: A\n): OperatorFunction<T, T | undefined>;\nexport function find<T>(predicate: (value: T, index: number, source: Observable<T>) => boolean): OperatorFunction<T, T | undefined>;\n/**\n * Emits only the first value emitted by the source Observable that meets some\n * condition.\n *\n * <span class=\"informal\">Finds the first value that passes some test and emits\n * that.</span>\n *\n * ![](find.png)\n *\n * `find` searches for the first item in the source Observable that matches the\n * specified condition embodied by the `predicate`, and returns the first\n * occurrence in the source. Unlike {@link first}, the `predicate` is required\n * in `find`, and does not emit an error if a valid value is not found\n * (emits `undefined` instead).\n *\n * ## Example\n *\n * Find and emit the first click that happens on a DIV element\n *\n * ```ts\n * import { fromEvent, find } from 'rxjs';\n *\n * const div = document.createElement('div');\n * div.style.cssText = 'width: 200px; height: 200px; background: #09c;';\n * document.body.appendChild(div);\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(find(ev => (<HTMLElement>ev.target).tagName === 'DIV'));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link filter}\n * @see {@link first}\n * @see {@link findIndex}\n * @see {@link take}\n *\n * @param {function(value: T, index: number, source: Observable<T>): boolean} predicate\n * A function called with each item to test for condition matching.\n * @param {any} [thisArg] An optional argument to determine the value of `this`\n * in the `predicate` function.\n * @return A function that returns an Observable that emits the first item that\n * matches the condition.\n */\nexport function find<T>(\n  predicate: (value: T, index: number, source: Observable<T>) => boolean,\n  thisArg?: any\n): OperatorFunction<T, T | undefined> {\n  return operate(createFind(predicate, thisArg, 'value'));\n}\n\nexport function createFind<T>(\n  predicate: (value: T, index: number, source: Observable<T>) => boolean,\n  thisArg: any,\n  emit: 'value' | 'index'\n) {\n  const findIndex = emit === 'index';\n  return (source: Observable<T>, subscriber: Subscriber<any>) => {\n    let index = 0;\n    source.subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        (value) => {\n          const i = index++;\n          if (predicate.call(thisArg, value, i, source)) {\n            subscriber.next(findIndex ? i : value);\n            subscriber.complete();\n          }\n        },\n        () => {\n          subscriber.next(findIndex ? -1 : undefined);\n          subscriber.complete();\n        }\n      )\n    );\n  };\n}\n","import { Observable } from '../Observable';\nimport { Falsy, OperatorFunction } from '../types';\nimport { operate } from '../util/lift';\nimport { createFind } from './find';\n\nexport function findIndex<T>(predicate: BooleanConstructor): OperatorFunction<T, T extends Falsy ? -1 : number>;\n/** @deprecated Use a closure instead of a `thisArg`. Signatures accepting a `thisArg` will be removed in v8. */\nexport function findIndex<T>(predicate: BooleanConstructor, thisArg: any): OperatorFunction<T, T extends Falsy ? -1 : number>;\n/** @deprecated Use a closure instead of a `thisArg`. Signatures accepting a `thisArg` will be removed in v8. */\nexport function findIndex<T, A>(\n  predicate: (this: A, value: T, index: number, source: Observable<T>) => boolean,\n  thisArg: A\n): OperatorFunction<T, number>;\nexport function findIndex<T>(predicate: (value: T, index: number, source: Observable<T>) => boolean): OperatorFunction<T, number>;\n\n/**\n * Emits only the index of the first value emitted by the source Observable that\n * meets some condition.\n *\n * <span class=\"informal\">It's like {@link find}, but emits the index of the\n * found value, not the value itself.</span>\n *\n * ![](findIndex.png)\n *\n * `findIndex` searches for the first item in the source Observable that matches\n * the specified condition embodied by the `predicate`, and returns the\n * (zero-based) index of the first occurrence in the source. Unlike\n * {@link first}, the `predicate` is required in `findIndex`, and does not emit\n * an error if a valid value is not found.\n *\n * ## Example\n *\n * Emit the index of first click that happens on a DIV element\n *\n * ```ts\n * import { fromEvent, findIndex } from 'rxjs';\n *\n * const div = document.createElement('div');\n * div.style.cssText = 'width: 200px; height: 200px; background: #09c;';\n * document.body.appendChild(div);\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(findIndex(ev => (<HTMLElement>ev.target).tagName === 'DIV'));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link filter}\n * @see {@link find}\n * @see {@link first}\n * @see {@link take}\n *\n * @param {function(value: T, index: number, source: Observable<T>): boolean} predicate\n * A function called with each item to test for condition matching.\n * @param {any} [thisArg] An optional argument to determine the value of `this`\n * in the `predicate` function.\n * @return A function that returns an Observable that emits the index of the\n * first item that matches the condition.\n */\nexport function findIndex<T>(\n  predicate: (value: T, index: number, source: Observable<T>) => boolean,\n  thisArg?: any\n): OperatorFunction<T, number> {\n  return operate(createFind(predicate, thisArg, 'index'));\n}\n","import { Observable } from '../Observable';\nimport { EmptyError } from '../util/EmptyError';\nimport { OperatorFunction, TruthyTypesOf } from '../types';\nimport { filter } from './filter';\nimport { take } from './take';\nimport { defaultIfEmpty } from './defaultIfEmpty';\nimport { throwIfEmpty } from './throwIfEmpty';\nimport { identity } from '../util/identity';\n\nexport function first<T, D = T>(predicate?: null, defaultValue?: D): OperatorFunction<T, T | D>;\nexport function first<T>(predicate: BooleanConstructor): OperatorFunction<T, TruthyTypesOf<T>>;\nexport function first<T, D>(predicate: BooleanConstructor, defaultValue: D): OperatorFunction<T, TruthyTypesOf<T> | D>;\nexport function first<T, S extends T>(\n  predicate: (value: T, index: number, source: Observable<T>) => value is S,\n  defaultValue?: S\n): OperatorFunction<T, S>;\nexport function first<T, S extends T, D>(\n  predicate: (value: T, index: number, source: Observable<T>) => value is S,\n  defaultValue: D\n): OperatorFunction<T, S | D>;\nexport function first<T, D = T>(\n  predicate: (value: T, index: number, source: Observable<T>) => boolean,\n  defaultValue?: D\n): OperatorFunction<T, T | D>;\n\n/**\n * Emits only the first value (or the first value that meets some condition)\n * emitted by the source Observable.\n *\n * <span class=\"informal\">Emits only the first value. Or emits only the first\n * value that passes some test.</span>\n *\n * ![](first.png)\n *\n * If called with no arguments, `first` emits the first value of the source\n * Observable, then completes. If called with a `predicate` function, `first`\n * emits the first value of the source that matches the specified condition. Throws an error if\n * `defaultValue` was not provided and a matching element is not found.\n *\n * ## Examples\n *\n * Emit only the first click that happens on the DOM\n *\n * ```ts\n * import { fromEvent, first } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(first());\n * result.subscribe(x => console.log(x));\n * ```\n *\n * Emits the first click that happens on a DIV\n *\n * ```ts\n * import { fromEvent, first } from 'rxjs';\n *\n * const div = document.createElement('div');\n * div.style.cssText = 'width: 200px; height: 200px; background: #09c;';\n * document.body.appendChild(div);\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(first(ev => (<HTMLElement>ev.target).tagName === 'DIV'));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link filter}\n * @see {@link find}\n * @see {@link take}\n *\n * @throws {EmptyError} Delivers an EmptyError to the Observer's `error`\n * callback if the Observable completes before any `next` notification was sent.\n * This is how `first()` is different from {@link take}(1) which completes instead.\n *\n * @param {function(value: T, index: number, source: Observable<T>): boolean} [predicate]\n * An optional function called with each item to test for condition matching.\n * @param {D} [defaultValue] The default value emitted in case no valid value\n * was found on the source.\n * @return A function that returns an Observable that emits the first item that\n * matches the condition.\n */\nexport function first<T, D>(\n  predicate?: ((value: T, index: number, source: Observable<T>) => boolean) | null,\n  defaultValue?: D\n): OperatorFunction<T, T | D> {\n  const hasDefaultValue = arguments.length >= 2;\n  return (source: Observable<T>) =>\n    source.pipe(\n      predicate ? filter((v, i) => predicate(v, i, source)) : identity,\n      take(1),\n      hasDefaultValue ? defaultIfEmpty(defaultValue!) : throwIfEmpty(() => new EmptyError())\n    );\n}\n","import { mergeMap } from './mergeMap';\n\n/**\n * @deprecated Renamed to {@link mergeMap}. Will be removed in v8.\n */\nexport const flatMap = mergeMap;\n","import { Observable } from '../Observable';\nimport { innerFrom } from '../observable/innerFrom';\nimport { Subject } from '../Subject';\nimport { ObservableInput, Observer, OperatorFunction, SubjectLike } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber, OperatorSubscriber } from './OperatorSubscriber';\n\nexport interface BasicGroupByOptions<K, T> {\n  element?: undefined;\n  duration?: (grouped: GroupedObservable<K, T>) => ObservableInput<any>;\n  connector?: () => SubjectLike<T>;\n}\n\nexport interface GroupByOptionsWithElement<K, E, T> {\n  element: (value: T) => E;\n  duration?: (grouped: GroupedObservable<K, E>) => ObservableInput<any>;\n  connector?: () => SubjectLike<E>;\n}\n\nexport function groupBy<T, K>(key: (value: T) => K, options: BasicGroupByOptions<K, T>): OperatorFunction<T, GroupedObservable<K, T>>;\n\nexport function groupBy<T, K, E>(\n  key: (value: T) => K,\n  options: GroupByOptionsWithElement<K, E, T>\n): OperatorFunction<T, GroupedObservable<K, E>>;\n\nexport function groupBy<T, K extends T>(\n  key: (value: T) => value is K\n): OperatorFunction<T, GroupedObservable<true, K> | GroupedObservable<false, Exclude<T, K>>>;\n\nexport function groupBy<T, K>(key: (value: T) => K): OperatorFunction<T, GroupedObservable<K, T>>;\n\n/**\n * @deprecated use the options parameter instead.\n */\nexport function groupBy<T, K>(\n  key: (value: T) => K,\n  element: void,\n  duration: (grouped: GroupedObservable<K, T>) => Observable<any>\n): OperatorFunction<T, GroupedObservable<K, T>>;\n\n/**\n * @deprecated use the options parameter instead.\n */\nexport function groupBy<T, K, R>(\n  key: (value: T) => K,\n  element?: (value: T) => R,\n  duration?: (grouped: GroupedObservable<K, R>) => Observable<any>\n): OperatorFunction<T, GroupedObservable<K, R>>;\n\n/**\n * Groups the items emitted by an Observable according to a specified criterion,\n * and emits these grouped items as `GroupedObservables`, one\n * {@link GroupedObservable} per group.\n *\n * ![](groupBy.png)\n *\n * When the Observable emits an item, a key is computed for this item with the key function.\n *\n * If a {@link GroupedObservable} for this key exists, this {@link GroupedObservable} emits. Otherwise, a new\n * {@link GroupedObservable} for this key is created and emits.\n *\n * A {@link GroupedObservable} represents values belonging to the same group represented by a common key. The common\n * key is available as the `key` field of a {@link GroupedObservable} instance.\n *\n * The elements emitted by {@link GroupedObservable}s are by default the items emitted by the Observable, or elements\n * returned by the element function.\n *\n * ## Examples\n *\n * Group objects by `id` and return as array\n *\n * ```ts\n * import { of, groupBy, mergeMap, reduce } from 'rxjs';\n *\n * of(\n *   { id: 1, name: 'JavaScript' },\n *   { id: 2, name: 'Parcel' },\n *   { id: 2, name: 'webpack' },\n *   { id: 1, name: 'TypeScript' },\n *   { id: 3, name: 'TSLint' }\n * ).pipe(\n *   groupBy(p => p.id),\n *   mergeMap(group$ => group$.pipe(reduce((acc, cur) => [...acc, cur], [])))\n * )\n * .subscribe(p => console.log(p));\n *\n * // displays:\n * // [{ id: 1, name: 'JavaScript' }, { id: 1, name: 'TypeScript'}]\n * // [{ id: 2, name: 'Parcel' }, { id: 2, name: 'webpack'}]\n * // [{ id: 3, name: 'TSLint' }]\n * ```\n *\n * Pivot data on the `id` field\n *\n * ```ts\n * import { of, groupBy, mergeMap, reduce, map } from 'rxjs';\n *\n * of(\n *   { id: 1, name: 'JavaScript' },\n *   { id: 2, name: 'Parcel' },\n *   { id: 2, name: 'webpack' },\n *   { id: 1, name: 'TypeScript' },\n *   { id: 3, name: 'TSLint' }\n * ).pipe(\n *   groupBy(p => p.id, { element: p => p.name }),\n *   mergeMap(group$ => group$.pipe(reduce((acc, cur) => [...acc, cur], [`${ group$.key }`]))),\n *   map(arr => ({ id: parseInt(arr[0], 10), values: arr.slice(1) }))\n * )\n * .subscribe(p => console.log(p));\n *\n * // displays:\n * // { id: 1, values: [ 'JavaScript', 'TypeScript' ] }\n * // { id: 2, values: [ 'Parcel', 'webpack' ] }\n * // { id: 3, values: [ 'TSLint' ] }\n * ```\n *\n * @param key A function that extracts the key\n * for each item.\n * @param element A function that extracts the\n * return element for each item.\n * @param duration\n * A function that returns an Observable to determine how long each group should\n * exist.\n * @param connector Factory function to create an\n * intermediate Subject through which grouped elements are emitted.\n * @return A function that returns an Observable that emits GroupedObservables,\n * each of which corresponds to a unique key value and each of which emits\n * those items from the source Observable that share that key value.\n *\n * @deprecated Use the options parameter instead.\n */\nexport function groupBy<T, K, R>(\n  key: (value: T) => K,\n  element?: (value: T) => R,\n  duration?: (grouped: GroupedObservable<K, R>) => Observable<any>,\n  connector?: () => Subject<R>\n): OperatorFunction<T, GroupedObservable<K, R>>;\n\n// Impl\nexport function groupBy<T, K, R>(\n  keySelector: (value: T) => K,\n  elementOrOptions?: ((value: any) => any) | void | BasicGroupByOptions<K, T> | GroupByOptionsWithElement<K, R, T>,\n  duration?: (grouped: GroupedObservable<any, any>) => ObservableInput<any>,\n  connector?: () => SubjectLike<any>\n): OperatorFunction<T, GroupedObservable<K, R>> {\n  return operate((source, subscriber) => {\n    let element: ((value: any) => any) | void;\n    if (!elementOrOptions || typeof elementOrOptions === 'function') {\n      element = elementOrOptions as ((value: any) => any);\n    } else {\n      ({ duration, element, connector } = elementOrOptions);\n    }\n\n    // A lookup for the groups that we have so far.\n    const groups = new Map<K, SubjectLike<any>>();\n\n    // Used for notifying all groups and the subscriber in the same way.\n    const notify = (cb: (group: Observer<any>) => void) => {\n      groups.forEach(cb);\n      cb(subscriber);\n    };\n\n    // Used to handle errors from the source, AND errors that occur during the\n    // next call from the source.\n    const handleError = (err: any) => notify((consumer) => consumer.error(err));\n\n    // The number of actively subscribed groups\n    let activeGroups = 0;\n\n    // Whether or not teardown was attempted on this subscription.\n    let teardownAttempted = false;\n\n    // Capturing a reference to this, because we need a handle to it\n    // in `createGroupedObservable` below. This is what we use to\n    // subscribe to our source observable. This sometimes needs to be unsubscribed\n    // out-of-band with our `subscriber` which is the downstream subscriber, or destination,\n    // in cases where a user unsubscribes from the main resulting subscription, but\n    // still has groups from this subscription subscribed and would expect values from it\n    // Consider:  `source.pipe(groupBy(fn), take(2))`.\n    const groupBySourceSubscriber = new OperatorSubscriber(\n      subscriber,\n      (value: T) => {\n        // Because we have to notify all groups of any errors that occur in here,\n        // we have to add our own try/catch to ensure that those errors are propagated.\n        // OperatorSubscriber will only send the error to the main subscriber.\n        try {\n          const key = keySelector(value);\n\n          let group = groups.get(key);\n          if (!group) {\n            // Create our group subject\n            groups.set(key, (group = connector ? connector() : new Subject<any>()));\n\n            // Emit the grouped observable. Note that we can't do a simple `asObservable()` here,\n            // because the grouped observable has special semantics around reference counting\n            // to ensure we don't sever our connection to the source prematurely.\n            const grouped = createGroupedObservable(key, group);\n            subscriber.next(grouped);\n\n            if (duration) {\n              const durationSubscriber = createOperatorSubscriber(\n                // Providing the group here ensures that it is disposed of -- via `unsubscribe` --\n                // when the duration subscription is torn down. That is important, because then\n                // if someone holds a handle to the grouped observable and tries to subscribe to it\n                // after the connection to the source has been severed, they will get an\n                // `ObjectUnsubscribedError` and know they can't possibly get any notifications.\n                group as any,\n                () => {\n                  // Our duration notified! We can complete the group.\n                  // The group will be removed from the map in the finalization phase.\n                  group!.complete();\n                  durationSubscriber?.unsubscribe();\n                },\n                // Completions are also sent to the group, but just the group.\n                undefined,\n                // Errors on the duration subscriber are sent to the group\n                // but only the group. They are not sent to the main subscription.\n                undefined,\n                // Finalization: Remove this group from our map.\n                () => groups.delete(key)\n              );\n\n              // Start our duration notifier.\n              groupBySourceSubscriber.add(innerFrom(duration(grouped)).subscribe(durationSubscriber));\n            }\n          }\n\n          // Send the value to our group.\n          group.next(element ? element(value) : value);\n        } catch (err) {\n          handleError(err);\n        }\n      },\n      // Source completes.\n      () => notify((consumer) => consumer.complete()),\n      // Error from the source.\n      handleError,\n      // Free up memory.\n      // When the source subscription is _finally_ torn down, release the subjects and keys\n      // in our groups Map, they may be quite large and we don't want to keep them around if we\n      // don't have to.\n      () => groups.clear(),\n      () => {\n        teardownAttempted = true;\n        // We only kill our subscription to the source if we have\n        // no active groups. As stated above, consider this scenario:\n        // source$.pipe(groupBy(fn), take(2)).\n        return activeGroups === 0;\n      }\n    );\n\n    // Subscribe to the source\n    source.subscribe(groupBySourceSubscriber);\n\n    /**\n     * Creates the actual grouped observable returned.\n     * @param key The key of the group\n     * @param groupSubject The subject that fuels the group\n     */\n    function createGroupedObservable(key: K, groupSubject: SubjectLike<any>) {\n      const result: any = new Observable<T>((groupSubscriber) => {\n        activeGroups++;\n        const innerSub = groupSubject.subscribe(groupSubscriber);\n        return () => {\n          innerSub.unsubscribe();\n          // We can kill the subscription to our source if we now have no more\n          // active groups subscribed, and a finalization was already attempted on\n          // the source.\n          --activeGroups === 0 && teardownAttempted && groupBySourceSubscriber.unsubscribe();\n        };\n      });\n      result.key = key;\n      return result;\n    }\n  });\n}\n\n/**\n * An observable of values that is the emitted by the result of a {@link groupBy} operator,\n * contains a `key` property for the grouping.\n */\nexport interface GroupedObservable<K, T> extends Observable<T> {\n  /**\n   * The key value for the grouped notifications.\n   */\n  readonly key: K;\n}\n","import { OperatorFunction } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nimport { noop } from '../util/noop';\n\n/**\n * Ignores all items emitted by the source Observable and only passes calls of `complete` or `error`.\n *\n * ![](ignoreElements.png)\n *\n * The `ignoreElements` operator suppresses all items emitted by the source Observable,\n * but allows its termination notification (either `error` or `complete`) to pass through unchanged.\n *\n * If you do not care about the items being emitted by an Observable, but you do want to be notified\n * when it completes or when it terminates with an error, you can apply the `ignoreElements` operator\n * to the Observable, which will ensure that it will never call its observers `next` handlers.\n *\n * ## Example\n *\n * Ignore all `next` emissions from the source\n *\n * ```ts\n * import { of, ignoreElements } from 'rxjs';\n *\n * of('you', 'talking', 'to', 'me')\n *   .pipe(ignoreElements())\n *   .subscribe({\n *     next: word => console.log(word),\n *     error: err => console.log('error:', err),\n *     complete: () => console.log('the end'),\n *   });\n *\n * // result:\n * // 'the end'\n * ```\n *\n * @return A function that returns an empty Observable that only calls\n * `complete` or `error`, based on which one is called by the source\n * Observable.\n */\nexport function ignoreElements(): OperatorFunction<unknown, never> {\n  return operate((source, subscriber) => {\n    source.subscribe(createOperatorSubscriber(subscriber, noop));\n  });\n}\n","import { OperatorFunction } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\n/**\n * Emits `false` if the input Observable emits any values, or emits `true` if the\n * input Observable completes without emitting any values.\n *\n * <span class=\"informal\">Tells whether any values are emitted by an Observable.</span>\n *\n * ![](isEmpty.png)\n *\n * `isEmpty` transforms an Observable that emits values into an Observable that\n * emits a single boolean value representing whether or not any values were\n * emitted by the source Observable. As soon as the source Observable emits a\n * value, `isEmpty` will emit a `false` and complete.  If the source Observable\n * completes having not emitted anything, `isEmpty` will emit a `true` and\n * complete.\n *\n * A similar effect could be achieved with {@link count}, but `isEmpty` can emit\n * a `false` value sooner.\n *\n * ## Examples\n *\n * Emit `false` for a non-empty Observable\n *\n * ```ts\n * import { Subject, isEmpty } from 'rxjs';\n *\n * const source = new Subject<string>();\n * const result = source.pipe(isEmpty());\n *\n * source.subscribe(x => console.log(x));\n * result.subscribe(x => console.log(x));\n *\n * source.next('a');\n * source.next('b');\n * source.next('c');\n * source.complete();\n *\n * // Outputs\n * // 'a'\n * // false\n * // 'b'\n * // 'c'\n * ```\n *\n * Emit `true` for an empty Observable\n *\n * ```ts\n * import { EMPTY, isEmpty } from 'rxjs';\n *\n * const result = EMPTY.pipe(isEmpty());\n * result.subscribe(x => console.log(x));\n *\n * // Outputs\n * // true\n * ```\n *\n * @see {@link count}\n * @see {@link EMPTY}\n *\n * @return A function that returns an Observable that emits boolean value\n * indicating whether the source Observable was empty or not.\n */\nexport function isEmpty<T>(): OperatorFunction<T, boolean> {\n  return operate((source, subscriber) => {\n    source.subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        () => {\n          subscriber.next(false);\n          subscriber.complete();\n        },\n        () => {\n          subscriber.next(true);\n          subscriber.complete();\n        }\n      )\n    );\n  });\n}\n","import { Observable } from '../Observable';\nimport { ObservableInput, OperatorFunction } from '../types';\nimport { identity } from '../util/identity';\nimport { mapOneOrManyArgs } from '../util/mapOneOrManyArgs';\nimport { pipe } from '../util/pipe';\nimport { mergeMap } from './mergeMap';\nimport { toArray } from './toArray';\n\n/**\n * Collects all of the inner sources from source observable. Then, once the\n * source completes, joins the values using the given static.\n *\n * This is used for {@link combineLatestAll} and {@link zipAll} which both have the\n * same behavior of collecting all inner observables, then operating on them.\n *\n * @param joinFn The type of static join to apply to the sources collected\n * @param project The projection function to apply to the values, if any\n */\nexport function joinAllInternals<T, R>(joinFn: (sources: ObservableInput<T>[]) => Observable<T>, project?: (...args: any[]) => R) {\n  return pipe(\n    // Collect all inner sources into an array, and emit them when the\n    // source completes.\n    toArray() as OperatorFunction<ObservableInput<T>, ObservableInput<T>[]>,\n    // Run the join function on the collected array of inner sources.\n    mergeMap((sources) => joinFn(sources)),\n    // If a projection function was supplied, apply it to each result.\n    project ? mapOneOrManyArgs(project) : (identity as any)\n  );\n}\n","import { Observable } from '../Observable';\nimport { EmptyError } from '../util/EmptyError';\nimport { OperatorFunction, TruthyTypesOf } from '../types';\nimport { filter } from './filter';\nimport { takeLast } from './takeLast';\nimport { throwIfEmpty } from './throwIfEmpty';\nimport { defaultIfEmpty } from './defaultIfEmpty';\nimport { identity } from '../util/identity';\n\nexport function last<T>(predicate: BooleanConstructor): OperatorFunction<T, TruthyTypesOf<T>>;\nexport function last<T, D>(predicate: BooleanConstructor, defaultValue: D): OperatorFunction<T, TruthyTypesOf<T> | D>;\nexport function last<T, D = T>(predicate?: null, defaultValue?: D): OperatorFunction<T, T | D>;\nexport function last<T, S extends T>(\n  predicate: (value: T, index: number, source: Observable<T>) => value is S,\n  defaultValue?: S\n): OperatorFunction<T, S>;\nexport function last<T, D = T>(\n  predicate: (value: T, index: number, source: Observable<T>) => boolean,\n  defaultValue?: D\n): OperatorFunction<T, T | D>;\n\n/**\n * Returns an Observable that emits only the last item emitted by the source Observable.\n * It optionally takes a predicate function as a parameter, in which case, rather than emitting\n * the last item from the source Observable, the resulting Observable will emit the last item\n * from the source Observable that satisfies the predicate.\n *\n * ![](last.png)\n *\n * It will throw an error if the source completes without notification or one that matches the predicate. It\n * returns the last value or if a predicate is provided last value that matches the predicate. It returns the\n * given default value if no notification is emitted or matches the predicate.\n *\n * ## Examples\n *\n * Last alphabet from the sequence\n *\n * ```ts\n * import { from, last } from 'rxjs';\n *\n * const source = from(['x', 'y', 'z']);\n * const result = source.pipe(last());\n *\n * result.subscribe(value => console.log(`Last alphabet: ${ value }`));\n *\n * // Outputs\n * // Last alphabet: z\n * ```\n *\n * Default value when the value in the predicate is not matched\n *\n * ```ts\n * import { from, last } from 'rxjs';\n *\n * const source = from(['x', 'y', 'z']);\n * const result = source.pipe(last(char => char === 'a', 'not found'));\n *\n * result.subscribe(value => console.log(`'a' is ${ value }.`));\n *\n * // Outputs\n * // 'a' is not found.\n * ```\n *\n * @see {@link skip}\n * @see {@link skipUntil}\n * @see {@link skipLast}\n * @see {@link skipWhile}\n *\n * @throws {EmptyError} Delivers an EmptyError to the Observer's `error`\n * callback if the Observable completes before any `next` notification was sent.\n * @param {function} [predicate] - The condition any source emitted item has to satisfy.\n * @param {any} [defaultValue] - An optional default value to provide if last\n * predicate isn't met or no values were emitted.\n * @return A function that returns an Observable that emits only the last item\n * satisfying the given condition from the source, or a NoSuchElementException\n * if no such items are emitted.\n * @throws - Throws if no items that match the predicate are emitted by the source Observable.\n */\nexport function last<T, D>(\n  predicate?: ((value: T, index: number, source: Observable<T>) => boolean) | null,\n  defaultValue?: D\n): OperatorFunction<T, T | D> {\n  const hasDefaultValue = arguments.length >= 2;\n  return (source: Observable<T>) =>\n    source.pipe(\n      predicate ? filter((v, i) => predicate(v, i, source)) : identity,\n      takeLast(1),\n      hasDefaultValue ? defaultIfEmpty(defaultValue!) : throwIfEmpty(() => new EmptyError())\n    );\n}\n","import { OperatorFunction } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\nexport function map<T, R>(project: (value: T, index: number) => R): OperatorFunction<T, R>;\n/** @deprecated Use a closure instead of a `thisArg`. Signatures accepting a `thisArg` will be removed in v8. */\nexport function map<T, R, A>(project: (this: A, value: T, index: number) => R, thisArg: A): OperatorFunction<T, R>;\n\n/**\n * Applies a given `project` function to each value emitted by the source\n * Observable, and emits the resulting values as an Observable.\n *\n * <span class=\"informal\">Like [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map),\n * it passes each source value through a transformation function to get\n * corresponding output values.</span>\n *\n * ![](map.png)\n *\n * Similar to the well known `Array.prototype.map` function, this operator\n * applies a projection to each value and emits that projection in the output\n * Observable.\n *\n * ## Example\n *\n * Map every click to the `clientX` position of that click\n *\n * ```ts\n * import { fromEvent, map } from 'rxjs';\n *\n * const clicks = fromEvent<PointerEvent>(document, 'click');\n * const positions = clicks.pipe(map(ev => ev.clientX));\n *\n * positions.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link mapTo}\n * @see {@link pluck}\n *\n * @param {function(value: T, index: number): R} project The function to apply\n * to each `value` emitted by the source Observable. The `index` parameter is\n * the number `i` for the i-th emission that has happened since the\n * subscription, starting from the number `0`.\n * @param {any} [thisArg] An optional argument to define what `this` is in the\n * `project` function.\n * @return A function that returns an Observable that emits the values from the\n * source Observable transformed by the given `project` function.\n */\nexport function map<T, R>(project: (value: T, index: number) => R, thisArg?: any): OperatorFunction<T, R> {\n  return operate((source, subscriber) => {\n    // The index of the value from the source. Used with projection.\n    let index = 0;\n    // Subscribe to the source, all errors and completions are sent along\n    // to the consumer.\n    source.subscribe(\n      createOperatorSubscriber(subscriber, (value: T) => {\n        // Call the projection function with the appropriate this context,\n        // and send the resulting value to the consumer.\n        subscriber.next(project.call(thisArg, value, index++));\n      })\n    );\n  });\n}\n","import { OperatorFunction } from '../types';\nimport { map } from './map';\n\n/** @deprecated To be removed in v9. Use {@link map} instead: `map(() => value)`. */\nexport function mapTo<R>(value: R): OperatorFunction<unknown, R>;\n/**\n * @deprecated Do not specify explicit type parameters. Signatures with type parameters\n * that cannot be inferred will be removed in v8. `mapTo` itself will be removed in v9,\n * use {@link map} instead: `map(() => value)`.\n * */\nexport function mapTo<T, R>(value: R): OperatorFunction<T, R>;\n\n/**\n * Emits the given constant value on the output Observable every time the source\n * Observable emits a value.\n *\n * <span class=\"informal\">Like {@link map}, but it maps every source value to\n * the same output value every time.</span>\n *\n * ![](mapTo.png)\n *\n * Takes a constant `value` as argument, and emits that whenever the source\n * Observable emits a value. In other words, ignores the actual source value,\n * and simply uses the emission moment to know when to emit the given `value`.\n *\n * ## Example\n *\n * Map every click to the string `'Hi'`\n *\n * ```ts\n * import { fromEvent, mapTo } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const greetings = clicks.pipe(mapTo('Hi'));\n *\n * greetings.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link map}\n *\n * @param value The value to map each source value to.\n * @return A function that returns an Observable that emits the given `value`\n * every time the source Observable emits.\n * @deprecated To be removed in v9. Use {@link map} instead: `map(() => value)`.\n */\nexport function mapTo<R>(value: R): OperatorFunction<unknown, R> {\n  return map(() => value);\n}\n","import { Notification } from '../Notification';\nimport { OperatorFunction, ObservableNotification } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\n/**\n * Represents all of the notifications from the source Observable as `next`\n * emissions marked with their original types within {@link Notification}\n * objects.\n *\n * <span class=\"informal\">Wraps `next`, `error` and `complete` emissions in\n * {@link Notification} objects, emitted as `next` on the output Observable.\n * </span>\n *\n * ![](materialize.png)\n *\n * `materialize` returns an Observable that emits a `next` notification for each\n * `next`, `error`, or `complete` emission of the source Observable. When the\n * source Observable emits `complete`, the output Observable will emit `next` as\n * a Notification of type \"complete\", and then it will emit `complete` as well.\n * When the source Observable emits `error`, the output will emit `next` as a\n * Notification of type \"error\", and then `complete`.\n *\n * This operator is useful for producing metadata of the source Observable, to\n * be consumed as `next` emissions. Use it in conjunction with\n * {@link dematerialize}.\n *\n * ## Example\n *\n * Convert a faulty Observable to an Observable of Notifications\n *\n * ```ts\n * import { of, materialize, map } from 'rxjs';\n *\n * const letters = of('a', 'b', 13, 'd');\n * const upperCase = letters.pipe(map((x: any) => x.toUpperCase()));\n * const materialized = upperCase.pipe(materialize());\n *\n * materialized.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // - Notification { kind: 'N', value: 'A', error: undefined, hasValue: true }\n * // - Notification { kind: 'N', value: 'B', error: undefined, hasValue: true }\n * // - Notification { kind: 'E', value: undefined, error: TypeError { message: x.toUpperCase is not a function }, hasValue: false }\n * ```\n *\n * @see {@link Notification}\n * @see {@link dematerialize}\n *\n * @return A function that returns an Observable that emits\n * {@link Notification} objects that wrap the original emissions from the\n * source Observable with metadata.\n */\nexport function materialize<T>(): OperatorFunction<T, Notification<T> & ObservableNotification<T>> {\n  return operate((source, subscriber) => {\n    source.subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        (value) => {\n          subscriber.next(Notification.createNext(value));\n        },\n        () => {\n          subscriber.next(Notification.createComplete());\n          subscriber.complete();\n        },\n        (err) => {\n          subscriber.next(Notification.createError(err));\n          subscriber.complete();\n        }\n      )\n    );\n  });\n}\n","import { reduce } from './reduce';\nimport { MonoTypeOperatorFunction } from '../types';\nimport { isFunction } from '../util/isFunction';\n\n/**\n * The Max operator operates on an Observable that emits numbers (or items that can be compared with a provided function),\n * and when source Observable completes it emits a single item: the item with the largest value.\n *\n * ![](max.png)\n *\n * ## Examples\n *\n * Get the maximal value of a series of numbers\n *\n * ```ts\n * import { of, max } from 'rxjs';\n *\n * of(5, 4, 7, 2, 8)\n *   .pipe(max())\n *   .subscribe(x => console.log(x));\n *\n * // Outputs\n * // 8\n * ```\n *\n * Use a comparer function to get the maximal item\n *\n * ```ts\n * import { of, max } from 'rxjs';\n *\n * of(\n *   { age: 7, name: 'Foo' },\n *   { age: 5, name: 'Bar' },\n *   { age: 9, name: 'Beer' }\n * ).pipe(\n *   max((a, b) => a.age < b.age ? -1 : 1)\n * )\n * .subscribe(x => console.log(x.name));\n *\n * // Outputs\n * // 'Beer'\n * ```\n *\n * @see {@link min}\n *\n * @param {Function} [comparer] - Optional comparer function that it will use instead of its default to compare the\n * value of two items.\n * @return A function that returns an Observable that emits item with the\n * largest value.\n */\nexport function max<T>(comparer?: (x: T, y: T) => number): MonoTypeOperatorFunction<T> {\n  return reduce(isFunction(comparer) ? (x, y) => (comparer(x, y) > 0 ? x : y) : (x, y) => (x > y ? x : y));\n}\n","import { ObservableInput, ObservableInputTuple, OperatorFunction, SchedulerLike } from '../types';\nimport { operate } from '../util/lift';\nimport { argsOrArgArray } from '../util/argsOrArgArray';\nimport { mergeAll } from './mergeAll';\nimport { popNumber, popScheduler } from '../util/args';\nimport { from } from '../observable/from';\n\n/** @deprecated Replaced with {@link mergeWith}. Will be removed in v8. */\nexport function merge<T, A extends readonly unknown[]>(...sources: [...ObservableInputTuple<A>]): OperatorFunction<T, T | A[number]>;\n/** @deprecated Replaced with {@link mergeWith}. Will be removed in v8. */\nexport function merge<T, A extends readonly unknown[]>(\n  ...sourcesAndConcurrency: [...ObservableInputTuple<A>, number]\n): OperatorFunction<T, T | A[number]>;\n/** @deprecated Replaced with {@link mergeWith}. Will be removed in v8. */\nexport function merge<T, A extends readonly unknown[]>(\n  ...sourcesAndScheduler: [...ObservableInputTuple<A>, SchedulerLike]\n): OperatorFunction<T, T | A[number]>;\n/** @deprecated Replaced with {@link mergeWith}. Will be removed in v8. */\nexport function merge<T, A extends readonly unknown[]>(\n  ...sourcesAndConcurrencyAndScheduler: [...ObservableInputTuple<A>, number, SchedulerLike]\n): OperatorFunction<T, T | A[number]>;\n\nexport function merge<T>(...args: unknown[]): OperatorFunction<T, unknown> {\n  const scheduler = popScheduler(args);\n  const concurrent = popNumber(args, Infinity);\n  args = argsOrArgArray(args);\n\n  return operate((source, subscriber) => {\n    mergeAll(concurrent)(from([source, ...(args as ObservableInput<T>[])], scheduler)).subscribe(subscriber);\n  });\n}\n","import { mergeMap } from './mergeMap';\nimport { identity } from '../util/identity';\nimport { OperatorFunction, ObservableInput, ObservedValueOf } from '../types';\n\n/**\n * Converts a higher-order Observable into a first-order Observable which\n * concurrently delivers all values that are emitted on the inner Observables.\n *\n * <span class=\"informal\">Flattens an Observable-of-Observables.</span>\n *\n * ![](mergeAll.png)\n *\n * `mergeAll` subscribes to an Observable that emits Observables, also known as\n * a higher-order Observable. Each time it observes one of these emitted inner\n * Observables, it subscribes to that and delivers all the values from the\n * inner Observable on the output Observable. The output Observable only\n * completes once all inner Observables have completed. Any error delivered by\n * a inner Observable will be immediately emitted on the output Observable.\n *\n * ## Examples\n *\n * Spawn a new interval Observable for each click event, and blend their outputs as one Observable\n *\n * ```ts\n * import { fromEvent, map, interval, mergeAll } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const higherOrder = clicks.pipe(map(() => interval(1000)));\n * const firstOrder = higherOrder.pipe(mergeAll());\n *\n * firstOrder.subscribe(x => console.log(x));\n * ```\n *\n * Count from 0 to 9 every second for each click, but only allow 2 concurrent timers\n *\n * ```ts\n * import { fromEvent, map, interval, take, mergeAll } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const higherOrder = clicks.pipe(\n *   map(() => interval(1000).pipe(take(10)))\n * );\n * const firstOrder = higherOrder.pipe(mergeAll(2));\n *\n * firstOrder.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link combineLatestAll}\n * @see {@link concatAll}\n * @see {@link exhaustAll}\n * @see {@link merge}\n * @see {@link mergeMap}\n * @see {@link mergeMapTo}\n * @see {@link mergeScan}\n * @see {@link switchAll}\n * @see {@link switchMap}\n * @see {@link zipAll}\n *\n * @param {number} [concurrent=Infinity] Maximum number of inner\n * Observables being subscribed to concurrently.\n * @return A function that returns an Observable that emits values coming from\n * all the inner Observables emitted by the source Observable.\n */\nexport function mergeAll<O extends ObservableInput<any>>(concurrent: number = Infinity): OperatorFunction<O, ObservedValueOf<O>> {\n  return mergeMap(identity, concurrent);\n}\n","import { Observable } from '../Observable';\nimport { innerFrom } from '../observable/innerFrom';\nimport { Subscriber } from '../Subscriber';\nimport { ObservableInput, SchedulerLike } from '../types';\nimport { executeSchedule } from '../util/executeSchedule';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\n/**\n * A process embodying the general \"merge\" strategy. This is used in\n * `mergeMap` and `mergeScan` because the logic is otherwise nearly identical.\n * @param source The original source observable\n * @param subscriber The consumer subscriber\n * @param project The projection function to get our inner sources\n * @param concurrent The number of concurrent inner subscriptions\n * @param onBeforeNext Additional logic to apply before nexting to our consumer\n * @param expand If `true` this will perform an \"expand\" strategy, which differs only\n * in that it recurses, and the inner subscription must be schedule-able.\n * @param innerSubScheduler A scheduler to use to schedule inner subscriptions,\n * this is to support the expand strategy, mostly, and should be deprecated\n */\nexport function mergeInternals<T, R>(\n  source: Observable<T>,\n  subscriber: Subscriber<R>,\n  project: (value: T, index: number) => ObservableInput<R>,\n  concurrent: number,\n  onBeforeNext?: (innerValue: R) => void,\n  expand?: boolean,\n  innerSubScheduler?: SchedulerLike,\n  additionalFinalizer?: () => void\n) {\n  // Buffered values, in the event of going over our concurrency limit\n  const buffer: T[] = [];\n  // The number of active inner subscriptions.\n  let active = 0;\n  // An index to pass to our accumulator function\n  let index = 0;\n  // Whether or not the outer source has completed.\n  let isComplete = false;\n\n  /**\n   * Checks to see if we can complete our result or not.\n   */\n  const checkComplete = () => {\n    // If the outer has completed, and nothing is left in the buffer,\n    // and we don't have any active inner subscriptions, then we can\n    // Emit the state and complete.\n    if (isComplete && !buffer.length && !active) {\n      subscriber.complete();\n    }\n  };\n\n  // If we're under our concurrency limit, just start the inner subscription, otherwise buffer and wait.\n  const outerNext = (value: T) => (active < concurrent ? doInnerSub(value) : buffer.push(value));\n\n  const doInnerSub = (value: T) => {\n    // If we're expanding, we need to emit the outer values and the inner values\n    // as the inners will \"become outers\" in a way as they are recursively fed\n    // back to the projection mechanism.\n    expand && subscriber.next(value as any);\n\n    // Increment the number of active subscriptions so we can track it\n    // against our concurrency limit later.\n    active++;\n\n    // A flag used to show that the inner observable completed.\n    // This is checked during finalization to see if we should\n    // move to the next item in the buffer, if there is on.\n    let innerComplete = false;\n\n    // Start our inner subscription.\n    innerFrom(project(value, index++)).subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        (innerValue) => {\n          // `mergeScan` has additional handling here. For example\n          // taking the inner value and updating state.\n          onBeforeNext?.(innerValue);\n\n          if (expand) {\n            // If we're expanding, then just recurse back to our outer\n            // handler. It will emit the value first thing.\n            outerNext(innerValue as any);\n          } else {\n            // Otherwise, emit the inner value.\n            subscriber.next(innerValue);\n          }\n        },\n        () => {\n          // Flag that we have completed, so we know to check the buffer\n          // during finalization.\n          innerComplete = true;\n        },\n        // Errors are passed to the destination.\n        undefined,\n        () => {\n          // During finalization, if the inner completed (it wasn't errored or\n          // cancelled), then we want to try the next item in the buffer if\n          // there is one.\n          if (innerComplete) {\n            // We have to wrap this in a try/catch because it happens during\n            // finalization, possibly asynchronously, and we want to pass\n            // any errors that happen (like in a projection function) to\n            // the outer Subscriber.\n            try {\n              // INNER SOURCE COMPLETE\n              // Decrement the active count to ensure that the next time\n              // we try to call `doInnerSub`, the number is accurate.\n              active--;\n              // If we have more values in the buffer, try to process those\n              // Note that this call will increment `active` ahead of the\n              // next conditional, if there were any more inner subscriptions\n              // to start.\n              while (buffer.length && active < concurrent) {\n                const bufferedValue = buffer.shift()!;\n                // Particularly for `expand`, we need to check to see if a scheduler was provided\n                // for when we want to start our inner subscription. Otherwise, we just start\n                // are next inner subscription.\n                if (innerSubScheduler) {\n                  executeSchedule(subscriber, innerSubScheduler, () => doInnerSub(bufferedValue));\n                } else {\n                  doInnerSub(bufferedValue);\n                }\n              }\n              // Check to see if we can complete, and complete if so.\n              checkComplete();\n            } catch (err) {\n              subscriber.error(err);\n            }\n          }\n        }\n      )\n    );\n  };\n\n  // Subscribe to our source observable.\n  source.subscribe(\n    createOperatorSubscriber(subscriber, outerNext, () => {\n      // Outer completed, make a note of it, and check to see if we can complete everything.\n      isComplete = true;\n      checkComplete();\n    })\n  );\n\n  // Additional finalization (for when the destination is torn down).\n  // Other finalization is added implicitly via subscription above.\n  return () => {\n    additionalFinalizer?.();\n  };\n}\n","import { ObservableInput, OperatorFunction, ObservedValueOf } from '../types';\nimport { map } from './map';\nimport { innerFrom } from '../observable/innerFrom';\nimport { operate } from '../util/lift';\nimport { mergeInternals } from './mergeInternals';\nimport { isFunction } from '../util/isFunction';\n\n/* tslint:disable:max-line-length */\nexport function mergeMap<T, O extends ObservableInput<any>>(\n  project: (value: T, index: number) => O,\n  concurrent?: number\n): OperatorFunction<T, ObservedValueOf<O>>;\n/** @deprecated The `resultSelector` parameter will be removed in v8. Use an inner `map` instead. Details: https://rxjs.dev/deprecations/resultSelector */\nexport function mergeMap<T, O extends ObservableInput<any>>(\n  project: (value: T, index: number) => O,\n  resultSelector: undefined,\n  concurrent?: number\n): OperatorFunction<T, ObservedValueOf<O>>;\n/** @deprecated The `resultSelector` parameter will be removed in v8. Use an inner `map` instead. Details: https://rxjs.dev/deprecations/resultSelector */\nexport function mergeMap<T, R, O extends ObservableInput<any>>(\n  project: (value: T, index: number) => O,\n  resultSelector: (outerValue: T, innerValue: ObservedValueOf<O>, outerIndex: number, innerIndex: number) => R,\n  concurrent?: number\n): OperatorFunction<T, R>;\n/* tslint:enable:max-line-length */\n\n/**\n * Projects each source value to an Observable which is merged in the output\n * Observable.\n *\n * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n * these inner Observables using {@link mergeAll}.</span>\n *\n * ![](mergeMap.png)\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an Observable, and then merging those resulting Observables and\n * emitting the results of this merger.\n *\n * ## Example\n *\n * Map and flatten each letter to an Observable ticking every 1 second\n *\n * ```ts\n * import { of, mergeMap, interval, map } from 'rxjs';\n *\n * const letters = of('a', 'b', 'c');\n * const result = letters.pipe(\n *   mergeMap(x => interval(1000).pipe(map(i => x + i)))\n * );\n *\n * result.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // a0\n * // b0\n * // c0\n * // a1\n * // b1\n * // c1\n * // continues to list a, b, c every second with respective ascending integers\n * ```\n *\n * @see {@link concatMap}\n * @see {@link exhaustMap}\n * @see {@link merge}\n * @see {@link mergeAll}\n * @see {@link mergeMapTo}\n * @see {@link mergeScan}\n * @see {@link switchMap}\n *\n * @param {function(value: T, ?index: number): ObservableInput} project A function\n * that, when applied to an item emitted by the source Observable, returns an\n * Observable.\n * @param {number} [concurrent=Infinity] Maximum number of input\n * Observables being subscribed to concurrently.\n * @return A function that returns an Observable that emits the result of\n * applying the projection function (and the optional deprecated\n * `resultSelector`) to each item emitted by the source Observable and merging\n * the results of the Observables obtained from this transformation.\n */\nexport function mergeMap<T, R, O extends ObservableInput<any>>(\n  project: (value: T, index: number) => O,\n  resultSelector?: ((outerValue: T, innerValue: ObservedValueOf<O>, outerIndex: number, innerIndex: number) => R) | number,\n  concurrent: number = Infinity\n): OperatorFunction<T, ObservedValueOf<O> | R> {\n  if (isFunction(resultSelector)) {\n    // DEPRECATED PATH\n    return mergeMap((a, i) => map((b: any, ii: number) => resultSelector(a, b, i, ii))(innerFrom(project(a, i))), concurrent);\n  } else if (typeof resultSelector === 'number') {\n    concurrent = resultSelector;\n  }\n\n  return operate((source, subscriber) => mergeInternals(source, subscriber, project, concurrent));\n}\n","import { OperatorFunction, ObservedValueOf, ObservableInput } from '../types';\nimport { mergeMap } from './mergeMap';\nimport { isFunction } from '../util/isFunction';\n\n/** @deprecated Will be removed in v9. Use {@link mergeMap} instead: `mergeMap(() => result)` */\nexport function mergeMapTo<O extends ObservableInput<unknown>>(\n  innerObservable: O,\n  concurrent?: number\n): OperatorFunction<unknown, ObservedValueOf<O>>;\n/**\n * @deprecated The `resultSelector` parameter will be removed in v8. Use an inner `map` instead.\n * Details: https://rxjs.dev/deprecations/resultSelector\n */\nexport function mergeMapTo<T, R, O extends ObservableInput<unknown>>(\n  innerObservable: O,\n  resultSelector: (outerValue: T, innerValue: ObservedValueOf<O>, outerIndex: number, innerIndex: number) => R,\n  concurrent?: number\n): OperatorFunction<T, R>;\n/* tslint:enable:max-line-length */\n\n/**\n * Projects each source value to the same Observable which is merged multiple\n * times in the output Observable.\n *\n * <span class=\"informal\">It's like {@link mergeMap}, but maps each value always\n * to the same inner Observable.</span>\n *\n * ![](mergeMapTo.png)\n *\n * Maps each source value to the given Observable `innerObservable` regardless\n * of the source value, and then merges those resulting Observables into one\n * single Observable, which is the output Observable.\n *\n * ## Example\n *\n * For each click event, start an interval Observable ticking every 1 second\n *\n * ```ts\n * import { fromEvent, mergeMapTo, interval } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(mergeMapTo(interval(1000)));\n *\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link concatMapTo}\n * @see {@link merge}\n * @see {@link mergeAll}\n * @see {@link mergeMap}\n * @see {@link mergeScan}\n * @see {@link switchMapTo}\n *\n * @param {ObservableInput} innerObservable An Observable to replace each value from\n * the source Observable.\n * @param {number} [concurrent=Infinity] Maximum number of input\n * Observables being subscribed to concurrently.\n * @return A function that returns an Observable that emits items from the\n * given `innerObservable`.\n * @deprecated Will be removed in v9. Use {@link mergeMap} instead: `mergeMap(() => result)`\n */\nexport function mergeMapTo<T, R, O extends ObservableInput<unknown>>(\n  innerObservable: O,\n  resultSelector?: ((outerValue: T, innerValue: ObservedValueOf<O>, outerIndex: number, innerIndex: number) => R) | number,\n  concurrent: number = Infinity\n): OperatorFunction<T, ObservedValueOf<O> | R> {\n  if (isFunction(resultSelector)) {\n    return mergeMap(() => innerObservable, resultSelector, concurrent);\n  }\n  if (typeof resultSelector === 'number') {\n    concurrent = resultSelector;\n  }\n  return mergeMap(() => innerObservable, concurrent);\n}\n","import { ObservableInput, OperatorFunction } from '../types';\nimport { operate } from '../util/lift';\nimport { mergeInternals } from './mergeInternals';\n\n/**\n * Applies an accumulator function over the source Observable where the\n * accumulator function itself returns an Observable, then each intermediate\n * Observable returned is merged into the output Observable.\n *\n * <span class=\"informal\">It's like {@link scan}, but the Observables returned\n * by the accumulator are merged into the outer Observable.</span>\n *\n * The first parameter of the `mergeScan` is an `accumulator` function which is\n * being called every time the source Observable emits a value. `mergeScan` will\n * subscribe to the value returned by the `accumulator` function and will emit\n * values to the subscriber emitted by inner Observable.\n *\n * The `accumulator` function is being called with three parameters passed to it:\n * `acc`, `value` and `index`. The `acc` parameter is used as the state parameter\n * whose value is initially set to the `seed` parameter (the second parameter\n * passed to the `mergeScan` operator).\n *\n * `mergeScan` internally keeps the value of the `acc` parameter: as long as the\n * source Observable emits without inner Observable emitting, the `acc` will be\n * set to `seed`. The next time the inner Observable emits a value, `mergeScan`\n * will internally remember it and it will be passed to the `accumulator`\n * function as `acc` parameter the next time source emits.\n *\n * The `value` parameter of the `accumulator` function is the value emitted by the\n * source Observable, while the `index` is a number which represent the order of the\n * current emission by the source Observable. It starts with 0.\n *\n * The last parameter to the `mergeScan` is the `concurrent` value which defaults\n * to Infinity. It represents the maximum number of inner Observable subscriptions\n * at a time.\n *\n * ## Example\n *\n * Count the number of click events\n *\n * ```ts\n * import { fromEvent, map, mergeScan, of } from 'rxjs';\n *\n * const click$ = fromEvent(document, 'click');\n * const one$ = click$.pipe(map(() => 1));\n * const seed = 0;\n * const count$ = one$.pipe(\n *   mergeScan((acc, one) => of(acc + one), seed)\n * );\n *\n * count$.subscribe(x => console.log(x));\n *\n * // Results:\n * // 1\n * // 2\n * // 3\n * // 4\n * // ...and so on for each click\n * ```\n *\n * @see {@link scan}\n * @see {@link switchScan}\n *\n * @param {function(acc: R, value: T): Observable<R>} accumulator\n * The accumulator function called on each source value.\n * @param seed The initial accumulation value.\n * @param {number} [concurrent=Infinity] Maximum number of\n * input Observables being subscribed to concurrently.\n * @return A function that returns an Observable of the accumulated values.\n */\nexport function mergeScan<T, R>(\n  accumulator: (acc: R, value: T, index: number) => ObservableInput<R>,\n  seed: R,\n  concurrent = Infinity\n): OperatorFunction<T, R> {\n  return operate((source, subscriber) => {\n    // The accumulated state.\n    let state = seed;\n\n    return mergeInternals(\n      source,\n      subscriber,\n      (value, index) => accumulator(state, value, index),\n      concurrent,\n      (value) => {\n        state = value;\n      },\n      false,\n      undefined,\n      () => (state = null!)\n    );\n  });\n}\n","import { ObservableInputTuple, OperatorFunction } from '../types';\nimport { merge } from './merge';\n\n/**\n * Merge the values from all observables to a single observable result.\n *\n * Creates an observable, that when subscribed to, subscribes to the source\n * observable, and all other sources provided as arguments. All values from\n * every source are emitted from the resulting subscription.\n *\n * When all sources complete, the resulting observable will complete.\n *\n * When any source errors, the resulting observable will error.\n *\n * ## Example\n *\n * Joining all outputs from multiple user input event streams\n *\n * ```ts\n * import { fromEvent, map, mergeWith } from 'rxjs';\n *\n * const clicks$ = fromEvent(document, 'click').pipe(map(() => 'click'));\n * const mousemoves$ = fromEvent(document, 'mousemove').pipe(map(() => 'mousemove'));\n * const dblclicks$ = fromEvent(document, 'dblclick').pipe(map(() => 'dblclick'));\n *\n * mousemoves$\n *   .pipe(mergeWith(clicks$, dblclicks$))\n *   .subscribe(x => console.log(x));\n *\n * // result (assuming user interactions)\n * // 'mousemove'\n * // 'mousemove'\n * // 'mousemove'\n * // 'click'\n * // 'click'\n * // 'dblclick'\n * ```\n *\n * @see {@link merge}\n *\n * @param otherSources the sources to combine the current source with.\n * @return A function that returns an Observable that merges the values from\n * all given Observables.\n */\nexport function mergeWith<T, A extends readonly unknown[]>(\n  ...otherSources: [...ObservableInputTuple<A>]\n): OperatorFunction<T, T | A[number]> {\n  return merge(...otherSources);\n}\n","import { reduce } from './reduce';\nimport { MonoTypeOperatorFunction } from '../types';\nimport { isFunction } from '../util/isFunction';\n\n/**\n * The Min operator operates on an Observable that emits numbers (or items that can be compared with a provided function),\n * and when source Observable completes it emits a single item: the item with the smallest value.\n *\n * ![](min.png)\n *\n * ## Examples\n *\n * Get the minimal value of a series of numbers\n *\n * ```ts\n * import { of, min } from 'rxjs';\n *\n * of(5, 4, 7, 2, 8)\n *   .pipe(min())\n *   .subscribe(x => console.log(x));\n *\n * // Outputs\n * // 2\n * ```\n *\n * Use a comparer function to get the minimal item\n *\n * ```ts\n * import { of, min } from 'rxjs';\n *\n * of(\n *   { age: 7, name: 'Foo' },\n *   { age: 5, name: 'Bar' },\n *   { age: 9, name: 'Beer' }\n * ).pipe(\n *   min((a, b) => a.age < b.age ? -1 : 1)\n * )\n * .subscribe(x => console.log(x.name));\n *\n * // Outputs\n * // 'Bar'\n * ```\n *\n * @see {@link max}\n *\n * @param {Function} [comparer] - Optional comparer function that it will use instead of its default to compare the\n * value of two items.\n * @return A function that returns an Observable that emits item with the\n * smallest value.\n */\nexport function min<T>(comparer?: (x: T, y: T) => number): MonoTypeOperatorFunction<T> {\n  return reduce(isFunction(comparer) ? (x, y) => (comparer(x, y) < 0 ? x : y) : (x, y) => (x < y ? x : y));\n}\n","import { Subject } from '../Subject';\nimport { Observable } from '../Observable';\nimport { ConnectableObservable } from '../observable/ConnectableObservable';\nimport { OperatorFunction, UnaryFunction, ObservedValueOf, ObservableInput } from '../types';\nimport { isFunction } from '../util/isFunction';\nimport { connect } from './connect';\n\n/**\n * An operator that creates a {@link ConnectableObservable}, that when connected,\n * with the `connect` method, will use the provided subject to multicast the values\n * from the source to all consumers.\n *\n * @param subject The subject to multicast through.\n * @return A function that returns a {@link ConnectableObservable}\n * @deprecated Will be removed in v8. To create a connectable observable, use {@link connectable}.\n * If you're using {@link refCount} after `multicast`, use the {@link share} operator instead.\n * `multicast(subject), refCount()` is equivalent to\n * `share({ connector: () => subject, resetOnError: false, resetOnComplete: false, resetOnRefCountZero: false })`.\n * Details: https://rxjs.dev/deprecations/multicasting\n */\nexport function multicast<T>(subject: Subject<T>): UnaryFunction<Observable<T>, ConnectableObservable<T>>;\n\n/**\n * Because this is deprecated in favor of the {@link connect} operator, and was otherwise poorly documented,\n * rather than duplicate the effort of documenting the same behavior, please see documentation for the\n * {@link connect} operator.\n *\n * @param subject The subject used to multicast.\n * @param selector A setup function to setup the multicast\n * @return A function that returns an observable that mirrors the observable returned by the selector.\n * @deprecated Will be removed in v8. Use the {@link connect} operator instead.\n * `multicast(subject, selector)` is equivalent to\n * `connect(selector, { connector: () => subject })`.\n * Details: https://rxjs.dev/deprecations/multicasting\n */\nexport function multicast<T, O extends ObservableInput<any>>(\n  subject: Subject<T>,\n  selector: (shared: Observable<T>) => O\n): OperatorFunction<T, ObservedValueOf<O>>;\n\n/**\n * An operator that creates a {@link ConnectableObservable}, that when connected,\n * with the `connect` method, will use the provided subject to multicast the values\n * from the source to all consumers.\n *\n * @param subjectFactory A factory that will be called to create the subject. Passing a function here\n * will cause the underlying subject to be \"reset\" on error, completion, or refCounted unsubscription of\n * the source.\n * @return A function that returns a {@link ConnectableObservable}\n * @deprecated Will be removed in v8. To create a connectable observable, use {@link connectable}.\n * If you're using {@link refCount} after `multicast`, use the {@link share} operator instead.\n * `multicast(() => new BehaviorSubject('test')), refCount()` is equivalent to\n * `share({ connector: () => new BehaviorSubject('test') })`.\n * Details: https://rxjs.dev/deprecations/multicasting\n */\nexport function multicast<T>(subjectFactory: () => Subject<T>): UnaryFunction<Observable<T>, ConnectableObservable<T>>;\n\n/**\n * Because this is deprecated in favor of the {@link connect} operator, and was otherwise poorly documented,\n * rather than duplicate the effort of documenting the same behavior, please see documentation for the\n * {@link connect} operator.\n *\n * @param subjectFactory A factory that creates the subject used to multicast.\n * @param selector A function to setup the multicast and select the output.\n * @return A function that returns an observable that mirrors the observable returned by the selector.\n * @deprecated Will be removed in v8. Use the {@link connect} operator instead.\n * `multicast(subjectFactory, selector)` is equivalent to\n * `connect(selector, { connector: subjectFactory })`.\n * Details: https://rxjs.dev/deprecations/multicasting\n */\nexport function multicast<T, O extends ObservableInput<any>>(\n  subjectFactory: () => Subject<T>,\n  selector: (shared: Observable<T>) => O\n): OperatorFunction<T, ObservedValueOf<O>>;\n\n/**\n * @deprecated Will be removed in v8. Use the {@link connectable} observable, the {@link connect} operator or the\n * {@link share} operator instead. See the overloads below for equivalent replacement examples of this operator's\n * behaviors.\n * Details: https://rxjs.dev/deprecations/multicasting\n */\nexport function multicast<T, R>(\n  subjectOrSubjectFactory: Subject<T> | (() => Subject<T>),\n  selector?: (source: Observable<T>) => Observable<R>\n): OperatorFunction<T, R> {\n  const subjectFactory = isFunction(subjectOrSubjectFactory) ? subjectOrSubjectFactory : () => subjectOrSubjectFactory;\n\n  if (isFunction(selector)) {\n    // If a selector function is provided, then we're a \"normal\" operator that isn't\n    // going to return a ConnectableObservable. We can use `connect` to do what we\n    // need to do.\n    return connect(selector, {\n      connector: subjectFactory,\n    });\n  }\n\n  return (source: Observable<T>) => new ConnectableObservable<any>(source, subjectFactory);\n}\n","/** @prettier */\nimport { MonoTypeOperatorFunction, SchedulerLike } from '../types';\nimport { executeSchedule } from '../util/executeSchedule';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\n/**\n * Re-emits all notifications from source Observable with specified scheduler.\n *\n * <span class=\"informal\">Ensure a specific scheduler is used, from outside of an Observable.</span>\n *\n * `observeOn` is an operator that accepts a scheduler as a first parameter, which will be used to reschedule\n * notifications emitted by the source Observable. It might be useful, if you do not have control over\n * internal scheduler of a given Observable, but want to control when its values are emitted nevertheless.\n *\n * Returned Observable emits the same notifications (nexted values, complete and error events) as the source Observable,\n * but rescheduled with provided scheduler. Note that this doesn't mean that source Observables internal\n * scheduler will be replaced in any way. Original scheduler still will be used, but when the source Observable emits\n * notification, it will be immediately scheduled again - this time with scheduler passed to `observeOn`.\n * An anti-pattern would be calling `observeOn` on Observable that emits lots of values synchronously, to split\n * that emissions into asynchronous chunks. For this to happen, scheduler would have to be passed into the source\n * Observable directly (usually into the operator that creates it). `observeOn` simply delays notifications a\n * little bit more, to ensure that they are emitted at expected moments.\n *\n * As a matter of fact, `observeOn` accepts second parameter, which specifies in milliseconds with what delay notifications\n * will be emitted. The main difference between {@link delay} operator and `observeOn` is that `observeOn`\n * will delay all notifications - including error notifications - while `delay` will pass through error\n * from source Observable immediately when it is emitted. In general it is highly recommended to use `delay` operator\n * for any kind of delaying of values in the stream, while using `observeOn` to specify which scheduler should be used\n * for notification emissions in general.\n *\n * ## Example\n *\n * Ensure values in subscribe are called just before browser repaint\n *\n * ```ts\n * import { interval, observeOn, animationFrameScheduler } from 'rxjs';\n *\n * const someDiv = document.createElement('div');\n * someDiv.style.cssText = 'width: 200px;background: #09c';\n * document.body.appendChild(someDiv);\n * const intervals = interval(10);      // Intervals are scheduled\n *                                      // with async scheduler by default...\n * intervals.pipe(\n *   observeOn(animationFrameScheduler) // ...but we will observe on animationFrame\n * )                                    // scheduler to ensure smooth animation.\n * .subscribe(val => {\n *   someDiv.style.height = val + 'px';\n * });\n * ```\n *\n * @see {@link delay}\n *\n * @param scheduler Scheduler that will be used to reschedule notifications from source Observable.\n * @param delay Number of milliseconds that states with what delay every notification should be rescheduled.\n * @return A function that returns an Observable that emits the same\n * notifications as the source Observable, but with provided scheduler.\n */\nexport function observeOn<T>(scheduler: SchedulerLike, delay = 0): MonoTypeOperatorFunction<T> {\n  return operate((source, subscriber) => {\n    source.subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        (value) => executeSchedule(subscriber, scheduler, () => subscriber.next(value), delay),\n        () => executeSchedule(subscriber, scheduler, () => subscriber.complete(), delay),\n        (err) => executeSchedule(subscriber, scheduler, () => subscriber.error(err), delay)\n      )\n    );\n  });\n}\n","import { ObservableInputTuple, OperatorFunction } from '../types';\nimport { argsOrArgArray } from '../util/argsOrArgArray';\nimport { onErrorResumeNext as oERNCreate } from '../observable/onErrorResumeNext';\n\nexport function onErrorResumeNextWith<T, A extends readonly unknown[]>(\n  sources: [...ObservableInputTuple<A>]\n): OperatorFunction<T, T | A[number]>;\nexport function onErrorResumeNextWith<T, A extends readonly unknown[]>(\n  ...sources: [...ObservableInputTuple<A>]\n): OperatorFunction<T, T | A[number]>;\n\n/**\n * When any of the provided Observable emits an complete or error notification, it immediately subscribes to the next one\n * that was passed.\n *\n * <span class=\"informal\">Execute series of Observables, subscribes to next one on error or complete.</span>\n *\n * ![](onErrorResumeNext.png)\n *\n * `onErrorResumeNext` is an operator that accepts a series of Observables, provided either directly as\n * arguments or as an array. If no single Observable is provided, returned Observable will simply behave the same\n * as the source.\n *\n * `onErrorResumeNext` returns an Observable that starts by subscribing and re-emitting values from the source Observable.\n * When its stream of values ends - no matter if Observable completed or emitted an error - `onErrorResumeNext`\n * will subscribe to the first Observable that was passed as an argument to the method. It will start re-emitting\n * its values as well and - again - when that stream ends, `onErrorResumeNext` will proceed to subscribing yet another\n * Observable in provided series, no matter if previous Observable completed or ended with an error. This will\n * be happening until there is no more Observables left in the series, at which point returned Observable will\n * complete - even if the last subscribed stream ended with an error.\n *\n * `onErrorResumeNext` can be therefore thought of as version of {@link concat} operator, which is more permissive\n * when it comes to the errors emitted by its input Observables. While `concat` subscribes to the next Observable\n * in series only if previous one successfully completed, `onErrorResumeNext` subscribes even if it ended with\n * an error.\n *\n * Note that you do not get any access to errors emitted by the Observables. In particular do not\n * expect these errors to appear in error callback passed to {@link Observable#subscribe}. If you want to take\n * specific actions based on what error was emitted by an Observable, you should try out {@link catchError} instead.\n *\n *\n * ## Example\n *\n * Subscribe to the next Observable after map fails\n *\n * ```ts\n * import { of, onErrorResumeNext, map } from 'rxjs';\n *\n * of(1, 2, 3, 0)\n *   .pipe(\n *     map(x => {\n *       if (x === 0) {\n *         throw Error();\n *       }\n *\n *       return 10 / x;\n *     }),\n *     onErrorResumeNext(of(1, 2, 3))\n *   )\n *   .subscribe({\n *     next: val => console.log(val),\n *     error: err => console.log(err),          // Will never be called.\n *     complete: () => console.log('that\\'s it!')\n *   });\n *\n * // Logs:\n * // 10\n * // 5\n * // 3.3333333333333335\n * // 1\n * // 2\n * // 3\n * // 'that's it!'\n * ```\n *\n * @see {@link concat}\n * @see {@link catchError}\n *\n * @param {...ObservableInput} sources Observables passed either directly or as an array.\n * @return A function that returns an Observable that emits values from source\n * Observable, but - if it errors - subscribes to the next passed Observable\n * and so on, until it completes or runs out of Observables.\n */\nexport function onErrorResumeNextWith<T, A extends readonly unknown[]>(\n  ...sources: [[...ObservableInputTuple<A>]] | [...ObservableInputTuple<A>]\n): OperatorFunction<T, T | A[number]> {\n  // For some reason, TS 4.1 RC gets the inference wrong here and infers the\n  // result to be `A[number][]` - completely dropping the ObservableInput part\n  // of the type. This makes no sense whatsoever. As a workaround, the type is\n  // asserted explicitly.\n  const nextSources = argsOrArgArray(sources) as unknown as ObservableInputTuple<A>;\n\n  return (source) => oERNCreate(source, ...nextSources);\n}\n\n/**\n * @deprecated Renamed. Use {@link onErrorResumeNextWith} instead. Will be removed in v8.\n */\nexport const onErrorResumeNext = onErrorResumeNextWith;\n","import { OperatorFunction } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\n/**\n * Groups pairs of consecutive emissions together and emits them as an array of\n * two values.\n *\n * <span class=\"informal\">Puts the current value and previous value together as\n * an array, and emits that.</span>\n *\n * ![](pairwise.png)\n *\n * The Nth emission from the source Observable will cause the output Observable\n * to emit an array [(N-1)th, Nth] of the previous and the current value, as a\n * pair. For this reason, `pairwise` emits on the second and subsequent\n * emissions from the source Observable, but not on the first emission, because\n * there is no previous value in that case.\n *\n * ## Example\n *\n * On every click (starting from the second), emit the relative distance to the previous click\n *\n * ```ts\n * import { fromEvent, pairwise, map } from 'rxjs';\n *\n * const clicks = fromEvent<PointerEvent>(document, 'click');\n * const pairs = clicks.pipe(pairwise());\n * const distance = pairs.pipe(\n *   map(([first, second]) => {\n *     const x0 = first.clientX;\n *     const y0 = first.clientY;\n *     const x1 = second.clientX;\n *     const y1 = second.clientY;\n *     return Math.sqrt(Math.pow(x0 - x1, 2) + Math.pow(y0 - y1, 2));\n *   })\n * );\n *\n * distance.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link buffer}\n * @see {@link bufferCount}\n *\n * @return A function that returns an Observable of pairs (as arrays) of\n * consecutive values from the source Observable.\n */\nexport function pairwise<T>(): OperatorFunction<T, [T, T]> {\n  return operate((source, subscriber) => {\n    let prev: T;\n    let hasPrev = false;\n    source.subscribe(\n      createOperatorSubscriber(subscriber, (value) => {\n        const p = prev;\n        prev = value;\n        hasPrev && subscriber.next([p, value]);\n        hasPrev = true;\n      })\n    );\n  });\n}\n","import { map } from './map';\nimport { OperatorFunction } from '../types';\n\n/* tslint:disable:max-line-length */\n/** @deprecated Use {@link map} and optional chaining: `pluck('foo', 'bar')` is `map(x => x?.foo?.bar)`. Will be removed in v8. */\nexport function pluck<T, K1 extends keyof T>(k1: K1): OperatorFunction<T, T[K1]>;\n/** @deprecated Use {@link map} and optional chaining: `pluck('foo', 'bar')` is `map(x => x?.foo?.bar)`. Will be removed in v8. */\nexport function pluck<T, K1 extends keyof T, K2 extends keyof T[K1]>(k1: K1, k2: K2): OperatorFunction<T, T[K1][K2]>;\n/** @deprecated Use {@link map} and optional chaining: `pluck('foo', 'bar')` is `map(x => x?.foo?.bar)`. Will be removed in v8. */\nexport function pluck<T, K1 extends keyof T, K2 extends keyof T[K1], K3 extends keyof T[K1][K2]>(\n  k1: K1,\n  k2: K2,\n  k3: K3\n): OperatorFunction<T, T[K1][K2][K3]>;\n/** @deprecated Use {@link map} and optional chaining: `pluck('foo', 'bar')` is `map(x => x?.foo?.bar)`. Will be removed in v8. */\nexport function pluck<T, K1 extends keyof T, K2 extends keyof T[K1], K3 extends keyof T[K1][K2], K4 extends keyof T[K1][K2][K3]>(\n  k1: K1,\n  k2: K2,\n  k3: K3,\n  k4: K4\n): OperatorFunction<T, T[K1][K2][K3][K4]>;\n/** @deprecated Use {@link map} and optional chaining: `pluck('foo', 'bar')` is `map(x => x?.foo?.bar)`. Will be removed in v8. */\nexport function pluck<\n  T,\n  K1 extends keyof T,\n  K2 extends keyof T[K1],\n  K3 extends keyof T[K1][K2],\n  K4 extends keyof T[K1][K2][K3],\n  K5 extends keyof T[K1][K2][K3][K4]\n>(k1: K1, k2: K2, k3: K3, k4: K4, k5: K5): OperatorFunction<T, T[K1][K2][K3][K4][K5]>;\n/** @deprecated Use {@link map} and optional chaining: `pluck('foo', 'bar')` is `map(x => x?.foo?.bar)`. Will be removed in v8. */\nexport function pluck<\n  T,\n  K1 extends keyof T,\n  K2 extends keyof T[K1],\n  K3 extends keyof T[K1][K2],\n  K4 extends keyof T[K1][K2][K3],\n  K5 extends keyof T[K1][K2][K3][K4],\n  K6 extends keyof T[K1][K2][K3][K4][K5]\n>(k1: K1, k2: K2, k3: K3, k4: K4, k5: K5, k6: K6): OperatorFunction<T, T[K1][K2][K3][K4][K5][K6]>;\n/** @deprecated Use {@link map} and optional chaining: `pluck('foo', 'bar')` is `map(x => x?.foo?.bar)`. Will be removed in v8. */\nexport function pluck<\n  T,\n  K1 extends keyof T,\n  K2 extends keyof T[K1],\n  K3 extends keyof T[K1][K2],\n  K4 extends keyof T[K1][K2][K3],\n  K5 extends keyof T[K1][K2][K3][K4],\n  K6 extends keyof T[K1][K2][K3][K4][K5]\n>(k1: K1, k2: K2, k3: K3, k4: K4, k5: K5, k6: K6, ...rest: string[]): OperatorFunction<T, unknown>;\n/** @deprecated Use {@link map} and optional chaining: `pluck('foo', 'bar')` is `map(x => x?.foo?.bar)`. Will be removed in v8. */\nexport function pluck<T>(...properties: string[]): OperatorFunction<T, unknown>;\n/* tslint:enable:max-line-length */\n\n/**\n * Maps each source value to its specified nested property.\n *\n * <span class=\"informal\">Like {@link map}, but meant only for picking one of\n * the nested properties of every emitted value.</span>\n *\n * ![](pluck.png)\n *\n * Given a list of strings or numbers describing a path to a property, retrieves\n * the value of a specified nested property from all values in the source\n * Observable. If a property can't be resolved, it will return `undefined` for\n * that value.\n *\n * ## Example\n *\n * Map every click to the tagName of the clicked target element\n *\n * ```ts\n * import { fromEvent, pluck } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const tagNames = clicks.pipe(pluck('target', 'tagName'));\n *\n * tagNames.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link map}\n *\n * @param properties The nested properties to pluck from each source\n * value.\n * @return A function that returns an Observable of property values from the\n * source values.\n * @deprecated Use {@link map} and optional chaining: `pluck('foo', 'bar')` is `map(x => x?.foo?.bar)`. Will be removed in v8.\n */\nexport function pluck<T, R>(...properties: Array<string | number | symbol>): OperatorFunction<T, R> {\n  const length = properties.length;\n  if (length === 0) {\n    throw new Error('list of properties cannot be empty.');\n  }\n  return map((x) => {\n    let currentProp: any = x;\n    for (let i = 0; i < length; i++) {\n      const p = currentProp?.[properties[i]];\n      if (typeof p !== 'undefined') {\n        currentProp = p;\n      } else {\n        return undefined;\n      }\n    }\n    return currentProp;\n  });\n}\n","import { Observable } from '../Observable';\nimport { Subject } from '../Subject';\nimport { multicast } from './multicast';\nimport { ConnectableObservable } from '../observable/ConnectableObservable';\nimport { MonoTypeOperatorFunction, OperatorFunction, UnaryFunction, ObservableInput, ObservedValueOf } from '../types';\nimport { connect } from './connect';\n\n/**\n * Returns a connectable observable that, when connected, will multicast\n * all values through a single underlying {@link Subject} instance.\n *\n * @deprecated Will be removed in v8. To create a connectable observable, use {@link connectable}.\n * `source.pipe(publish())` is equivalent to\n * `connectable(source, { connector: () => new Subject(), resetOnDisconnect: false })`.\n * If you're using {@link refCount} after `publish`, use {@link share} operator instead.\n * `source.pipe(publish(), refCount())` is equivalent to\n * `source.pipe(share({ resetOnError: false, resetOnComplete: false, resetOnRefCountZero: false }))`.\n * Details: https://rxjs.dev/deprecations/multicasting\n */\nexport function publish<T>(): UnaryFunction<Observable<T>, ConnectableObservable<T>>;\n\n/**\n * Returns an observable, that when subscribed to, creates an underlying {@link Subject},\n * provides an observable view of it to a `selector` function, takes the observable result of\n * that selector function and subscribes to it, sending its values to the consumer, _then_ connects\n * the subject to the original source.\n *\n * @param selector A function used to setup multicasting prior to automatic connection.\n *\n * @deprecated Will be removed in v8. Use the {@link connect} operator instead.\n * `publish(selector)` is equivalent to `connect(selector)`.\n * Details: https://rxjs.dev/deprecations/multicasting\n */\nexport function publish<T, O extends ObservableInput<any>>(selector: (shared: Observable<T>) => O): OperatorFunction<T, ObservedValueOf<O>>;\n\n/**\n * Returns a ConnectableObservable, which is a variety of Observable that waits until its connect method is called\n * before it begins emitting items to those Observers that have subscribed to it.\n *\n * <span class=\"informal\">Makes a cold Observable hot</span>\n *\n * ![](publish.png)\n *\n * ## Examples\n *\n * Make `source$` hot by applying `publish` operator, then merge each inner observable into a single one\n * and subscribe\n *\n * ```ts\n * import { zip, interval, of, map, publish, merge, tap } from 'rxjs';\n *\n * const source$ = zip(interval(2000), of(1, 2, 3, 4, 5, 6, 7, 8, 9))\n *   .pipe(map(([, number]) => number));\n *\n * source$\n *   .pipe(\n *     publish(multicasted$ =>\n *       merge(\n *         multicasted$.pipe(tap(x => console.log('Stream 1:', x))),\n *         multicasted$.pipe(tap(x => console.log('Stream 2:', x))),\n *         multicasted$.pipe(tap(x => console.log('Stream 3:', x)))\n *       )\n *     )\n *   )\n *   .subscribe();\n *\n * // Results every two seconds\n * // Stream 1: 1\n * // Stream 2: 1\n * // Stream 3: 1\n * // ...\n * // Stream 1: 9\n * // Stream 2: 9\n * // Stream 3: 9\n * ```\n *\n * @see {@link publishLast}\n * @see {@link publishReplay}\n * @see {@link publishBehavior}\n *\n * @param {Function} [selector] - Optional selector function which can use the multicasted source sequence as many times\n * as needed, without causing multiple subscriptions to the source sequence.\n * Subscribers to the given source will receive all notifications of the source from the time of the subscription on.\n * @return A function that returns a ConnectableObservable that upon connection\n * causes the source Observable to emit items to its Observers.\n * @deprecated Will be removed in v8. Use the {@link connectable} observable, the {@link connect} operator or the\n * {@link share} operator instead. See the overloads below for equivalent replacement examples of this operator's\n * behaviors.\n * Details: https://rxjs.dev/deprecations/multicasting\n */\nexport function publish<T, R>(selector?: OperatorFunction<T, R>): MonoTypeOperatorFunction<T> | OperatorFunction<T, R> {\n  return selector ? (source) => connect(selector)(source) : (source) => multicast(new Subject<T>())(source);\n}\n","import { Observable } from '../Observable';\nimport { BehaviorSubject } from '../BehaviorSubject';\nimport { ConnectableObservable } from '../observable/ConnectableObservable';\nimport { UnaryFunction } from '../types';\n\n/**\n * Creates a {@link ConnectableObservable} that utilizes a {@link BehaviorSubject}.\n *\n * @param initialValue The initial value passed to the {@link BehaviorSubject}.\n * @return A function that returns a {@link ConnectableObservable}\n * @deprecated Will be removed in v8. To create a connectable observable that uses a\n * {@link BehaviorSubject} under the hood, use {@link connectable}.\n * `source.pipe(publishBehavior(initValue))` is equivalent to\n * `connectable(source, { connector: () => new BehaviorSubject(initValue), resetOnDisconnect: false })`.\n * If you're using {@link refCount} after `publishBehavior`, use the {@link share} operator instead.\n * `source.pipe(publishBehavior(initValue), refCount())` is equivalent to\n * `source.pipe(share({ connector: () => new BehaviorSubject(initValue), resetOnError: false, resetOnComplete: false, resetOnRefCountZero: false  }))`.\n * Details: https://rxjs.dev/deprecations/multicasting\n */\nexport function publishBehavior<T>(initialValue: T): UnaryFunction<Observable<T>, ConnectableObservable<T>> {\n  // Note that this has *never* supported the selector function.\n  return (source) => {\n    const subject = new BehaviorSubject<T>(initialValue);\n    return new ConnectableObservable(source, () => subject);\n  };\n}\n","import { Observable } from '../Observable';\nimport { AsyncSubject } from '../AsyncSubject';\nimport { ConnectableObservable } from '../observable/ConnectableObservable';\nimport { UnaryFunction } from '../types';\n\n/**\n * Returns a connectable observable sequence that shares a single subscription to the\n * underlying sequence containing only the last notification.\n *\n * ![](publishLast.png)\n *\n * Similar to {@link publish}, but it waits until the source observable completes and stores\n * the last emitted value.\n * Similarly to {@link publishReplay} and {@link publishBehavior}, this keeps storing the last\n * value even if it has no more subscribers. If subsequent subscriptions happen, they will\n * immediately get that last stored value and complete.\n *\n * ## Example\n *\n * ```ts\n * import { ConnectableObservable, interval, publishLast, tap, take } from 'rxjs';\n *\n * const connectable = <ConnectableObservable<number>>interval(1000)\n *   .pipe(\n *     tap(x => console.log('side effect', x)),\n *     take(3),\n *     publishLast()\n *   );\n *\n * connectable.subscribe({\n *   next: x => console.log('Sub. A', x),\n *   error: err => console.log('Sub. A Error', err),\n *   complete: () => console.log('Sub. A Complete')\n * });\n *\n * connectable.subscribe({\n *   next: x => console.log('Sub. B', x),\n *   error: err => console.log('Sub. B Error', err),\n *   complete: () => console.log('Sub. B Complete')\n * });\n *\n * connectable.connect();\n *\n * // Results:\n * // 'side effect 0'   - after one second\n * // 'side effect 1'   - after two seconds\n * // 'side effect 2'   - after three seconds\n * // 'Sub. A 2'        - immediately after 'side effect 2'\n * // 'Sub. B 2'\n * // 'Sub. A Complete'\n * // 'Sub. B Complete'\n * ```\n *\n * @see {@link ConnectableObservable}\n * @see {@link publish}\n * @see {@link publishReplay}\n * @see {@link publishBehavior}\n *\n * @return A function that returns an Observable that emits elements of a\n * sequence produced by multicasting the source sequence.\n * @deprecated Will be removed in v8. To create a connectable observable with an\n * {@link AsyncSubject} under the hood, use {@link connectable}.\n * `source.pipe(publishLast())` is equivalent to\n * `connectable(source, { connector: () => new AsyncSubject(), resetOnDisconnect: false })`.\n * If you're using {@link refCount} after `publishLast`, use the {@link share} operator instead.\n * `source.pipe(publishLast(), refCount())` is equivalent to\n * `source.pipe(share({ connector: () => new AsyncSubject(), resetOnError: false, resetOnComplete: false, resetOnRefCountZero: false }))`.\n * Details: https://rxjs.dev/deprecations/multicasting\n */\nexport function publishLast<T>(): UnaryFunction<Observable<T>, ConnectableObservable<T>> {\n  // Note that this has *never* supported a selector function like `publish` and `publishReplay`.\n  return (source) => {\n    const subject = new AsyncSubject<T>();\n    return new ConnectableObservable(source, () => subject);\n  };\n}\n","import { Observable } from '../Observable';\nimport { ReplaySubject } from '../ReplaySubject';\nimport { multicast } from './multicast';\nimport { MonoTypeOperatorFunction, OperatorFunction, TimestampProvider, ObservableInput, ObservedValueOf } from '../types';\nimport { isFunction } from '../util/isFunction';\n\n/**\n * Creates a {@link ConnectableObservable} that uses a {@link ReplaySubject}\n * internally.\n *\n * @param bufferSize The buffer size for the underlying {@link ReplaySubject}.\n * @param windowTime The window time for the underlying {@link ReplaySubject}.\n * @param timestampProvider The timestamp provider for the underlying {@link ReplaySubject}.\n * @deprecated Will be removed in v8. To create a connectable observable that uses a\n * {@link ReplaySubject} under the hood, use {@link connectable}.\n * `source.pipe(publishReplay(size, time, scheduler))` is equivalent to\n * `connectable(source, { connector: () => new ReplaySubject(size, time, scheduler), resetOnDisconnect: false })`.\n * If you're using {@link refCount} after `publishReplay`, use the {@link share} operator instead.\n * `publishReplay(size, time, scheduler), refCount()` is equivalent to\n * `share({ connector: () => new ReplaySubject(size, time, scheduler), resetOnError: false, resetOnComplete: false, resetOnRefCountZero: false })`.\n * Details: https://rxjs.dev/deprecations/multicasting\n */\nexport function publishReplay<T>(\n  bufferSize?: number,\n  windowTime?: number,\n  timestampProvider?: TimestampProvider\n): MonoTypeOperatorFunction<T>;\n\n/**\n * Creates an observable, that when subscribed to, will create a {@link ReplaySubject},\n * and pass an observable from it (using [asObservable](api/index/class/Subject#asObservable)) to\n * the `selector` function, which then returns an observable that is subscribed to before\n * \"connecting\" the source to the internal `ReplaySubject`.\n *\n * Since this is deprecated, for additional details see the documentation for {@link connect}.\n *\n * @param bufferSize The buffer size for the underlying {@link ReplaySubject}.\n * @param windowTime The window time for the underlying {@link ReplaySubject}.\n * @param selector A function used to setup the multicast.\n * @param timestampProvider The timestamp provider for the underlying {@link ReplaySubject}.\n * @deprecated Will be removed in v8. Use the {@link connect} operator instead.\n * `source.pipe(publishReplay(size, window, selector, scheduler))` is equivalent to\n * `source.pipe(connect(selector, { connector: () => new ReplaySubject(size, window, scheduler) }))`.\n * Details: https://rxjs.dev/deprecations/multicasting\n */\nexport function publishReplay<T, O extends ObservableInput<any>>(\n  bufferSize: number | undefined,\n  windowTime: number | undefined,\n  selector: (shared: Observable<T>) => O,\n  timestampProvider?: TimestampProvider\n): OperatorFunction<T, ObservedValueOf<O>>;\n\n/**\n * Creates a {@link ConnectableObservable} that uses a {@link ReplaySubject}\n * internally.\n *\n * @param bufferSize The buffer size for the underlying {@link ReplaySubject}.\n * @param windowTime The window time for the underlying {@link ReplaySubject}.\n * @param selector Passing `undefined` here determines that this operator will return a {@link ConnectableObservable}.\n * @param timestampProvider The timestamp provider for the underlying {@link ReplaySubject}.\n * @deprecated Will be removed in v8. To create a connectable observable that uses a\n * {@link ReplaySubject} under the hood, use {@link connectable}.\n * `source.pipe(publishReplay(size, time, scheduler))` is equivalent to\n * `connectable(source, { connector: () => new ReplaySubject(size, time, scheduler), resetOnDisconnect: false })`.\n * If you're using {@link refCount} after `publishReplay`, use the {@link share} operator instead.\n * `publishReplay(size, time, scheduler), refCount()` is equivalent to\n * `share({ connector: () => new ReplaySubject(size, time, scheduler), resetOnError: false, resetOnComplete: false, resetOnRefCountZero: false })`.\n * Details: https://rxjs.dev/deprecations/multicasting\n */\nexport function publishReplay<T, O extends ObservableInput<any>>(\n  bufferSize: number | undefined,\n  windowTime: number | undefined,\n  selector: undefined,\n  timestampProvider: TimestampProvider\n): OperatorFunction<T, ObservedValueOf<O>>;\n\n/**\n * @deprecated Will be removed in v8. Use the {@link connectable} observable, the {@link connect} operator or the\n * {@link share} operator instead. See the overloads below for equivalent replacement examples of this operator's\n * behaviors.\n * Details: https://rxjs.dev/deprecations/multicasting\n */\nexport function publishReplay<T, R>(\n  bufferSize?: number,\n  windowTime?: number,\n  selectorOrScheduler?: TimestampProvider | OperatorFunction<T, R>,\n  timestampProvider?: TimestampProvider\n) {\n  if (selectorOrScheduler && !isFunction(selectorOrScheduler)) {\n    timestampProvider = selectorOrScheduler;\n  }\n  const selector = isFunction(selectorOrScheduler) ? selectorOrScheduler : undefined;\n  // Note, we're passing `selector!` here, because at runtime, `undefined` is an acceptable argument\n  // but it makes our TypeScript signature for `multicast` unhappy (as it should, because it's gross).\n  return (source: Observable<T>) => multicast(new ReplaySubject<T>(bufferSize, windowTime, timestampProvider), selector!)(source);\n}\n","import { OperatorFunction, ObservableInputTuple } from '../types';\nimport { raceInit } from '../observable/race';\nimport { operate } from '../util/lift';\nimport { identity } from '../util/identity';\n\n/**\n * Creates an Observable that mirrors the first source Observable to emit a next,\n * error or complete notification from the combination of the Observable to which\n * the operator is applied and supplied Observables.\n *\n * ## Example\n *\n * ```ts\n * import { interval, map, raceWith } from 'rxjs';\n *\n * const obs1 = interval(7000).pipe(map(() => 'slow one'));\n * const obs2 = interval(3000).pipe(map(() => 'fast one'));\n * const obs3 = interval(5000).pipe(map(() => 'medium one'));\n *\n * obs1\n *   .pipe(raceWith(obs2, obs3))\n *   .subscribe(winner => console.log(winner));\n *\n * // Outputs\n * // a series of 'fast one'\n * ```\n *\n * @param otherSources Sources used to race for which Observable emits first.\n * @return A function that returns an Observable that mirrors the output of the\n * first Observable to emit an item.\n */\nexport function raceWith<T, A extends readonly unknown[]>(\n  ...otherSources: [...ObservableInputTuple<A>]\n): OperatorFunction<T, T | A[number]> {\n  return !otherSources.length\n    ? identity\n    : operate((source, subscriber) => {\n        raceInit<T | A[number]>([source, ...otherSources])(subscriber);\n      });\n}\n","import { scanInternals } from './scanInternals';\nimport { OperatorFunction } from '../types';\nimport { operate } from '../util/lift';\n\nexport function reduce<V, A = V>(accumulator: (acc: A | V, value: V, index: number) => A): OperatorFunction<V, V | A>;\nexport function reduce<V, A>(accumulator: (acc: A, value: V, index: number) => A, seed: A): OperatorFunction<V, A>;\nexport function reduce<V, A, S = A>(accumulator: (acc: A | S, value: V, index: number) => A, seed: S): OperatorFunction<V, A>;\n\n/**\n * Applies an accumulator function over the source Observable, and returns the\n * accumulated result when the source completes, given an optional seed value.\n *\n * <span class=\"informal\">Combines together all values emitted on the source,\n * using an accumulator function that knows how to join a new source value into\n * the accumulation from the past.</span>\n *\n * ![](reduce.png)\n *\n * Like\n * [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce),\n * `reduce` applies an `accumulator` function against an accumulation and each\n * value of the source Observable (from the past) to reduce it to a single\n * value, emitted on the output Observable. Note that `reduce` will only emit\n * one value, only when the source Observable completes. It is equivalent to\n * applying operator {@link scan} followed by operator {@link last}.\n *\n * Returns an Observable that applies a specified `accumulator` function to each\n * item emitted by the source Observable. If a `seed` value is specified, then\n * that value will be used as the initial value for the accumulator. If no seed\n * value is specified, the first item of the source is used as the seed.\n *\n * ## Example\n *\n * Count the number of click events that happened in 5 seconds\n *\n * ```ts\n * import { fromEvent, takeUntil, interval, map, reduce } from 'rxjs';\n *\n * const clicksInFiveSeconds = fromEvent(document, 'click')\n *   .pipe(takeUntil(interval(5000)));\n *\n * const ones = clicksInFiveSeconds.pipe(map(() => 1));\n * const seed = 0;\n * const count = ones.pipe(reduce((acc, one) => acc + one, seed));\n *\n * count.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link count}\n * @see {@link expand}\n * @see {@link mergeScan}\n * @see {@link scan}\n *\n * @param {function(acc: A, value: V, index: number): A} accumulator The accumulator function\n * called on each source value.\n * @param {A} [seed] The initial accumulation value.\n * @return A function that returns an Observable that emits a single value that\n * is the result of accumulating the values emitted by the source Observable.\n */\nexport function reduce<V, A>(accumulator: (acc: V | A, value: V, index: number) => A, seed?: any): OperatorFunction<V, V | A> {\n  return operate(scanInternals(accumulator, seed, arguments.length >= 2, false, true));\n}\n","import { ConnectableObservable } from '../observable/ConnectableObservable';\nimport { Subscription } from '../Subscription';\nimport { MonoTypeOperatorFunction } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\n/**\n * Make a {@link ConnectableObservable} behave like a ordinary observable and automates the way\n * you can connect to it.\n *\n * Internally it counts the subscriptions to the observable and subscribes (only once) to the source if\n * the number of subscriptions is larger than 0. If the number of subscriptions is smaller than 1, it\n * unsubscribes from the source. This way you can make sure that everything before the *published*\n * refCount has only a single subscription independently of the number of subscribers to the target\n * observable.\n *\n * Note that using the {@link share} operator is exactly the same as using the `multicast(() => new Subject())` operator\n * (making the observable hot) and the *refCount* operator in a sequence.\n *\n * ![](refCount.png)\n *\n * ## Example\n *\n * In the following example there are two intervals turned into connectable observables\n * by using the *publish* operator. The first one uses the *refCount* operator, the\n * second one does not use it. You will notice that a connectable observable does nothing\n * until you call its connect function.\n *\n * ```ts\n * import { interval, tap, publish, refCount } from 'rxjs';\n *\n * // Turn the interval observable into a ConnectableObservable (hot)\n * const refCountInterval = interval(400).pipe(\n *   tap(num => console.log(`refCount ${ num }`)),\n *   publish(),\n *   refCount()\n * );\n *\n * const publishedInterval = interval(400).pipe(\n *   tap(num => console.log(`publish ${ num }`)),\n *   publish()\n * );\n *\n * refCountInterval.subscribe();\n * refCountInterval.subscribe();\n * // 'refCount 0' -----> 'refCount 1' -----> etc\n * // All subscriptions will receive the same value and the tap (and\n * // every other operator) before the `publish` operator will be executed\n * // only once per event independently of the number of subscriptions.\n *\n * publishedInterval.subscribe();\n * // Nothing happens until you call .connect() on the observable.\n * ```\n *\n * @return A function that returns an Observable that automates the connection\n * to ConnectableObservable.\n * @see {@link ConnectableObservable}\n * @see {@link share}\n * @see {@link publish}\n * @deprecated Replaced with the {@link share} operator. How `share` is used\n * will depend on the connectable observable you created just prior to the\n * `refCount` operator.\n * Details: https://rxjs.dev/deprecations/multicasting\n */\nexport function refCount<T>(): MonoTypeOperatorFunction<T> {\n  return operate((source, subscriber) => {\n    let connection: Subscription | null = null;\n\n    (source as any)._refCount++;\n\n    const refCounter = createOperatorSubscriber(subscriber, undefined, undefined, undefined, () => {\n      if (!source || (source as any)._refCount <= 0 || 0 < --(source as any)._refCount) {\n        connection = null;\n        return;\n      }\n\n      ///\n      // Compare the local RefCountSubscriber's connection Subscription to the\n      // connection Subscription on the shared ConnectableObservable. In cases\n      // where the ConnectableObservable source synchronously emits values, and\n      // the RefCountSubscriber's downstream Observers synchronously unsubscribe,\n      // execution continues to here before the RefCountOperator has a chance to\n      // supply the RefCountSubscriber with the shared connection Subscription.\n      // For example:\n      // ```\n      // range(0, 10).pipe(\n      //   publish(),\n      //   refCount(),\n      //   take(5),\n      // )\n      // .subscribe();\n      // ```\n      // In order to account for this case, RefCountSubscriber should only dispose\n      // the ConnectableObservable's shared connection Subscription if the\n      // connection Subscription exists, *and* either:\n      //   a. RefCountSubscriber doesn't have a reference to the shared connection\n      //      Subscription yet, or,\n      //   b. RefCountSubscriber's connection Subscription reference is identical\n      //      to the shared connection Subscription\n      ///\n\n      const sharedConnection = (source as any)._connection;\n      const conn = connection;\n      connection = null;\n\n      if (sharedConnection && (!conn || sharedConnection === conn)) {\n        sharedConnection.unsubscribe();\n      }\n\n      subscriber.unsubscribe();\n    });\n\n    source.subscribe(refCounter);\n\n    if (!refCounter.closed) {\n      connection = (source as ConnectableObservable<T>).connect();\n    }\n  });\n}\n","import { Subscription } from '../Subscription';\nimport { EMPTY } from '../observable/empty';\nimport { operate } from '../util/lift';\nimport { MonoTypeOperatorFunction, ObservableInput } from '../types';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nimport { innerFrom } from '../observable/innerFrom';\nimport { timer } from '../observable/timer';\n\nexport interface RepeatConfig {\n  /**\n   * The number of times to repeat the source. Defaults to `Infinity`.\n   */\n  count?: number;\n\n  /**\n   * If a `number`, will delay the repeat of the source by that number of milliseconds.\n   * If a function, it will provide the number of times the source has been subscribed to,\n   * and the return value should be a valid observable input that will notify when the source\n   * should be repeated. If the notifier observable is empty, the result will complete.\n   */\n  delay?: number | ((count: number) => ObservableInput<any>);\n}\n\n/**\n * Returns an Observable that will resubscribe to the source stream when the source stream completes.\n *\n * <span class=\"informal\">Repeats all values emitted on the source. It's like {@link retry}, but for non error cases.</span>\n *\n * ![](repeat.png)\n *\n * Repeat will output values from a source until the source completes, then it will resubscribe to the\n * source a specified number of times, with a specified delay. Repeat can be particularly useful in\n * combination with closing operators like {@link take}, {@link takeUntil}, {@link first}, or {@link takeWhile},\n * as it can be used to restart a source again from scratch.\n *\n * Repeat is very similar to {@link retry}, where {@link retry} will resubscribe to the source in the error case, but\n * `repeat` will resubscribe if the source completes.\n *\n * Note that `repeat` will _not_ catch errors. Use {@link retry} for that.\n *\n * - `repeat(0)` returns an empty observable\n * - `repeat()` will repeat forever\n * - `repeat({ delay: 200 })` will repeat forever, with a delay of 200ms between repetitions.\n * - `repeat({ count: 2, delay: 400 })` will repeat twice, with a delay of 400ms between repetitions.\n * - `repeat({ delay: (count) => timer(count * 1000) })` will repeat forever, but will have a delay that grows by one second for each repetition.\n *\n * ## Example\n *\n * Repeat a message stream\n *\n * ```ts\n * import { of, repeat } from 'rxjs';\n *\n * const source = of('Repeat message');\n * const result = source.pipe(repeat(3));\n *\n * result.subscribe(x => console.log(x));\n *\n * // Results\n * // 'Repeat message'\n * // 'Repeat message'\n * // 'Repeat message'\n * ```\n *\n * Repeat 3 values, 2 times\n *\n * ```ts\n * import { interval, take, repeat } from 'rxjs';\n *\n * const source = interval(1000);\n * const result = source.pipe(take(3), repeat(2));\n *\n * result.subscribe(x => console.log(x));\n *\n * // Results every second\n * // 0\n * // 1\n * // 2\n * // 0\n * // 1\n * // 2\n * ```\n *\n * Defining two complex repeats with delays on the same source.\n * Note that the second repeat cannot be called until the first\n * repeat as exhausted it's count.\n *\n * ```ts\n * import { defer, of, repeat } from 'rxjs';\n *\n * const source = defer(() => {\n *    return of(`Hello, it is ${new Date()}`)\n * });\n *\n * source.pipe(\n *    // Repeat 3 times with a delay of 1 second between repetitions\n *    repeat({\n *      count: 3,\n *      delay: 1000,\n *    }),\n *\n *    // *Then* repeat forever, but with an exponential step-back\n *    // maxing out at 1 minute.\n *    repeat({\n *      delay: (count) => timer(Math.min(60000, 2 ^ count * 1000))\n *    })\n * )\n * ```\n *\n * @see {@link repeatWhen}\n * @see {@link retry}\n *\n * @param count The number of times the source Observable items are repeated, a count of 0 will yield\n * an empty Observable.\n */\nexport function repeat<T>(countOrConfig?: number | RepeatConfig): MonoTypeOperatorFunction<T> {\n  let count = Infinity;\n  let delay: RepeatConfig['delay'];\n\n  if (countOrConfig != null) {\n    if (typeof countOrConfig === 'object') {\n      ({ count = Infinity, delay } = countOrConfig);\n    } else {\n      count = countOrConfig;\n    }\n  }\n\n  return count <= 0\n    ? () => EMPTY\n    : operate((source, subscriber) => {\n        let soFar = 0;\n        let sourceSub: Subscription | null;\n\n        const resubscribe = () => {\n          sourceSub?.unsubscribe();\n          sourceSub = null;\n          if (delay != null) {\n            const notifier = typeof delay === 'number' ? timer(delay) : innerFrom(delay(soFar));\n            const notifierSubscriber = createOperatorSubscriber(subscriber, () => {\n              notifierSubscriber.unsubscribe();\n              subscribeToSource();\n            });\n            notifier.subscribe(notifierSubscriber);\n          } else {\n            subscribeToSource();\n          }\n        };\n\n        const subscribeToSource = () => {\n          let syncUnsub = false;\n          sourceSub = source.subscribe(\n            createOperatorSubscriber(subscriber, undefined, () => {\n              if (++soFar < count) {\n                if (sourceSub) {\n                  resubscribe();\n                } else {\n                  syncUnsub = true;\n                }\n              } else {\n                subscriber.complete();\n              }\n            })\n          );\n\n          if (syncUnsub) {\n            resubscribe();\n          }\n        };\n\n        subscribeToSource();\n      });\n}\n","import { Observable } from '../Observable';\nimport { innerFrom } from '../observable/innerFrom';\nimport { Subject } from '../Subject';\nimport { Subscription } from '../Subscription';\n\nimport { MonoTypeOperatorFunction, ObservableInput } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\n/**\n * Returns an Observable that mirrors the source Observable with the exception of a `complete`. If the source\n * Observable calls `complete`, this method will emit to the Observable returned from `notifier`. If that Observable\n * calls `complete` or `error`, then this method will call `complete` or `error` on the child subscription. Otherwise\n * this method will resubscribe to the source Observable.\n *\n * ![](repeatWhen.png)\n *\n * ## Example\n *\n * Repeat a message stream on click\n *\n * ```ts\n * import { of, fromEvent, repeatWhen } from 'rxjs';\n *\n * const source = of('Repeat message');\n * const documentClick$ = fromEvent(document, 'click');\n *\n * const result = source.pipe(repeatWhen(() => documentClick$));\n *\n * result.subscribe(data => console.log(data))\n * ```\n *\n * @see {@link repeat}\n * @see {@link retry}\n * @see {@link retryWhen}\n *\n * @param notifier Function that receives an Observable of notifications with\n * which a user can `complete` or `error`, aborting the repetition.\n * @return A function that returns an `ObservableInput` that mirrors the source\n * Observable with the exception of a `complete`.\n * @deprecated Will be removed in v9 or v10. Use {@link repeat}'s {@link RepeatConfig#delay delay} option instead.\n * Instead of `repeatWhen(() => notify$)`, use: `repeat({ delay: () => notify$ })`.\n */\nexport function repeatWhen<T>(notifier: (notifications: Observable<void>) => ObservableInput<any>): MonoTypeOperatorFunction<T> {\n  return operate((source, subscriber) => {\n    let innerSub: Subscription | null;\n    let syncResub = false;\n    let completions$: Subject<void>;\n    let isNotifierComplete = false;\n    let isMainComplete = false;\n\n    /**\n     * Checks to see if we can complete the result, completes it, and returns `true` if it was completed.\n     */\n    const checkComplete = () => isMainComplete && isNotifierComplete && (subscriber.complete(), true);\n    /**\n     * Gets the subject to send errors through. If it doesn't exist,\n     * we know we need to setup the notifier.\n     */\n    const getCompletionSubject = () => {\n      if (!completions$) {\n        completions$ = new Subject();\n\n        // If the call to `notifier` throws, it will be caught by the OperatorSubscriber\n        // In the main subscription -- in `subscribeForRepeatWhen`.\n        innerFrom(notifier(completions$)).subscribe(\n          createOperatorSubscriber(\n            subscriber,\n            () => {\n              if (innerSub) {\n                subscribeForRepeatWhen();\n              } else {\n                // If we don't have an innerSub yet, that's because the inner subscription\n                // call hasn't even returned yet. We've arrived here synchronously.\n                // So we flag that we want to resub, such that we can ensure finalization\n                // happens before we resubscribe.\n                syncResub = true;\n              }\n            },\n            () => {\n              isNotifierComplete = true;\n              checkComplete();\n            }\n          )\n        );\n      }\n      return completions$;\n    };\n\n    const subscribeForRepeatWhen = () => {\n      isMainComplete = false;\n\n      innerSub = source.subscribe(\n        createOperatorSubscriber(subscriber, undefined, () => {\n          isMainComplete = true;\n          // Check to see if we are complete, and complete if so.\n          // If we are not complete. Get the subject. This calls the `notifier` function.\n          // If that function fails, it will throw and `.next()` will not be reached on this\n          // line. The thrown error is caught by the _complete handler in this\n          // `OperatorSubscriber` and handled appropriately.\n          !checkComplete() && getCompletionSubject().next();\n        })\n      );\n\n      if (syncResub) {\n        // Ensure that the inner subscription is torn down before\n        // moving on to the next subscription in the synchronous case.\n        // If we don't do this here, all inner subscriptions will not be\n        // torn down until the entire observable is done.\n        innerSub.unsubscribe();\n        // It is important to null this out. Not only to free up memory, but\n        // to make sure code above knows we are in a subscribing state to\n        // handle synchronous resubscription.\n        innerSub = null;\n        // We may need to do this multiple times, so reset the flags.\n        syncResub = false;\n        // Resubscribe\n        subscribeForRepeatWhen();\n      }\n    };\n\n    // Start the subscription\n    subscribeForRepeatWhen();\n  });\n}\n","import { MonoTypeOperatorFunction, ObservableInput } from '../types';\nimport { operate } from '../util/lift';\nimport { Subscription } from '../Subscription';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nimport { identity } from '../util/identity';\nimport { timer } from '../observable/timer';\nimport { innerFrom } from '../observable/innerFrom';\n\n/**\n * The {@link retry} operator configuration object. `retry` either accepts a `number`\n * or an object described by this interface.\n */\nexport interface RetryConfig {\n  /**\n   * The maximum number of times to retry. If `count` is omitted, `retry` will try to\n   * resubscribe on errors infinite number of times.\n   */\n  count?: number;\n  /**\n   * The number of milliseconds to delay before retrying, OR a function to\n   * return a notifier for delaying. If a function is given, that function should\n   * return a notifier that, when it emits will retry the source. If the notifier\n   * completes _without_ emitting, the resulting observable will complete without error,\n   * if the notifier errors, the error will be pushed to the result.\n   */\n  delay?: number | ((error: any, retryCount: number) => ObservableInput<any>);\n  /**\n   * Whether or not to reset the retry counter when the retried subscription\n   * emits its first value.\n   */\n  resetOnSuccess?: boolean;\n}\n\nexport function retry<T>(count?: number): MonoTypeOperatorFunction<T>;\nexport function retry<T>(config: RetryConfig): MonoTypeOperatorFunction<T>;\n\n/**\n * Returns an Observable that mirrors the source Observable with the exception of an `error`.\n *\n * If the source Observable calls `error`, this method will resubscribe to the source Observable for a maximum of\n * `count` resubscriptions rather than propagating the `error` call.\n *\n * ![](retry.png)\n *\n * The number of retries is determined by the `count` parameter. It can be set either by passing a number to\n * `retry` function or by setting `count` property when `retry` is configured using {@link RetryConfig}. If\n * `count` is omitted, `retry` will try to resubscribe on errors infinite number of times.\n *\n * Any and all items emitted by the source Observable will be emitted by the resulting Observable, even those\n * emitted during failed subscriptions. For example, if an Observable fails at first but emits `[1, 2]` then\n * succeeds the second time and emits: `[1, 2, 3, 4, 5, complete]` then the complete stream of emissions and\n * notifications would be: `[1, 2, 1, 2, 3, 4, 5, complete]`.\n *\n * ## Example\n *\n * ```ts\n * import { interval, mergeMap, throwError, of, retry } from 'rxjs';\n *\n * const source = interval(1000);\n * const result = source.pipe(\n *   mergeMap(val => val > 5 ? throwError(() => 'Error!') : of(val)),\n *   retry(2) // retry 2 times on error\n * );\n *\n * result.subscribe({\n *   next: value => console.log(value),\n *   error: err => console.log(`${ err }: Retried 2 times then quit!`)\n * });\n *\n * // Output:\n * // 0..1..2..3..4..5..\n * // 0..1..2..3..4..5..\n * // 0..1..2..3..4..5..\n * // 'Error!: Retried 2 times then quit!'\n * ```\n *\n * @see {@link retryWhen}\n *\n * @param configOrCount - Either number of retry attempts before failing or a {@link RetryConfig} object.\n * @return A function that returns an Observable that will resubscribe to the\n * source stream when the source stream errors, at most `count` times.\n */\nexport function retry<T>(configOrCount: number | RetryConfig = Infinity): MonoTypeOperatorFunction<T> {\n  let config: RetryConfig;\n  if (configOrCount && typeof configOrCount === 'object') {\n    config = configOrCount;\n  } else {\n    config = {\n      count: configOrCount as number,\n    };\n  }\n  const { count = Infinity, delay, resetOnSuccess: resetOnSuccess = false } = config;\n\n  return count <= 0\n    ? identity\n    : operate((source, subscriber) => {\n        let soFar = 0;\n        let innerSub: Subscription | null;\n        const subscribeForRetry = () => {\n          let syncUnsub = false;\n          innerSub = source.subscribe(\n            createOperatorSubscriber(\n              subscriber,\n              (value) => {\n                // If we're resetting on success\n                if (resetOnSuccess) {\n                  soFar = 0;\n                }\n                subscriber.next(value);\n              },\n              // Completions are passed through to consumer.\n              undefined,\n              (err) => {\n                if (soFar++ < count) {\n                  // We are still under our retry count\n                  const resub = () => {\n                    if (innerSub) {\n                      innerSub.unsubscribe();\n                      innerSub = null;\n                      subscribeForRetry();\n                    } else {\n                      syncUnsub = true;\n                    }\n                  };\n\n                  if (delay != null) {\n                    // The user specified a retry delay.\n                    // They gave us a number, use a timer, otherwise, it's a function,\n                    // and we're going to call it to get a notifier.\n                    const notifier = typeof delay === 'number' ? timer(delay) : innerFrom(delay(err, soFar));\n                    const notifierSubscriber = createOperatorSubscriber(\n                      subscriber,\n                      () => {\n                        // After we get the first notification, we\n                        // unsubscribe from the notifier, because we don't want anymore\n                        // and we resubscribe to the source.\n                        notifierSubscriber.unsubscribe();\n                        resub();\n                      },\n                      () => {\n                        // The notifier completed without emitting.\n                        // The author is telling us they want to complete.\n                        subscriber.complete();\n                      }\n                    );\n                    notifier.subscribe(notifierSubscriber);\n                  } else {\n                    // There was no notifier given. Just resub immediately.\n                    resub();\n                  }\n                } else {\n                  // We're past our maximum number of retries.\n                  // Just send along the error.\n                  subscriber.error(err);\n                }\n              }\n            )\n          );\n          if (syncUnsub) {\n            innerSub.unsubscribe();\n            innerSub = null;\n            subscribeForRetry();\n          }\n        };\n        subscribeForRetry();\n      });\n}\n","import { Observable } from '../Observable';\nimport { innerFrom } from '../observable/innerFrom';\nimport { Subject } from '../Subject';\nimport { Subscription } from '../Subscription';\n\nimport { MonoTypeOperatorFunction, ObservableInput } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\n/**\n * Returns an Observable that mirrors the source Observable with the exception of an `error`. If the source Observable\n * calls `error`, this method will emit the Throwable that caused the error to the `ObservableInput` returned from `notifier`.\n * If that Observable calls `complete` or `error` then this method will call `complete` or `error` on the child\n * subscription. Otherwise this method will resubscribe to the source Observable.\n *\n * ![](retryWhen.png)\n *\n * Retry an observable sequence on error based on custom criteria.\n *\n * ## Example\n *\n * ```ts\n * import { interval, map, retryWhen, tap, delayWhen, timer } from 'rxjs';\n *\n * const source = interval(1000);\n * const result = source.pipe(\n *   map(value => {\n *     if (value > 5) {\n *       // error will be picked up by retryWhen\n *       throw value;\n *     }\n *     return value;\n *   }),\n *   retryWhen(errors =>\n *     errors.pipe(\n *       // log error message\n *       tap(value => console.log(`Value ${ value } was too high!`)),\n *       // restart in 5 seconds\n *       delayWhen(value => timer(value * 1000))\n *     )\n *   )\n * );\n *\n * result.subscribe(value => console.log(value));\n *\n * // results:\n * // 0\n * // 1\n * // 2\n * // 3\n * // 4\n * // 5\n * // 'Value 6 was too high!'\n * // - Wait 5 seconds then repeat\n * ```\n *\n * @see {@link retry}\n *\n * @param notifier Function that receives an Observable of notifications with which a\n * user can `complete` or `error`, aborting the retry.\n * @return A function that returns an `ObservableInput` that mirrors the source\n * Observable with the exception of an `error`.\n * @deprecated Will be removed in v9 or v10, use {@link retry}'s `delay` option instead.\n * Will be removed in v9 or v10. Use {@link retry}'s {@link RetryConfig#delay delay} option instead.\n * Instead of `retryWhen(() => notify$)`, use: `retry({ delay: () => notify$ })`.\n */\nexport function retryWhen<T>(notifier: (errors: Observable<any>) => ObservableInput<any>): MonoTypeOperatorFunction<T> {\n  return operate((source, subscriber) => {\n    let innerSub: Subscription | null;\n    let syncResub = false;\n    let errors$: Subject<any>;\n\n    const subscribeForRetryWhen = () => {\n      innerSub = source.subscribe(\n        createOperatorSubscriber(subscriber, undefined, undefined, (err) => {\n          if (!errors$) {\n            errors$ = new Subject();\n            innerFrom(notifier(errors$)).subscribe(\n              createOperatorSubscriber(subscriber, () =>\n                // If we have an innerSub, this was an asynchronous call, kick off the retry.\n                // Otherwise, if we don't have an innerSub yet, that's because the inner subscription\n                // call hasn't even returned yet. We've arrived here synchronously.\n                // So we flag that we want to resub, such that we can ensure finalization\n                // happens before we resubscribe.\n                innerSub ? subscribeForRetryWhen() : (syncResub = true)\n              )\n            );\n          }\n          if (errors$) {\n            // We have set up the notifier without error.\n            errors$.next(err);\n          }\n        })\n      );\n\n      if (syncResub) {\n        // Ensure that the inner subscription is torn down before\n        // moving on to the next subscription in the synchronous case.\n        // If we don't do this here, all inner subscriptions will not be\n        // torn down until the entire observable is done.\n        innerSub.unsubscribe();\n        innerSub = null;\n        // We may need to do this multiple times, so reset the flag.\n        syncResub = false;\n        // Resubscribe\n        subscribeForRetryWhen();\n      }\n    };\n\n    // Start the subscription\n    subscribeForRetryWhen();\n  });\n}\n","import { innerFrom } from '../observable/innerFrom';\nimport { MonoTypeOperatorFunction, ObservableInput } from '../types';\nimport { operate } from '../util/lift';\nimport { noop } from '../util/noop';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\n/**\n * Emits the most recently emitted value from the source Observable whenever\n * another Observable, the `notifier`, emits.\n *\n * <span class=\"informal\">It's like {@link sampleTime}, but samples whenever\n * the `notifier` `ObservableInput` emits something.</span>\n *\n * ![](sample.png)\n *\n * Whenever the `notifier` `ObservableInput` emits a value, `sample`\n * looks at the source Observable and emits whichever value it has most recently\n * emitted since the previous sampling, unless the source has not emitted\n * anything since the previous sampling. The `notifier` is subscribed to as soon\n * as the output Observable is subscribed.\n *\n * ## Example\n *\n * On every click, sample the most recent `seconds` timer\n *\n * ```ts\n * import { fromEvent, interval, sample } from 'rxjs';\n *\n * const seconds = interval(1000);\n * const clicks = fromEvent(document, 'click');\n * const result = seconds.pipe(sample(clicks));\n *\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link audit}\n * @see {@link debounce}\n * @see {@link sampleTime}\n * @see {@link throttle}\n *\n * @param notifier The `ObservableInput` to use for sampling the\n * source Observable.\n * @return A function that returns an Observable that emits the results of\n * sampling the values emitted by the source Observable whenever the notifier\n * Observable emits value or completes.\n */\nexport function sample<T>(notifier: ObservableInput<any>): MonoTypeOperatorFunction<T> {\n  return operate((source, subscriber) => {\n    let hasValue = false;\n    let lastValue: T | null = null;\n    source.subscribe(\n      createOperatorSubscriber(subscriber, (value) => {\n        hasValue = true;\n        lastValue = value;\n      })\n    );\n    innerFrom(notifier).subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        () => {\n          if (hasValue) {\n            hasValue = false;\n            const value = lastValue!;\n            lastValue = null;\n            subscriber.next(value);\n          }\n        },\n        noop\n      )\n    );\n  });\n}\n","import { asyncScheduler } from '../scheduler/async';\nimport { MonoTypeOperatorFunction, SchedulerLike } from '../types';\nimport { sample } from './sample';\nimport { interval } from '../observable/interval';\n\n/**\n * Emits the most recently emitted value from the source Observable within\n * periodic time intervals.\n *\n * <span class=\"informal\">Samples the source Observable at periodic time\n * intervals, emitting what it samples.</span>\n *\n * ![](sampleTime.png)\n *\n * `sampleTime` periodically looks at the source Observable and emits whichever\n * value it has most recently emitted since the previous sampling, unless the\n * source has not emitted anything since the previous sampling. The sampling\n * happens periodically in time every `period` milliseconds (or the time unit\n * defined by the optional `scheduler` argument). The sampling starts as soon as\n * the output Observable is subscribed.\n *\n * ## Example\n *\n * Every second, emit the most recent click at most once\n *\n * ```ts\n * import { fromEvent, sampleTime } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(sampleTime(1000));\n *\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link auditTime}\n * @see {@link debounceTime}\n * @see {@link delay}\n * @see {@link sample}\n * @see {@link throttleTime}\n *\n * @param {number} period The sampling period expressed in milliseconds or the\n * time unit determined internally by the optional `scheduler`.\n * @param {SchedulerLike} [scheduler=async] The {@link SchedulerLike} to use for\n * managing the timers that handle the sampling.\n * @return A function that returns an Observable that emits the results of\n * sampling the values emitted by the source Observable at the specified time\n * interval.\n */\nexport function sampleTime<T>(period: number, scheduler: SchedulerLike = asyncScheduler): MonoTypeOperatorFunction<T> {\n  return sample(interval(period, scheduler));\n}\n","import { OperatorFunction } from '../types';\nimport { operate } from '../util/lift';\nimport { scanInternals } from './scanInternals';\n\nexport function scan<V, A = V>(accumulator: (acc: A | V, value: V, index: number) => A): OperatorFunction<V, V | A>;\nexport function scan<V, A>(accumulator: (acc: A, value: V, index: number) => A, seed: A): OperatorFunction<V, A>;\nexport function scan<V, A, S>(accumulator: (acc: A | S, value: V, index: number) => A, seed: S): OperatorFunction<V, A>;\n\n// TODO: link to a \"redux pattern\" section in the guide (location TBD)\n\n/**\n * Useful for encapsulating and managing state. Applies an accumulator (or \"reducer function\")\n * to each value from the source after an initial state is established -- either via\n * a `seed` value (second argument), or from the first value from the source.\n *\n * <span class=\"informal\">It's like {@link reduce}, but emits the current\n * accumulation state after each update</span>\n *\n * ![](scan.png)\n *\n * This operator maintains an internal state and emits it after processing each value as follows:\n *\n * 1. First value arrives\n *   - If a `seed` value was supplied (as the second argument to `scan`), let `state = seed` and `value = firstValue`.\n *   - If NO `seed` value was supplied (no second argument), let `state = firstValue` and go to 3.\n * 2. Let `state = accumulator(state, value)`.\n *   - If an error is thrown by `accumulator`, notify the consumer of an error. The process ends.\n * 3. Emit `state`.\n * 4. Next value arrives, let `value = nextValue`, go to 2.\n *\n * ## Examples\n *\n * An average of previous numbers. This example shows how\n * not providing a `seed` can prime the stream with the\n * first value from the source.\n *\n * ```ts\n * import { of, scan, map } from 'rxjs';\n *\n * const numbers$ = of(1, 2, 3);\n *\n * numbers$\n *   .pipe(\n *     // Get the sum of the numbers coming in.\n *     scan((total, n) => total + n),\n *     // Get the average by dividing the sum by the total number\n *     // received so far (which is 1 more than the zero-based index).\n *     map((sum, index) => sum / (index + 1))\n *   )\n *   .subscribe(console.log);\n * ```\n *\n * The Fibonacci sequence. This example shows how you can use\n * a seed to prime accumulation process. Also... you know... Fibonacci.\n * So important to like, computers and stuff that its whiteboarded\n * in job interviews. Now you can show them the Rx version! (Please don't, haha)\n *\n * ```ts\n * import { interval, scan, map, startWith } from 'rxjs';\n *\n * const firstTwoFibs = [0, 1];\n * // An endless stream of Fibonacci numbers.\n * const fibonacci$ = interval(1000).pipe(\n *   // Scan to get the fibonacci numbers (after 0, 1)\n *   scan(([a, b]) => [b, a + b], firstTwoFibs),\n *   // Get the second number in the tuple, it's the one you calculated\n *   map(([, n]) => n),\n *   // Start with our first two digits :)\n *   startWith(...firstTwoFibs)\n * );\n *\n * fibonacci$.subscribe(console.log);\n * ```\n *\n * @see {@link expand}\n * @see {@link mergeScan}\n * @see {@link reduce}\n * @see {@link switchScan}\n *\n * @param accumulator A \"reducer function\". This will be called for each value after an initial state is\n * acquired.\n * @param seed The initial state. If this is not provided, the first value from the source will\n * be used as the initial state, and emitted without going through the accumulator. All subsequent values\n * will be processed by the accumulator function. If this is provided, all values will go through\n * the accumulator function.\n * @return A function that returns an Observable of the accumulated values.\n */\nexport function scan<V, A, S>(accumulator: (acc: V | A | S, value: V, index: number) => A, seed?: S): OperatorFunction<V, V | A> {\n  // providing a seed of `undefined` *should* be valid and trigger\n  // hasSeed! so don't use `seed !== undefined` checks!\n  // For this reason, we have to check it here at the original call site\n  // otherwise inside Operator/Subscriber we won't know if `undefined`\n  // means they didn't provide anything or if they literally provided `undefined`\n  return operate(scanInternals(accumulator, seed as S, arguments.length >= 2, true));\n}\n","import { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\n/**\n * A basic scan operation. This is used for `scan` and `reduce`.\n * @param accumulator The accumulator to use\n * @param seed The seed value for the state to accumulate\n * @param hasSeed Whether or not a seed was provided\n * @param emitOnNext Whether or not to emit the state on next\n * @param emitBeforeComplete Whether or not to emit the before completion\n */\n\nexport function scanInternals<V, A, S>(\n  accumulator: (acc: V | A | S, value: V, index: number) => A,\n  seed: S,\n  hasSeed: boolean,\n  emitOnNext: boolean,\n  emitBeforeComplete?: undefined | true\n) {\n  return (source: Observable<V>, subscriber: Subscriber<any>) => {\n    // Whether or not we have state yet. This will only be\n    // false before the first value arrives if we didn't get\n    // a seed value.\n    let hasState = hasSeed;\n    // The state that we're tracking, starting with the seed,\n    // if there is one, and then updated by the return value\n    // from the accumulator on each emission.\n    let state: any = seed;\n    // An index to pass to the accumulator function.\n    let index = 0;\n\n    // Subscribe to our source. All errors and completions are passed through.\n    source.subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        (value) => {\n          // Always increment the index.\n          const i = index++;\n          // Set the state\n          state = hasState\n            ? // We already have state, so we can get the new state from the accumulator\n              accumulator(state, value, i)\n            : // We didn't have state yet, a seed value was not provided, so\n\n              // we set the state to the first value, and mark that we have state now\n              ((hasState = true), value);\n\n          // Maybe send it to the consumer.\n          emitOnNext && subscriber.next(state);\n        },\n        // If an onComplete was given, call it, otherwise\n        // just pass through the complete notification to the consumer.\n        emitBeforeComplete &&\n          (() => {\n            hasState && subscriber.next(state);\n            subscriber.complete();\n          })\n      )\n    );\n  };\n}\n","import { OperatorFunction, ObservableInput } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nimport { innerFrom } from '../observable/innerFrom';\n\n/**\n * Compares all values of two observables in sequence using an optional comparator function\n * and returns an observable of a single boolean value representing whether or not the two sequences\n * are equal.\n *\n * <span class=\"informal\">Checks to see of all values emitted by both observables are equal, in order.</span>\n *\n * ![](sequenceEqual.png)\n *\n * `sequenceEqual` subscribes to source observable and `compareTo` `ObservableInput` (that internally\n * gets converted to an observable) and buffers incoming values from each observable. Whenever either\n * observable emits a value, the value is buffered and the buffers are shifted and compared from the bottom\n * up; If any value pair doesn't match, the returned observable will emit `false` and complete. If one of the\n * observables completes, the operator will wait for the other observable to complete; If the other\n * observable emits before completing, the returned observable will emit `false` and complete. If one observable never\n * completes or emits after the other completes, the returned observable will never complete.\n *\n * ## Example\n *\n * Figure out if the Konami code matches\n *\n * ```ts\n * import { from, fromEvent, map, bufferCount, mergeMap, sequenceEqual } from 'rxjs';\n *\n * const codes = from([\n *   'ArrowUp',\n *   'ArrowUp',\n *   'ArrowDown',\n *   'ArrowDown',\n *   'ArrowLeft',\n *   'ArrowRight',\n *   'ArrowLeft',\n *   'ArrowRight',\n *   'KeyB',\n *   'KeyA',\n *   'Enter', // no start key, clearly.\n * ]);\n *\n * const keys = fromEvent<KeyboardEvent>(document, 'keyup').pipe(map(e => e.code));\n * const matches = keys.pipe(\n *   bufferCount(11, 1),\n *   mergeMap(last11 => from(last11).pipe(sequenceEqual(codes)))\n * );\n * matches.subscribe(matched => console.log('Successful cheat at Contra? ', matched));\n * ```\n *\n * @see {@link combineLatest}\n * @see {@link zip}\n * @see {@link withLatestFrom}\n *\n * @param compareTo The `ObservableInput` sequence to compare the source sequence to.\n * @param comparator An optional function to compare each value pair.\n *\n * @return A function that returns an Observable that emits a single boolean\n * value representing whether or not the values emitted by the source\n * Observable and provided `ObservableInput` were equal in sequence.\n */\nexport function sequenceEqual<T>(\n  compareTo: ObservableInput<T>,\n  comparator: (a: T, b: T) => boolean = (a, b) => a === b\n): OperatorFunction<T, boolean> {\n  return operate((source, subscriber) => {\n    // The state for the source observable\n    const aState = createState<T>();\n    // The state for the compareTo observable;\n    const bState = createState<T>();\n\n    /** A utility to emit and complete */\n    const emit = (isEqual: boolean) => {\n      subscriber.next(isEqual);\n      subscriber.complete();\n    };\n\n    /**\n     * Creates a subscriber that subscribes to one of the sources, and compares its collected\n     * state -- `selfState` -- to the other source's collected state -- `otherState`. This\n     * is used for both streams.\n     */\n    const createSubscriber = (selfState: SequenceState<T>, otherState: SequenceState<T>) => {\n      const sequenceEqualSubscriber = createOperatorSubscriber(\n        subscriber,\n        (a: T) => {\n          const { buffer, complete } = otherState;\n          if (buffer.length === 0) {\n            // If there's no values in the other buffer\n            // and the other stream is complete, we know\n            // this isn't a match, because we got one more value.\n            // Otherwise, we push onto our buffer, so when the other\n            // stream emits, it can pull this value off our buffer and check it\n            // at the appropriate time.\n            complete ? emit(false) : selfState.buffer.push(a);\n          } else {\n            // If the other stream *does* have values in its buffer,\n            // pull the oldest one off so we can compare it to what we\n            // just got. If it wasn't a match, emit `false` and complete.\n            !comparator(a, buffer.shift()!) && emit(false);\n          }\n        },\n        () => {\n          // Or observable completed\n          selfState.complete = true;\n          const { complete, buffer } = otherState;\n          // If the other observable is also complete, and there's\n          // still stuff left in their buffer, it doesn't match, if their\n          // buffer is empty, then it does match. This is because we can't\n          // possibly get more values here anymore.\n          complete && emit(buffer.length === 0);\n          // Be sure to clean up our stream as soon as possible if we can.\n          sequenceEqualSubscriber?.unsubscribe();\n        }\n      );\n\n      return sequenceEqualSubscriber;\n    };\n\n    // Subscribe to each source.\n    source.subscribe(createSubscriber(aState, bState));\n    innerFrom(compareTo).subscribe(createSubscriber(bState, aState));\n  });\n}\n\n/**\n * A simple structure for the data used to test each sequence\n */\ninterface SequenceState<T> {\n  /** A temporary store for arrived values before they are checked */\n  buffer: T[];\n  /** Whether or not the sequence source has completed. */\n  complete: boolean;\n}\n\n/**\n * Creates a simple structure that is used to represent\n * data used to test each sequence.\n */\nfunction createState<T>(): SequenceState<T> {\n  return {\n    buffer: [],\n    complete: false,\n  };\n}\n","import { innerFrom } from '../observable/innerFrom';\nimport { Subject } from '../Subject';\nimport { SafeSubscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\nimport { MonoTypeOperatorFunction, SubjectLike, ObservableInput } from '../types';\nimport { operate } from '../util/lift';\n\nexport interface ShareConfig<T> {\n  /**\n   * The factory used to create the subject that will connect the source observable to\n   * multicast consumers.\n   */\n  connector?: () => SubjectLike<T>;\n  /**\n   * If `true`, the resulting observable will reset internal state on error from source and return to a \"cold\" state. This\n   * allows the resulting observable to be \"retried\" in the event of an error.\n   * If `false`, when an error comes from the source it will push the error into the connecting subject, and the subject\n   * will remain the connecting subject, meaning the resulting observable will not go \"cold\" again, and subsequent retries\n   * or resubscriptions will resubscribe to that same subject. In all cases, RxJS subjects will emit the same error again, however\n   * {@link ReplaySubject} will also push its buffered values before pushing the error.\n   * It is also possible to pass a notifier factory returning an `ObservableInput` instead which grants more fine-grained\n   * control over how and when the reset should happen. This allows behaviors like conditional or delayed resets.\n   */\n  resetOnError?: boolean | ((error: any) => ObservableInput<any>);\n  /**\n   * If `true`, the resulting observable will reset internal state on completion from source and return to a \"cold\" state. This\n   * allows the resulting observable to be \"repeated\" after it is done.\n   * If `false`, when the source completes, it will push the completion through the connecting subject, and the subject\n   * will remain the connecting subject, meaning the resulting observable will not go \"cold\" again, and subsequent repeats\n   * or resubscriptions will resubscribe to that same subject.\n   * It is also possible to pass a notifier factory returning an `ObservableInput` instead which grants more fine-grained\n   * control over how and when the reset should happen. This allows behaviors like conditional or delayed resets.\n   */\n  resetOnComplete?: boolean | (() => ObservableInput<any>);\n  /**\n   * If `true`, when the number of subscribers to the resulting observable reaches zero due to those subscribers unsubscribing, the\n   * internal state will be reset and the resulting observable will return to a \"cold\" state. This means that the next\n   * time the resulting observable is subscribed to, a new subject will be created and the source will be subscribed to\n   * again.\n   * If `false`, when the number of subscribers to the resulting observable reaches zero due to unsubscription, the subject\n   * will remain connected to the source, and new subscriptions to the result will be connected through that same subject.\n   * It is also possible to pass a notifier factory returning an `ObservableInput` instead which grants more fine-grained\n   * control over how and when the reset should happen. This allows behaviors like conditional or delayed resets.\n   */\n  resetOnRefCountZero?: boolean | (() => ObservableInput<any>);\n}\n\nexport function share<T>(): MonoTypeOperatorFunction<T>;\n\nexport function share<T>(options: ShareConfig<T>): MonoTypeOperatorFunction<T>;\n\n/**\n * Returns a new Observable that multicasts (shares) the original Observable. As long as there is at least one\n * Subscriber this Observable will be subscribed and emitting data. When all subscribers have unsubscribed it will\n * unsubscribe from the source Observable. Because the Observable is multicasting it makes the stream `hot`.\n * This is an alias for `multicast(() => new Subject()), refCount()`.\n *\n * The subscription to the underlying source Observable can be reset (unsubscribe and resubscribe for new subscribers),\n * if the subscriber count to the shared observable drops to 0, or if the source Observable errors or completes. It is\n * possible to use notifier factories for the resets to allow for behaviors like conditional or delayed resets. Please\n * note that resetting on error or complete of the source Observable does not behave like a transparent retry or restart\n * of the source because the error or complete will be forwarded to all subscribers and their subscription will be\n * closed. Only new subscribers after a reset on error or complete happened will cause a fresh subscription to the\n * source. To achieve transparent retries or restarts pipe the source through appropriate operators before sharing.\n *\n * ![](share.png)\n *\n * ## Example\n *\n * Generate new multicast Observable from the `source` Observable value\n *\n * ```ts\n * import { interval, tap, map, take, share } from 'rxjs';\n *\n * const source = interval(1000).pipe(\n *   tap(x => console.log('Processing: ', x)),\n *   map(x => x * x),\n *   take(6),\n *   share()\n * );\n *\n * source.subscribe(x => console.log('subscription 1: ', x));\n * source.subscribe(x => console.log('subscription 2: ', x));\n *\n * // Logs:\n * // Processing: 0\n * // subscription 1: 0\n * // subscription 2: 0\n * // Processing: 1\n * // subscription 1: 1\n * // subscription 2: 1\n * // Processing: 2\n * // subscription 1: 4\n * // subscription 2: 4\n * // Processing: 3\n * // subscription 1: 9\n * // subscription 2: 9\n * // Processing: 4\n * // subscription 1: 16\n * // subscription 2: 16\n * // Processing: 5\n * // subscription 1: 25\n * // subscription 2: 25\n * ```\n *\n * ## Example with notifier factory: Delayed reset\n *\n * ```ts\n * import { interval, take, share, timer } from 'rxjs';\n *\n * const source = interval(1000).pipe(\n *   take(3),\n *   share({\n *     resetOnRefCountZero: () => timer(1000)\n *   })\n * );\n *\n * const subscriptionOne = source.subscribe(x => console.log('subscription 1: ', x));\n * setTimeout(() => subscriptionOne.unsubscribe(), 1300);\n *\n * setTimeout(() => source.subscribe(x => console.log('subscription 2: ', x)), 1700);\n *\n * setTimeout(() => source.subscribe(x => console.log('subscription 3: ', x)), 5000);\n *\n * // Logs:\n * // subscription 1:  0\n * // (subscription 1 unsubscribes here)\n * // (subscription 2 subscribes here ~400ms later, source was not reset)\n * // subscription 2:  1\n * // subscription 2:  2\n * // (subscription 2 unsubscribes here)\n * // (subscription 3 subscribes here ~2000ms later, source did reset before)\n * // subscription 3:  0\n * // subscription 3:  1\n * // subscription 3:  2\n * ```\n *\n * @see {@link shareReplay}\n *\n * @return A function that returns an Observable that mirrors the source.\n */\nexport function share<T>(options: ShareConfig<T> = {}): MonoTypeOperatorFunction<T> {\n  const { connector = () => new Subject<T>(), resetOnError = true, resetOnComplete = true, resetOnRefCountZero = true } = options;\n  // It's necessary to use a wrapper here, as the _operator_ must be\n  // referentially transparent. Otherwise, it cannot be used in calls to the\n  // static `pipe` function - to create a partial pipeline.\n  //\n  // The _operator function_ - the function returned by the _operator_ - will\n  // not be referentially transparent - as it shares its source - but the\n  // _operator function_ is called when the complete pipeline is composed via a\n  // call to a source observable's `pipe` method - not when the static `pipe`\n  // function is called.\n  return (wrapperSource) => {\n    let connection: SafeSubscriber<T> | undefined;\n    let resetConnection: Subscription | undefined;\n    let subject: SubjectLike<T> | undefined;\n    let refCount = 0;\n    let hasCompleted = false;\n    let hasErrored = false;\n\n    const cancelReset = () => {\n      resetConnection?.unsubscribe();\n      resetConnection = undefined;\n    };\n    // Used to reset the internal state to a \"cold\"\n    // state, as though it had never been subscribed to.\n    const reset = () => {\n      cancelReset();\n      connection = subject = undefined;\n      hasCompleted = hasErrored = false;\n    };\n    const resetAndUnsubscribe = () => {\n      // We need to capture the connection before\n      // we reset (if we need to reset).\n      const conn = connection;\n      reset();\n      conn?.unsubscribe();\n    };\n\n    return operate<T, T>((source, subscriber) => {\n      refCount++;\n      if (!hasErrored && !hasCompleted) {\n        cancelReset();\n      }\n\n      // Create the subject if we don't have one yet. Grab a local reference to\n      // it as well, which avoids non-null assertions when using it and, if we\n      // connect to it now, then error/complete need a reference after it was\n      // reset.\n      const dest = (subject = subject ?? connector());\n\n      // Add the finalization directly to the subscriber - instead of returning it -\n      // so that the handling of the subscriber's unsubscription will be wired\n      // up _before_ the subscription to the source occurs. This is done so that\n      // the assignment to the source connection's `closed` property will be seen\n      // by synchronous firehose sources.\n      subscriber.add(() => {\n        refCount--;\n\n        // If we're resetting on refCount === 0, and it's 0, we only want to do\n        // that on \"unsubscribe\", really. Resetting on error or completion is a different\n        // configuration.\n        if (refCount === 0 && !hasErrored && !hasCompleted) {\n          resetConnection = handleReset(resetAndUnsubscribe, resetOnRefCountZero);\n        }\n      });\n\n      // The following line adds the subscription to the subscriber passed.\n      // Basically, `subscriber === dest.subscribe(subscriber)` is `true`.\n      dest.subscribe(subscriber);\n\n      if (\n        !connection &&\n        // Check this shareReplay is still activate - it can be reset to 0\n        // and be \"unsubscribed\" _before_ it actually subscribes.\n        // If we were to subscribe then, it'd leak and get stuck.\n        refCount > 0\n      ) {\n        // We need to create a subscriber here - rather than pass an observer and\n        // assign the returned subscription to connection - because it's possible\n        // for reentrant subscriptions to the shared observable to occur and in\n        // those situations we want connection to be already-assigned so that we\n        // don't create another connection to the source.\n        connection = new SafeSubscriber({\n          next: (value) => dest.next(value),\n          error: (err) => {\n            hasErrored = true;\n            cancelReset();\n            resetConnection = handleReset(reset, resetOnError, err);\n            dest.error(err);\n          },\n          complete: () => {\n            hasCompleted = true;\n            cancelReset();\n            resetConnection = handleReset(reset, resetOnComplete);\n            dest.complete();\n          },\n        });\n        innerFrom(source).subscribe(connection);\n      }\n    })(wrapperSource);\n  };\n}\n\nfunction handleReset<T extends unknown[] = never[]>(\n  reset: () => void,\n  on: boolean | ((...args: T) => ObservableInput<any>),\n  ...args: T\n): Subscription | undefined {\n  if (on === true) {\n    reset();\n    return;\n  }\n\n  if (on === false) {\n    return;\n  }\n\n  const onSubscriber = new SafeSubscriber({\n    next: () => {\n      onSubscriber.unsubscribe();\n      reset();\n    },\n  });\n\n  return innerFrom(on(...args)).subscribe(onSubscriber);\n}\n","import { ReplaySubject } from '../ReplaySubject';\nimport { MonoTypeOperatorFunction, SchedulerLike } from '../types';\nimport { share } from './share';\n\nexport interface ShareReplayConfig {\n  bufferSize?: number;\n  windowTime?: number;\n  refCount: boolean;\n  scheduler?: SchedulerLike;\n}\n\nexport function shareReplay<T>(config: ShareReplayConfig): MonoTypeOperatorFunction<T>;\nexport function shareReplay<T>(bufferSize?: number, windowTime?: number, scheduler?: SchedulerLike): MonoTypeOperatorFunction<T>;\n\n/**\n * Share source and replay specified number of emissions on subscription.\n *\n * This operator is a specialization of `replay` that connects to a source observable\n * and multicasts through a `ReplaySubject` constructed with the specified arguments.\n * A successfully completed source will stay cached in the `shareReplay`ed observable forever,\n * but an errored source can be retried.\n *\n * ## Why use `shareReplay`?\n *\n * You generally want to use `shareReplay` when you have side-effects or taxing computations\n * that you do not wish to be executed amongst multiple subscribers.\n * It may also be valuable in situations where you know you will have late subscribers to\n * a stream that need access to previously emitted values.\n * This ability to replay values on subscription is what differentiates {@link share} and `shareReplay`.\n *\n * ## Reference counting\n *\n * By default `shareReplay` will use `refCount` of false, meaning that it will _not_ unsubscribe the\n * source when the reference counter drops to zero, i.e. the inner `ReplaySubject` will _not_ be unsubscribed\n * (and potentially run for ever).\n * This is the default as it is expected that `shareReplay` is often used to keep around expensive to setup\n * observables which we want to keep running instead of having to do the expensive setup again.\n *\n * As of RXJS version 6.4.0 a new overload signature was added to allow for manual control over what\n * happens when the operators internal reference counter drops to zero.\n * If `refCount` is true, the source will be unsubscribed from once the reference count drops to zero, i.e.\n * the inner `ReplaySubject` will be unsubscribed. All new subscribers will receive value emissions from a\n * new `ReplaySubject` which in turn will cause a new subscription to the source observable.\n *\n * ## Examples\n *\n * Example with a third subscriber coming late to the party\n *\n * ```ts\n * import { interval, take, shareReplay } from 'rxjs';\n *\n * const shared$ = interval(2000).pipe(\n *   take(6),\n *   shareReplay(3)\n * );\n *\n * shared$.subscribe(x => console.log('sub A: ', x));\n * shared$.subscribe(y => console.log('sub B: ', y));\n *\n * setTimeout(() => {\n *   shared$.subscribe(y => console.log('sub C: ', y));\n * }, 11000);\n *\n * // Logs:\n * // (after ~2000 ms)\n * // sub A: 0\n * // sub B: 0\n * // (after ~4000 ms)\n * // sub A: 1\n * // sub B: 1\n * // (after ~6000 ms)\n * // sub A: 2\n * // sub B: 2\n * // (after ~8000 ms)\n * // sub A: 3\n * // sub B: 3\n * // (after ~10000 ms)\n * // sub A: 4\n * // sub B: 4\n * // (after ~11000 ms, sub C gets the last 3 values)\n * // sub C: 2\n * // sub C: 3\n * // sub C: 4\n * // (after ~12000 ms)\n * // sub A: 5\n * // sub B: 5\n * // sub C: 5\n * ```\n *\n * Example for `refCount` usage\n *\n * ```ts\n * import { Observable, tap, interval, shareReplay, take } from 'rxjs';\n *\n * const log = <T>(name: string, source: Observable<T>) => source.pipe(\n *   tap({\n *     subscribe: () => console.log(`${ name }: subscribed`),\n *     next: value => console.log(`${ name }: ${ value }`),\n *     complete: () => console.log(`${ name }: completed`),\n *     finalize: () => console.log(`${ name }: unsubscribed`)\n *   })\n * );\n *\n * const obs$ = log('source', interval(1000));\n *\n * const shared$ = log('shared', obs$.pipe(\n *   shareReplay({ bufferSize: 1, refCount: true }),\n *   take(2)\n * ));\n *\n * shared$.subscribe(x => console.log('sub A: ', x));\n * shared$.subscribe(y => console.log('sub B: ', y));\n *\n * // PRINTS:\n * // shared: subscribed <-- reference count = 1\n * // source: subscribed\n * // shared: subscribed <-- reference count = 2\n * // source: 0\n * // shared: 0\n * // sub A: 0\n * // shared: 0\n * // sub B: 0\n * // source: 1\n * // shared: 1\n * // sub A: 1\n * // shared: completed <-- take(2) completes the subscription for sub A\n * // shared: unsubscribed <-- reference count = 1\n * // shared: 1\n * // sub B: 1\n * // shared: completed <-- take(2) completes the subscription for sub B\n * // shared: unsubscribed <-- reference count = 0\n * // source: unsubscribed <-- replaySubject unsubscribes from source observable because the reference count dropped to 0 and refCount is true\n *\n * // In case of refCount being false, the unsubscribe is never called on the source and the source would keep on emitting, even if no subscribers\n * // are listening.\n * // source: 2\n * // source: 3\n * // source: 4\n * // ...\n * ```\n *\n * @see {@link publish}\n * @see {@link share}\n * @see {@link publishReplay}\n *\n * @param configOrBufferSize Maximum element count of the replay buffer or {@link ShareReplayConfig configuration}\n * object.\n * @param windowTime Maximum time length of the replay buffer in milliseconds.\n * @param scheduler Scheduler where connected observers within the selector function\n * will be invoked on.\n * @return A function that returns an Observable sequence that contains the\n * elements of a sequence produced by multicasting the source sequence within a\n * selector function.\n */\nexport function shareReplay<T>(\n  configOrBufferSize?: ShareReplayConfig | number,\n  windowTime?: number,\n  scheduler?: SchedulerLike\n): MonoTypeOperatorFunction<T> {\n  let bufferSize: number;\n  let refCount = false;\n  if (configOrBufferSize && typeof configOrBufferSize === 'object') {\n    ({ bufferSize = Infinity, windowTime = Infinity, refCount = false, scheduler } = configOrBufferSize);\n  } else {\n    bufferSize = (configOrBufferSize ?? Infinity) as number;\n  }\n  return share<T>({\n    connector: () => new ReplaySubject(bufferSize, windowTime, scheduler),\n    resetOnError: true,\n    resetOnComplete: false,\n    resetOnRefCountZero: refCount,\n  });\n}\n","import { Observable } from '../Observable';\nimport { EmptyError } from '../util/EmptyError';\n\nimport { MonoTypeOperatorFunction, OperatorFunction, TruthyTypesOf } from '../types';\nimport { SequenceError } from '../util/SequenceError';\nimport { NotFoundError } from '../util/NotFoundError';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\nexport function single<T>(predicate: BooleanConstructor): OperatorFunction<T, TruthyTypesOf<T>>;\nexport function single<T>(predicate?: (value: T, index: number, source: Observable<T>) => boolean): MonoTypeOperatorFunction<T>;\n\n/**\n * Returns an observable that asserts that only one value is\n * emitted from the observable that matches the predicate. If no\n * predicate is provided, then it will assert that the observable\n * only emits one value.\n *\n * In the event that the observable is empty, it will throw an\n * {@link EmptyError}.\n *\n * In the event that two values are found that match the predicate,\n * or when there are two values emitted and no predicate, it will\n * throw a {@link SequenceError}\n *\n * In the event that no values match the predicate, if one is provided,\n * it will throw a {@link NotFoundError}\n *\n * ## Example\n *\n * Expect only `name` beginning with `'B'`\n *\n * ```ts\n * import { of, single } from 'rxjs';\n *\n * const source1 = of(\n *  { name: 'Ben' },\n *  { name: 'Tracy' },\n *  { name: 'Laney' },\n *  { name: 'Lily' }\n * );\n *\n * source1\n *   .pipe(single(x => x.name.startsWith('B')))\n *   .subscribe(x => console.log(x));\n * // Emits 'Ben'\n *\n *\n * const source2 = of(\n *  { name: 'Ben' },\n *  { name: 'Tracy' },\n *  { name: 'Bradley' },\n *  { name: 'Lincoln' }\n * );\n *\n * source2\n *   .pipe(single(x => x.name.startsWith('B')))\n *   .subscribe({ error: err => console.error(err) });\n * // Error emitted: SequenceError('Too many values match')\n *\n *\n * const source3 = of(\n *  { name: 'Laney' },\n *  { name: 'Tracy' },\n *  { name: 'Lily' },\n *  { name: 'Lincoln' }\n * );\n *\n * source3\n *   .pipe(single(x => x.name.startsWith('B')))\n *   .subscribe({ error: err => console.error(err) });\n * // Error emitted: NotFoundError('No values match')\n * ```\n *\n * @see {@link first}\n * @see {@link find}\n * @see {@link findIndex}\n * @see {@link elementAt}\n *\n * @throws {NotFoundError} Delivers an NotFoundError to the Observer's `error`\n * callback if the Observable completes before any `next` notification was sent.\n * @throws {SequenceError} Delivers a SequenceError if more than one value is emitted that matches the\n * provided predicate. If no predicate is provided, will deliver a SequenceError if more\n * than one value comes from the source\n * @param {Function} predicate - A predicate function to evaluate items emitted by the source Observable.\n * @return A function that returns an Observable that emits the single item\n * emitted by the source Observable that matches the predicate.\n */\nexport function single<T>(predicate?: (value: T, index: number, source: Observable<T>) => boolean): MonoTypeOperatorFunction<T> {\n  return operate((source, subscriber) => {\n    let hasValue = false;\n    let singleValue: T;\n    let seenValue = false;\n    let index = 0;\n    source.subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        (value) => {\n          seenValue = true;\n          if (!predicate || predicate(value, index++, source)) {\n            hasValue && subscriber.error(new SequenceError('Too many matching values'));\n            hasValue = true;\n            singleValue = value;\n          }\n        },\n        () => {\n          if (hasValue) {\n            subscriber.next(singleValue);\n            subscriber.complete();\n          } else {\n            subscriber.error(seenValue ? new NotFoundError('No matching values') : new EmptyError());\n          }\n        }\n      )\n    );\n  });\n}\n","import { MonoTypeOperatorFunction } from '../types';\nimport { filter } from './filter';\n\n/**\n * Returns an Observable that skips the first `count` items emitted by the source Observable.\n *\n * ![](skip.png)\n *\n * Skips the values until the sent notifications are equal or less than provided skip count. It raises\n * an error if skip count is equal or more than the actual number of emits and source raises an error.\n *\n * ## Example\n *\n * Skip the values before the emission\n *\n * ```ts\n * import { interval, skip } from 'rxjs';\n *\n * // emit every half second\n * const source = interval(500);\n * // skip the first 10 emitted values\n * const result = source.pipe(skip(10));\n *\n * result.subscribe(value => console.log(value));\n * // output: 10...11...12...13...\n * ```\n *\n * @see {@link last}\n * @see {@link skipWhile}\n * @see {@link skipUntil}\n * @see {@link skipLast}\n *\n * @param {Number} count - The number of times, items emitted by source Observable should be skipped.\n * @return A function that returns an Observable that skips the first `count`\n * values emitted by the source Observable.\n */\nexport function skip<T>(count: number): MonoTypeOperatorFunction<T> {\n  return filter((_, index) => count <= index);\n}\n","import { MonoTypeOperatorFunction } from '../types';\nimport { identity } from '../util/identity';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\n/**\n * Skip a specified number of values before the completion of an observable.\n *\n * ![](skipLast.png)\n *\n * Returns an observable that will emit values as soon as it can, given a number of\n * skipped values. For example, if you `skipLast(3)` on a source, when the source\n * emits its fourth value, the first value the source emitted will finally be emitted\n * from the returned observable, as it is no longer part of what needs to be skipped.\n *\n * All values emitted by the result of `skipLast(N)` will be delayed by `N` emissions,\n * as each value is held in a buffer until enough values have been emitted that that\n * the buffered value may finally be sent to the consumer.\n *\n * After subscribing, unsubscribing will not result in the emission of the buffered\n * skipped values.\n *\n * ## Example\n *\n * Skip the last 2 values of an observable with many values\n *\n * ```ts\n * import { of, skipLast } from 'rxjs';\n *\n * const numbers = of(1, 2, 3, 4, 5);\n * const skipLastTwo = numbers.pipe(skipLast(2));\n * skipLastTwo.subscribe(x => console.log(x));\n *\n * // Results in:\n * // 1 2 3\n * // (4 and 5 are skipped)\n * ```\n *\n * @see {@link skip}\n * @see {@link skipUntil}\n * @see {@link skipWhile}\n * @see {@link take}\n *\n * @param skipCount Number of elements to skip from the end of the source Observable.\n * @return A function that returns an Observable that skips the last `count`\n * values emitted by the source Observable.\n */\nexport function skipLast<T>(skipCount: number): MonoTypeOperatorFunction<T> {\n  return skipCount <= 0\n    ? // For skipCounts less than or equal to zero, we are just mirroring the source.\n      identity\n    : operate((source, subscriber) => {\n        // A ring buffer to hold the values while we wait to see\n        // if we can emit it or it's part of the \"skipped\" last values.\n        // Note that it is the _same size_ as the skip count.\n        let ring: T[] = new Array(skipCount);\n        // The number of values seen so far. This is used to get\n        // the index of the current value when it arrives.\n        let seen = 0;\n        source.subscribe(\n          createOperatorSubscriber(subscriber, (value) => {\n            // Get the index of the value we have right now\n            // relative to all other values we've seen, then\n            // increment `seen`. This ensures we've moved to\n            // the next slot in our ring buffer.\n            const valueIndex = seen++;\n            if (valueIndex < skipCount) {\n              // If we haven't seen enough values to fill our buffer yet,\n              // Then we aren't to a number of seen values where we can\n              // emit anything, so let's just start by filling the ring buffer.\n              ring[valueIndex] = value;\n            } else {\n              // We are traversing over the ring array in such\n              // a way that when we get to the end, we loop back\n              // and go to the start.\n              const index = valueIndex % skipCount;\n              // Pull the oldest value out so we can emit it,\n              // and stuff the new value in it's place.\n              const oldValue = ring[index];\n              ring[index] = value;\n              // Emit the old value. It is important that this happens\n              // after we swap the value in the buffer, if it happens\n              // before we swap the value in the buffer, then a synchronous\n              // source can get the buffer out of whack.\n              subscriber.next(oldValue);\n            }\n          })\n        );\n\n        return () => {\n          // Release our values in memory\n          ring = null!;\n        };\n      });\n}\n","import { MonoTypeOperatorFunction, ObservableInput } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nimport { innerFrom } from '../observable/innerFrom';\nimport { noop } from '../util/noop';\n\n/**\n * Returns an Observable that skips items emitted by the source Observable until a second Observable emits an item.\n *\n * The `skipUntil` operator causes the observable stream to skip the emission of values until the passed in observable\n * emits the first value. This can be particularly useful in combination with user interactions, responses of HTTP\n * requests or waiting for specific times to pass by.\n *\n * ![](skipUntil.png)\n *\n * Internally, the `skipUntil` operator subscribes to the passed in `notifier` `ObservableInput` (which gets converted\n * to an Observable) in order to recognize the emission of its first value. When `notifier` emits next, the operator\n * unsubscribes from it and starts emitting the values of the *source* observable until it completes or errors. It\n * will never let the *source* observable emit any values if the `notifier` completes or throws an error without\n * emitting a value before.\n *\n * ## Example\n *\n * In the following example, all emitted values of the interval observable are skipped until the user clicks anywhere\n * within the page\n *\n * ```ts\n * import { interval, fromEvent, skipUntil } from 'rxjs';\n *\n * const intervalObservable = interval(1000);\n * const click = fromEvent(document, 'click');\n *\n * const emitAfterClick = intervalObservable.pipe(\n *   skipUntil(click)\n * );\n * // clicked at 4.6s. output: 5...6...7...8........ or\n * // clicked at 7.3s. output: 8...9...10..11.......\n * emitAfterClick.subscribe(value => console.log(value));\n * ```\n *\n * @see {@link last}\n * @see {@link skip}\n * @see {@link skipWhile}\n * @see {@link skipLast}\n *\n * @param notifier An `ObservableInput` that has to emit an item before the source Observable elements begin to\n * be mirrored by the resulting Observable.\n * @return A function that returns an Observable that skips items from the\n * source Observable until the `notifier` Observable emits an item, then emits the\n * remaining items.\n */\nexport function skipUntil<T>(notifier: ObservableInput<any>): MonoTypeOperatorFunction<T> {\n  return operate((source, subscriber) => {\n    let taking = false;\n\n    const skipSubscriber = createOperatorSubscriber(\n      subscriber,\n      () => {\n        skipSubscriber?.unsubscribe();\n        taking = true;\n      },\n      noop\n    );\n\n    innerFrom(notifier).subscribe(skipSubscriber);\n\n    source.subscribe(createOperatorSubscriber(subscriber, (value) => taking && subscriber.next(value)));\n  });\n}\n","import { Falsy, MonoTypeOperatorFunction, OperatorFunction } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\nexport function skipWhile<T>(predicate: BooleanConstructor): OperatorFunction<T, Extract<T, Falsy> extends never ? never : T>;\nexport function skipWhile<T>(predicate: (value: T, index: number) => true): OperatorFunction<T, never>;\nexport function skipWhile<T>(predicate: (value: T, index: number) => boolean): MonoTypeOperatorFunction<T>;\n\n/**\n * Returns an Observable that skips all items emitted by the source Observable as long as a specified condition holds\n * true, but emits all further source items as soon as the condition becomes false.\n *\n * ![](skipWhile.png)\n *\n * Skips all the notifications with a truthy predicate. It will not skip the notifications when the predicate is falsy.\n * It can also be skipped using index. Once the predicate is true, it will not be called again.\n *\n * ## Example\n *\n * Skip some super heroes\n *\n * ```ts\n * import { from, skipWhile } from 'rxjs';\n *\n * const source = from(['Green Arrow', 'SuperMan', 'Flash', 'SuperGirl', 'Black Canary'])\n * // Skip the heroes until SuperGirl\n * const example = source.pipe(skipWhile(hero => hero !== 'SuperGirl'));\n * // output: SuperGirl, Black Canary\n * example.subscribe(femaleHero => console.log(femaleHero));\n * ```\n *\n * Skip values from the array until index 5\n *\n * ```ts\n * import { from, skipWhile } from 'rxjs';\n *\n * const source = from([1, 2, 3, 4, 5, 6, 7, 9, 10]);\n * const example = source.pipe(skipWhile((_, i) => i !== 5));\n * // output: 6, 7, 9, 10\n * example.subscribe(value => console.log(value));\n * ```\n *\n * @see {@link last}\n * @see {@link skip}\n * @see {@link skipUntil}\n * @see {@link skipLast}\n *\n * @param {Function} predicate - A function to test each item emitted from the source Observable.\n * @return A function that returns an Observable that begins emitting items\n * emitted by the source Observable when the specified predicate becomes false.\n */\nexport function skipWhile<T>(predicate: (value: T, index: number) => boolean): MonoTypeOperatorFunction<T> {\n  return operate((source, subscriber) => {\n    let taking = false;\n    let index = 0;\n    source.subscribe(\n      createOperatorSubscriber(subscriber, (value) => (taking || (taking = !predicate(value, index++))) && subscriber.next(value))\n    );\n  });\n}\n","import { concat } from '../observable/concat';\nimport { OperatorFunction, SchedulerLike, ValueFromArray } from '../types';\nimport { popScheduler } from '../util/args';\nimport { operate } from '../util/lift';\n\n// Devs are more likely to pass null or undefined than they are a scheduler\n// without accompanying values. To make things easier for (naughty) devs who\n// use the `strictNullChecks: false` TypeScript compiler option, these\n// overloads with explicit null and undefined values are included.\n\nexport function startWith<T>(value: null): OperatorFunction<T, T | null>;\nexport function startWith<T>(value: undefined): OperatorFunction<T, T | undefined>;\n\n/** @deprecated The `scheduler` parameter will be removed in v8. Use `scheduled` and `concatAll`. Details: https://rxjs.dev/deprecations/scheduler-argument */\nexport function startWith<T, A extends readonly unknown[] = T[]>(\n  ...valuesAndScheduler: [...A, SchedulerLike]\n): OperatorFunction<T, T | ValueFromArray<A>>;\nexport function startWith<T, A extends readonly unknown[] = T[]>(...values: A): OperatorFunction<T, T | ValueFromArray<A>>;\n\n/**\n * Returns an observable that, at the moment of subscription, will synchronously emit all\n * values provided to this operator, then subscribe to the source and mirror all of its emissions\n * to subscribers.\n *\n * This is a useful way to know when subscription has occurred on an existing observable.\n *\n * <span class=\"informal\">First emits its arguments in order, and then any\n * emissions from the source.</span>\n *\n * ![](startWith.png)\n *\n * ## Examples\n *\n * Emit a value when a timer starts.\n *\n * ```ts\n * import { timer, map, startWith } from 'rxjs';\n *\n * timer(1000)\n *   .pipe(\n *     map(() => 'timer emit'),\n *     startWith('timer start')\n *   )\n *   .subscribe(x => console.log(x));\n *\n * // results:\n * // 'timer start'\n * // 'timer emit'\n * ```\n *\n * @param values Items you want the modified Observable to emit first.\n * @return A function that returns an Observable that synchronously emits\n * provided values before subscribing to the source Observable.\n *\n * @see {@link endWith}\n * @see {@link finalize}\n * @see {@link concat}\n */\nexport function startWith<T, D>(...values: D[]): OperatorFunction<T, T | D> {\n  const scheduler = popScheduler(values);\n  return operate((source, subscriber) => {\n    // Here we can't pass `undefined` as a scheduler, because if we did, the\n    // code inside of `concat` would be confused by the `undefined`, and treat it\n    // like an invalid observable. So we have to split it two different ways.\n    (scheduler ? concat(values, source, scheduler) : concat(values, source)).subscribe(subscriber);\n  });\n}\n","import { MonoTypeOperatorFunction, SchedulerLike } from '../types';\nimport { operate } from '../util/lift';\n\n/**\n * Asynchronously subscribes Observers to this Observable on the specified {@link SchedulerLike}.\n *\n * With `subscribeOn` you can decide what type of scheduler a specific Observable will be using when it is subscribed to.\n *\n * Schedulers control the speed and order of emissions to observers from an Observable stream.\n *\n * ![](subscribeOn.png)\n *\n * ## Example\n *\n * Given the following code:\n *\n * ```ts\n * import { of, merge } from 'rxjs';\n *\n * const a = of(1, 2, 3);\n * const b = of(4, 5, 6);\n *\n * merge(a, b).subscribe(console.log);\n *\n * // Outputs\n * // 1\n * // 2\n * // 3\n * // 4\n * // 5\n * // 6\n * ```\n *\n * Both Observable `a` and `b` will emit their values directly and synchronously once they are subscribed to.\n *\n * If we instead use the `subscribeOn` operator declaring that we want to use the {@link asyncScheduler} for values emitted by Observable `a`:\n *\n * ```ts\n * import { of, subscribeOn, asyncScheduler, merge } from 'rxjs';\n *\n * const a = of(1, 2, 3).pipe(subscribeOn(asyncScheduler));\n * const b = of(4, 5, 6);\n *\n * merge(a, b).subscribe(console.log);\n *\n * // Outputs\n * // 4\n * // 5\n * // 6\n * // 1\n * // 2\n * // 3\n * ```\n *\n * The reason for this is that Observable `b` emits its values directly and synchronously like before\n * but the emissions from `a` are scheduled on the event loop because we are now using the {@link asyncScheduler} for that specific Observable.\n *\n * @param scheduler The {@link SchedulerLike} to perform subscription actions on.\n * @param delay A delay to pass to the scheduler to delay subscriptions\n * @return A function that returns an Observable modified so that its\n * subscriptions happen on the specified {@link SchedulerLike}.\n */\nexport function subscribeOn<T>(scheduler: SchedulerLike, delay: number = 0): MonoTypeOperatorFunction<T> {\n  return operate((source, subscriber) => {\n    subscriber.add(scheduler.schedule(() => source.subscribe(subscriber), delay));\n  });\n}\n","import { OperatorFunction, ObservableInput, ObservedValueOf } from '../types';\nimport { switchMap } from './switchMap';\nimport { identity } from '../util/identity';\n\n/**\n * Converts a higher-order Observable into a first-order Observable\n * producing values only from the most recent observable sequence\n *\n * <span class=\"informal\">Flattens an Observable-of-Observables.</span>\n *\n * ![](switchAll.png)\n *\n * `switchAll` subscribes to a source that is an observable of observables, also known as a\n * \"higher-order observable\" (or `Observable<Observable<T>>`). It subscribes to the most recently\n * provided \"inner observable\" emitted by the source, unsubscribing from any previously subscribed\n * to inner observable, such that only the most recent inner observable may be subscribed to at\n * any point in time. The resulting observable returned by `switchAll` will only complete if the\n * source observable completes, *and* any currently subscribed to inner observable also has completed,\n * if there are any.\n *\n * ## Examples\n *\n * Spawn a new interval observable for each click event, but for every new\n * click, cancel the previous interval and subscribe to the new one\n *\n * ```ts\n * import { fromEvent, tap, map, interval, switchAll } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click').pipe(tap(() => console.log('click')));\n * const source = clicks.pipe(map(() => interval(1000)));\n *\n * source\n *   .pipe(switchAll())\n *   .subscribe(x => console.log(x));\n *\n * // Output\n * // click\n * // 0\n * // 1\n * // 2\n * // 3\n * // ...\n * // click\n * // 0\n * // 1\n * // 2\n * // ...\n * // click\n * // ...\n * ```\n *\n * @see {@link combineLatestAll}\n * @see {@link concatAll}\n * @see {@link exhaustAll}\n * @see {@link switchMap}\n * @see {@link switchMapTo}\n * @see {@link mergeAll}\n *\n * @return A function that returns an Observable that converts a higher-order\n * Observable into a first-order Observable producing values only from the most\n * recent Observable sequence.\n */\nexport function switchAll<O extends ObservableInput<any>>(): OperatorFunction<O, ObservedValueOf<O>> {\n  return switchMap(identity);\n}\n","import { Subscriber } from '../Subscriber';\nimport { ObservableInput, OperatorFunction, ObservedValueOf } from '../types';\nimport { innerFrom } from '../observable/innerFrom';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\n/* tslint:disable:max-line-length */\nexport function switchMap<T, O extends ObservableInput<any>>(\n  project: (value: T, index: number) => O\n): OperatorFunction<T, ObservedValueOf<O>>;\n/** @deprecated The `resultSelector` parameter will be removed in v8. Use an inner `map` instead. Details: https://rxjs.dev/deprecations/resultSelector */\nexport function switchMap<T, O extends ObservableInput<any>>(\n  project: (value: T, index: number) => O,\n  resultSelector: undefined\n): OperatorFunction<T, ObservedValueOf<O>>;\n/** @deprecated The `resultSelector` parameter will be removed in v8. Use an inner `map` instead. Details: https://rxjs.dev/deprecations/resultSelector */\nexport function switchMap<T, R, O extends ObservableInput<any>>(\n  project: (value: T, index: number) => O,\n  resultSelector: (outerValue: T, innerValue: ObservedValueOf<O>, outerIndex: number, innerIndex: number) => R\n): OperatorFunction<T, R>;\n/* tslint:enable:max-line-length */\n\n/**\n * Projects each source value to an Observable which is merged in the output\n * Observable, emitting values only from the most recently projected Observable.\n *\n * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n * these inner Observables using {@link switchAll}.</span>\n *\n * ![](switchMap.png)\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an (so-called \"inner\") Observable. Each time it observes one of these\n * inner Observables, the output Observable begins emitting the items emitted by\n * that inner Observable. When a new inner Observable is emitted, `switchMap`\n * stops emitting items from the earlier-emitted inner Observable and begins\n * emitting items from the new one. It continues to behave like this for\n * subsequent inner Observables.\n *\n * ## Example\n *\n * Generate new Observable according to source Observable values\n *\n * ```ts\n * import { of, switchMap } from 'rxjs';\n *\n * const switched = of(1, 2, 3).pipe(switchMap(x => of(x, x ** 2, x ** 3)));\n * switched.subscribe(x => console.log(x));\n * // outputs\n * // 1\n * // 1\n * // 1\n * // 2\n * // 4\n * // 8\n * // 3\n * // 9\n * // 27\n * ```\n *\n * Restart an interval Observable on every click event\n *\n * ```ts\n * import { fromEvent, switchMap, interval } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(switchMap(() => interval(1000)));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link concatMap}\n * @see {@link exhaustMap}\n * @see {@link mergeMap}\n * @see {@link switchAll}\n * @see {@link switchMapTo}\n *\n * @param {function(value: T, index: number): ObservableInput} project A function\n * that, when applied to an item emitted by the source Observable, returns an\n * Observable.\n * @return A function that returns an Observable that emits the result of\n * applying the projection function (and the optional deprecated\n * `resultSelector`) to each item emitted by the source Observable and taking\n * only the values from the most recently projected inner Observable.\n */\nexport function switchMap<T, R, O extends ObservableInput<any>>(\n  project: (value: T, index: number) => O,\n  resultSelector?: (outerValue: T, innerValue: ObservedValueOf<O>, outerIndex: number, innerIndex: number) => R\n): OperatorFunction<T, ObservedValueOf<O> | R> {\n  return operate((source, subscriber) => {\n    let innerSubscriber: Subscriber<ObservedValueOf<O>> | null = null;\n    let index = 0;\n    // Whether or not the source subscription has completed\n    let isComplete = false;\n\n    // We only complete the result if the source is complete AND we don't have an active inner subscription.\n    // This is called both when the source completes and when the inners complete.\n    const checkComplete = () => isComplete && !innerSubscriber && subscriber.complete();\n\n    source.subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        (value) => {\n          // Cancel the previous inner subscription if there was one\n          innerSubscriber?.unsubscribe();\n          let innerIndex = 0;\n          const outerIndex = index++;\n          // Start the next inner subscription\n          innerFrom(project(value, outerIndex)).subscribe(\n            (innerSubscriber = createOperatorSubscriber(\n              subscriber,\n              // When we get a new inner value, next it through. Note that this is\n              // handling the deprecate result selector here. This is because with this architecture\n              // it ends up being smaller than using the map operator.\n              (innerValue) => subscriber.next(resultSelector ? resultSelector(value, innerValue, outerIndex, innerIndex++) : innerValue),\n              () => {\n                // The inner has completed. Null out the inner subscriber to\n                // free up memory and to signal that we have no inner subscription\n                // currently.\n                innerSubscriber = null!;\n                checkComplete();\n              }\n            ))\n          );\n        },\n        () => {\n          isComplete = true;\n          checkComplete();\n        }\n      )\n    );\n  });\n}\n","import { switchMap } from './switchMap';\nimport { ObservableInput, OperatorFunction, ObservedValueOf } from '../types';\nimport { isFunction } from '../util/isFunction';\n\n/** @deprecated Will be removed in v9. Use {@link switchMap} instead: `switchMap(() => result)` */\nexport function switchMapTo<O extends ObservableInput<unknown>>(observable: O): OperatorFunction<unknown, ObservedValueOf<O>>;\n/** @deprecated The `resultSelector` parameter will be removed in v8. Use an inner `map` instead. Details: https://rxjs.dev/deprecations/resultSelector */\nexport function switchMapTo<O extends ObservableInput<unknown>>(\n  observable: O,\n  resultSelector: undefined\n): OperatorFunction<unknown, ObservedValueOf<O>>;\n/** @deprecated The `resultSelector` parameter will be removed in v8. Use an inner `map` instead. Details: https://rxjs.dev/deprecations/resultSelector */\nexport function switchMapTo<T, R, O extends ObservableInput<unknown>>(\n  observable: O,\n  resultSelector: (outerValue: T, innerValue: ObservedValueOf<O>, outerIndex: number, innerIndex: number) => R\n): OperatorFunction<T, R>;\n\n/**\n * Projects each source value to the same Observable which is flattened multiple\n * times with {@link switchMap} in the output Observable.\n *\n * <span class=\"informal\">It's like {@link switchMap}, but maps each value\n * always to the same inner Observable.</span>\n *\n * ![](switchMapTo.png)\n *\n * Maps each source value to the given Observable `innerObservable` regardless\n * of the source value, and then flattens those resulting Observables into one\n * single Observable, which is the output Observable. The output Observables\n * emits values only from the most recently emitted instance of\n * `innerObservable`.\n *\n * ## Example\n *\n * Restart an interval Observable on every click event\n *\n * ```ts\n * import { fromEvent, switchMapTo, interval } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(switchMapTo(interval(1000)));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link concatMapTo}\n * @see {@link switchAll}\n * @see {@link switchMap}\n * @see {@link mergeMapTo}\n *\n * @param {ObservableInput} innerObservable An Observable to replace each value from\n * the source Observable.\n * @return A function that returns an Observable that emits items from the\n * given `innerObservable` (and optionally transformed through the deprecated\n * `resultSelector`) every time a value is emitted on the source Observable,\n * and taking only the values from the most recently projected inner\n * Observable.\n * @deprecated Will be removed in v9. Use {@link switchMap} instead: `switchMap(() => result)`\n */\nexport function switchMapTo<T, R, O extends ObservableInput<unknown>>(\n  innerObservable: O,\n  resultSelector?: (outerValue: T, innerValue: ObservedValueOf<O>, outerIndex: number, innerIndex: number) => R\n): OperatorFunction<T, ObservedValueOf<O> | R> {\n  return isFunction(resultSelector) ? switchMap(() => innerObservable, resultSelector) : switchMap(() => innerObservable);\n}\n","import { ObservableInput, ObservedValueOf, OperatorFunction } from '../types';\nimport { switchMap } from './switchMap';\nimport { operate } from '../util/lift';\n\n// TODO: Generate a marble diagram for these docs.\n\n/**\n * Applies an accumulator function over the source Observable where the\n * accumulator function itself returns an Observable, emitting values\n * only from the most recently returned Observable.\n *\n * <span class=\"informal\">It's like {@link mergeScan}, but only the most recent\n * Observable returned by the accumulator is merged into the outer Observable.</span>\n *\n * @see {@link scan}\n * @see {@link mergeScan}\n * @see {@link switchMap}\n *\n * @param accumulator\n * The accumulator function called on each source value.\n * @param seed The initial accumulation value.\n * @return A function that returns an observable of the accumulated values.\n */\nexport function switchScan<T, R, O extends ObservableInput<any>>(\n  accumulator: (acc: R, value: T, index: number) => O,\n  seed: R\n): OperatorFunction<T, ObservedValueOf<O>> {\n  return operate((source, subscriber) => {\n    // The state we will keep up to date to pass into our\n    // accumulator function at each new value from the source.\n    let state = seed;\n\n    // Use `switchMap` on our `source` to do the work of creating\n    // this operator. Note the backwards order here of `switchMap()(source)`\n    // to avoid needing to use `pipe` unnecessarily\n    switchMap(\n      // On each value from the source, call the accumulator with\n      // our previous state, the value and the index.\n      (value: T, index) => accumulator(state, value, index),\n      // Using the deprecated result selector here as a dirty trick\n      // to update our state with the flattened value.\n      (_, innerValue) => ((state = innerValue), innerValue)\n    )(source).subscribe(subscriber);\n\n    return () => {\n      // Release state on finalization\n      state = null!;\n    };\n  });\n}\n","import { MonoTypeOperatorFunction } from '../types';\nimport { EMPTY } from '../observable/empty';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\n/**\n * Emits only the first `count` values emitted by the source Observable.\n *\n * <span class=\"informal\">Takes the first `count` values from the source, then\n * completes.</span>\n *\n * ![](take.png)\n *\n * `take` returns an Observable that emits only the first `count` values emitted\n * by the source Observable. If the source emits fewer than `count` values then\n * all of its values are emitted. After that, it completes, regardless if the\n * source completes.\n *\n * ## Example\n *\n * Take the first 5 seconds of an infinite 1-second interval Observable\n *\n * ```ts\n * import { interval, take } from 'rxjs';\n *\n * const intervalCount = interval(1000);\n * const takeFive = intervalCount.pipe(take(5));\n * takeFive.subscribe(x => console.log(x));\n *\n * // Logs:\n * // 0\n * // 1\n * // 2\n * // 3\n * // 4\n * ```\n *\n * @see {@link takeLast}\n * @see {@link takeUntil}\n * @see {@link takeWhile}\n * @see {@link skip}\n *\n * @param count The maximum number of `next` values to emit.\n * @return A function that returns an Observable that emits only the first\n * `count` values emitted by the source Observable, or all of the values from\n * the source if the source emits fewer than `count` values.\n */\nexport function take<T>(count: number): MonoTypeOperatorFunction<T> {\n  return count <= 0\n    ? // If we are taking no values, that's empty.\n      () => EMPTY\n    : operate((source, subscriber) => {\n        let seen = 0;\n        source.subscribe(\n          createOperatorSubscriber(subscriber, (value) => {\n            // Increment the number of values we have seen,\n            // then check it against the allowed count to see\n            // if we are still letting values through.\n            if (++seen <= count) {\n              subscriber.next(value);\n              // If we have met or passed our allowed count,\n              // we need to complete. We have to do <= here,\n              // because re-entrant code will increment `seen` twice.\n              if (count <= seen) {\n                subscriber.complete();\n              }\n            }\n          })\n        );\n      });\n}\n","import { EMPTY } from '../observable/empty';\nimport { MonoTypeOperatorFunction } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\n/**\n * Waits for the source to complete, then emits the last N values from the source,\n * as specified by the `count` argument.\n *\n * ![](takeLast.png)\n *\n * `takeLast` results in an observable that will hold values up to `count` values in memory,\n * until the source completes. It then pushes all values in memory to the consumer, in the\n * order they were received from the source, then notifies the consumer that it is\n * complete.\n *\n * If for some reason the source completes before the `count` supplied to `takeLast` is reached,\n * all values received until that point are emitted, and then completion is notified.\n *\n * **Warning**: Using `takeLast` with an observable that never completes will result\n * in an observable that never emits a value.\n *\n * ## Example\n *\n * Take the last 3 values of an Observable with many values\n *\n * ```ts\n * import { range, takeLast } from 'rxjs';\n *\n * const many = range(1, 100);\n * const lastThree = many.pipe(takeLast(3));\n * lastThree.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link take}\n * @see {@link takeUntil}\n * @see {@link takeWhile}\n * @see {@link skip}\n *\n * @param count The maximum number of values to emit from the end of\n * the sequence of values emitted by the source Observable.\n * @return A function that returns an Observable that emits at most the last\n * `count` values emitted by the source Observable.\n */\nexport function takeLast<T>(count: number): MonoTypeOperatorFunction<T> {\n  return count <= 0\n    ? () => EMPTY\n    : operate((source, subscriber) => {\n        // This buffer will hold the values we are going to emit\n        // when the source completes. Since we only want to take the\n        // last N values, we can't emit until we're sure we're not getting\n        // any more values.\n        let buffer: T[] = [];\n        source.subscribe(\n          createOperatorSubscriber(\n            subscriber,\n            (value) => {\n              // Add the most recent value onto the end of our buffer.\n              buffer.push(value);\n              // If our buffer is now larger than the number of values we\n              // want to take, we remove the oldest value from the buffer.\n              count < buffer.length && buffer.shift();\n            },\n            () => {\n              // The source completed, we now know what are last values\n              // are, emit them in the order they were received.\n              for (const value of buffer) {\n                subscriber.next(value);\n              }\n              subscriber.complete();\n            },\n            // Errors are passed through to the consumer\n            undefined,\n            () => {\n              // During finalization release the values in our buffer.\n              buffer = null!;\n            }\n          )\n        );\n      });\n}\n","import { MonoTypeOperatorFunction, ObservableInput } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nimport { innerFrom } from '../observable/innerFrom';\nimport { noop } from '../util/noop';\n\n/**\n * Emits the values emitted by the source Observable until a `notifier`\n * Observable emits a value.\n *\n * <span class=\"informal\">Lets values pass until a second Observable,\n * `notifier`, emits a value. Then, it completes.</span>\n *\n * ![](takeUntil.png)\n *\n * `takeUntil` subscribes and begins mirroring the source Observable. It also\n * monitors a second Observable, `notifier` that you provide. If the `notifier`\n * emits a value, the output Observable stops mirroring the source Observable\n * and completes. If the `notifier` doesn't emit any value and completes\n * then `takeUntil` will pass all values.\n *\n * ## Example\n *\n * Tick every second until the first click happens\n *\n * ```ts\n * import { interval, fromEvent, takeUntil } from 'rxjs';\n *\n * const source = interval(1000);\n * const clicks = fromEvent(document, 'click');\n * const result = source.pipe(takeUntil(clicks));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link take}\n * @see {@link takeLast}\n * @see {@link takeWhile}\n * @see {@link skip}\n *\n * @param {Observable} notifier The Observable whose first emitted value will\n * cause the output Observable of `takeUntil` to stop emitting values from the\n * source Observable.\n * @return A function that returns an Observable that emits the values from the\n * source Observable until `notifier` emits its first value.\n */\nexport function takeUntil<T>(notifier: ObservableInput<any>): MonoTypeOperatorFunction<T> {\n  return operate((source, subscriber) => {\n    innerFrom(notifier).subscribe(createOperatorSubscriber(subscriber, () => subscriber.complete(), noop));\n    !subscriber.closed && source.subscribe(subscriber);\n  });\n}\n","import { OperatorFunction, MonoTypeOperatorFunction, TruthyTypesOf } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\nexport function takeWhile<T>(predicate: BooleanConstructor, inclusive: true): MonoTypeOperatorFunction<T>;\nexport function takeWhile<T>(predicate: BooleanConstructor, inclusive: false): OperatorFunction<T, TruthyTypesOf<T>>;\nexport function takeWhile<T>(predicate: BooleanConstructor): OperatorFunction<T, TruthyTypesOf<T>>;\nexport function takeWhile<T, S extends T>(predicate: (value: T, index: number) => value is S): OperatorFunction<T, S>;\nexport function takeWhile<T, S extends T>(predicate: (value: T, index: number) => value is S, inclusive: false): OperatorFunction<T, S>;\nexport function takeWhile<T>(predicate: (value: T, index: number) => boolean, inclusive?: boolean): MonoTypeOperatorFunction<T>;\n\n/**\n * Emits values emitted by the source Observable so long as each value satisfies\n * the given `predicate`, and then completes as soon as this `predicate` is not\n * satisfied.\n *\n * <span class=\"informal\">Takes values from the source only while they pass the\n * condition given. When the first value does not satisfy, it completes.</span>\n *\n * ![](takeWhile.png)\n *\n * `takeWhile` subscribes and begins mirroring the source Observable. Each value\n * emitted on the source is given to the `predicate` function which returns a\n * boolean, representing a condition to be satisfied by the source values. The\n * output Observable emits the source values until such time as the `predicate`\n * returns false, at which point `takeWhile` stops mirroring the source\n * Observable and completes the output Observable.\n *\n * ## Example\n *\n * Emit click events only while the clientX property is greater than 200\n *\n * ```ts\n * import { fromEvent, takeWhile } from 'rxjs';\n *\n * const clicks = fromEvent<PointerEvent>(document, 'click');\n * const result = clicks.pipe(takeWhile(ev => ev.clientX > 200));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link take}\n * @see {@link takeLast}\n * @see {@link takeUntil}\n * @see {@link skip}\n *\n * @param {function(value: T, index: number): boolean} predicate A function that\n * evaluates a value emitted by the source Observable and returns a boolean.\n * Also takes the (zero-based) index as the second argument.\n * @param {boolean} inclusive When set to `true` the value that caused\n * `predicate` to return `false` will also be emitted.\n * @return A function that returns an Observable that emits values from the\n * source Observable so long as each value satisfies the condition defined by\n * the `predicate`, then completes.\n */\nexport function takeWhile<T>(predicate: (value: T, index: number) => boolean, inclusive = false): MonoTypeOperatorFunction<T> {\n  return operate((source, subscriber) => {\n    let index = 0;\n    source.subscribe(\n      createOperatorSubscriber(subscriber, (value) => {\n        const result = predicate(value, index++);\n        (result || inclusive) && subscriber.next(value);\n        !result && subscriber.complete();\n      })\n    );\n  });\n}\n","import { MonoTypeOperatorFunction, Observer } from '../types';\nimport { isFunction } from '../util/isFunction';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nimport { identity } from '../util/identity';\n\n/**\n * An extension to the {@link Observer} interface used only by the {@link tap} operator.\n *\n * It provides a useful set of callbacks a user can register to do side-effects in\n * cases other than what the usual {@link Observer} callbacks are\n * ({@link guide/glossary-and-semantics#next next},\n * {@link guide/glossary-and-semantics#error error} and/or\n * {@link guide/glossary-and-semantics#complete complete}).\n *\n * ## Example\n *\n * ```ts\n * import { fromEvent, switchMap, tap, interval, take } from 'rxjs';\n *\n * const source$ = fromEvent(document, 'click');\n * const result$ = source$.pipe(\n *   switchMap((_, i) => i % 2 === 0\n *     ? fromEvent(document, 'mousemove').pipe(\n *         tap({\n *           subscribe: () => console.log('Subscribed to the mouse move events after click #' + i),\n *           unsubscribe: () => console.log('Mouse move events #' + i + ' unsubscribed'),\n *           finalize: () => console.log('Mouse move events #' + i + ' finalized')\n *         })\n *       )\n *     : interval(1_000).pipe(\n *         take(5),\n *         tap({\n *           subscribe: () => console.log('Subscribed to the 1-second interval events after click #' + i),\n *           unsubscribe: () => console.log('1-second interval events #' + i + ' unsubscribed'),\n *           finalize: () => console.log('1-second interval events #' + i + ' finalized')\n *         })\n *       )\n *   )\n * );\n *\n * const subscription = result$.subscribe({\n *   next: console.log\n * });\n *\n * setTimeout(() => {\n *   console.log('Unsubscribe after 60 seconds');\n *   subscription.unsubscribe();\n * }, 60_000);\n * ```\n */\nexport interface TapObserver<T> extends Observer<T> {\n  /**\n   * The callback that `tap` operator invokes at the moment when the source Observable\n   * gets subscribed to.\n   */\n  subscribe: () => void;\n  /**\n   * The callback that `tap` operator invokes when an explicit\n   * {@link guide/glossary-and-semantics#unsubscription unsubscribe} happens. It won't get invoked on\n   * `error` or `complete` events.\n   */\n  unsubscribe: () => void;\n  /**\n   * The callback that `tap` operator invokes when any kind of\n   * {@link guide/glossary-and-semantics#finalization finalization} happens - either when\n   * the source Observable `error`s or `complete`s or when it gets explicitly unsubscribed\n   * by the user. There is no difference in using this callback or the {@link finalize}\n   * operator, but if you're already using `tap` operator, you can use this callback\n   * instead. You'd get the same result in either case.\n   */\n  finalize: () => void;\n}\nexport function tap<T>(observerOrNext?: Partial<TapObserver<T>> | ((value: T) => void)): MonoTypeOperatorFunction<T>;\n/** @deprecated Instead of passing separate callback arguments, use an observer argument. Signatures taking separate callback arguments will be removed in v8. Details: https://rxjs.dev/deprecations/subscribe-arguments */\nexport function tap<T>(\n  next?: ((value: T) => void) | null,\n  error?: ((error: any) => void) | null,\n  complete?: (() => void) | null\n): MonoTypeOperatorFunction<T>;\n\n/**\n * Used to perform side-effects for notifications from the source observable\n *\n * <span class=\"informal\">Used when you want to affect outside state with a notification without altering the notification</span>\n *\n * ![](tap.png)\n *\n * Tap is designed to allow the developer a designated place to perform side effects. While you _could_ perform side-effects\n * inside of a `map` or a `mergeMap`, that would make their mapping functions impure, which isn't always a big deal, but will\n * make it so you can't do things like memoize those functions. The `tap` operator is designed solely for such side-effects to\n * help you remove side-effects from other operations.\n *\n * For any notification, next, error, or complete, `tap` will call the appropriate callback you have provided to it, via a function\n * reference, or a partial observer, then pass that notification down the stream.\n *\n * The observable returned by `tap` is an exact mirror of the source, with one exception: Any error that occurs -- synchronously -- in a handler\n * provided to `tap` will be emitted as an error from the returned observable.\n *\n * > Be careful! You can mutate objects as they pass through the `tap` operator's handlers.\n *\n * The most common use of `tap` is actually for debugging. You can place a `tap(console.log)` anywhere\n * in your observable `pipe`, log out the notifications as they are emitted by the source returned by the previous\n * operation.\n *\n * ## Examples\n *\n * Check a random number before it is handled. Below is an observable that will use a random number between 0 and 1,\n * and emit `'big'` or `'small'` depending on the size of that number. But we wanted to log what the original number\n * was, so we have added a `tap(console.log)`.\n *\n * ```ts\n * import { of, tap, map } from 'rxjs';\n *\n * of(Math.random()).pipe(\n *   tap(console.log),\n *   map(n => n > 0.5 ? 'big' : 'small')\n * ).subscribe(console.log);\n * ```\n *\n * Using `tap` to analyze a value and force an error. Below is an observable where in our system we only\n * want to emit numbers 3 or less we get from another source. We can force our observable to error\n * using `tap`.\n *\n * ```ts\n * import { of, tap } from 'rxjs';\n *\n * const source = of(1, 2, 3, 4, 5);\n *\n * source.pipe(\n *   tap(n => {\n *     if (n > 3) {\n *       throw new TypeError(`Value ${ n } is greater than 3`);\n *     }\n *   })\n * )\n * .subscribe({ next: console.log, error: err => console.log(err.message) });\n * ```\n *\n * We want to know when an observable completes before moving on to the next observable. The system\n * below will emit a random series of `'X'` characters from 3 different observables in sequence. The\n * only way we know when one observable completes and moves to the next one, in this case, is because\n * we have added a `tap` with the side effect of logging to console.\n *\n * ```ts\n * import { of, concatMap, interval, take, map, tap } from 'rxjs';\n *\n * of(1, 2, 3).pipe(\n *   concatMap(n => interval(1000).pipe(\n *     take(Math.round(Math.random() * 10)),\n *     map(() => 'X'),\n *     tap({ complete: () => console.log(`Done with ${ n }`) })\n *   ))\n * )\n * .subscribe(console.log);\n * ```\n *\n * @see {@link finalize}\n * @see {@link TapObserver}\n *\n * @param observerOrNext A next handler or partial observer\n * @param error An error handler\n * @param complete A completion handler\n * @return A function that returns an Observable identical to the source, but\n * runs the specified Observer or callback(s) for each item.\n */\nexport function tap<T>(\n  observerOrNext?: Partial<TapObserver<T>> | ((value: T) => void) | null,\n  error?: ((e: any) => void) | null,\n  complete?: (() => void) | null\n): MonoTypeOperatorFunction<T> {\n  // We have to check to see not only if next is a function,\n  // but if error or complete were passed. This is because someone\n  // could technically call tap like `tap(null, fn)` or `tap(null, null, fn)`.\n  const tapObserver =\n    isFunction(observerOrNext) || error || complete\n      ? // tslint:disable-next-line: no-object-literal-type-assertion\n        ({ next: observerOrNext as Exclude<typeof observerOrNext, Partial<TapObserver<T>>>, error, complete } as Partial<TapObserver<T>>)\n      : observerOrNext;\n\n  return tapObserver\n    ? operate((source, subscriber) => {\n        tapObserver.subscribe?.();\n        let isUnsub = true;\n        source.subscribe(\n          createOperatorSubscriber(\n            subscriber,\n            (value) => {\n              tapObserver.next?.(value);\n              subscriber.next(value);\n            },\n            () => {\n              isUnsub = false;\n              tapObserver.complete?.();\n              subscriber.complete();\n            },\n            (err) => {\n              isUnsub = false;\n              tapObserver.error?.(err);\n              subscriber.error(err);\n            },\n            () => {\n              if (isUnsub) {\n                tapObserver.unsubscribe?.();\n              }\n              tapObserver.finalize?.();\n            }\n          )\n        );\n      })\n    : // Tap was called with no valid tap observer or handler\n      // (e.g. `tap(null, null, null)` or `tap(null)` or `tap()`)\n      // so we're going to just mirror the source.\n      identity;\n}\n","import { Subscription } from '../Subscription';\n\nimport { MonoTypeOperatorFunction, ObservableInput } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nimport { innerFrom } from '../observable/innerFrom';\n\n/**\n * An object interface used by {@link throttle} or {@link throttleTime} that ensure\n * configuration options of these operators.\n *\n * @see {@link throttle}\n * @see {@link throttleTime}\n */\nexport interface ThrottleConfig {\n  /**\n   * If `true`, the resulting Observable will emit the first value from the source\n   * Observable at the **start** of the \"throttling\" process (when starting an\n   * internal timer that prevents other emissions from the source to pass through).\n   * If `false`, it will not emit the first value from the source Observable at the\n   * start of the \"throttling\" process.\n   *\n   * If not provided, defaults to: `true`.\n   */\n  leading?: boolean;\n  /**\n   * If `true`, the resulting Observable will emit the last value from the source\n   * Observable at the **end** of the \"throttling\" process (when ending an internal\n   * timer that prevents other emissions from the source to pass through).\n   * If `false`, it will not emit the last value from the source Observable at the\n   * end of the \"throttling\" process.\n   *\n   * If not provided, defaults to: `false`.\n   */\n  trailing?: boolean;\n}\n\n/**\n * Emits a value from the source Observable, then ignores subsequent source\n * values for a duration determined by another Observable, then repeats this\n * process.\n *\n * <span class=\"informal\">It's like {@link throttleTime}, but the silencing\n * duration is determined by a second Observable.</span>\n *\n * ![](throttle.svg)\n *\n * `throttle` emits the source Observable values on the output Observable\n * when its internal timer is disabled, and ignores source values when the timer\n * is enabled. Initially, the timer is disabled. As soon as the first source\n * value arrives, it is forwarded to the output Observable, and then the timer\n * is enabled by calling the `durationSelector` function with the source value,\n * which returns the \"duration\" Observable. When the duration Observable emits a\n * value, the timer is disabled, and this process repeats for the\n * next source value.\n *\n * ## Example\n *\n * Emit clicks at a rate of at most one click per second\n *\n * ```ts\n * import { fromEvent, throttle, interval } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(throttle(() => interval(1000)));\n *\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link audit}\n * @see {@link debounce}\n * @see {@link delayWhen}\n * @see {@link sample}\n * @see {@link throttleTime}\n *\n * @param durationSelector A function that receives a value from the source\n * Observable, for computing the silencing duration for each source value,\n * returned as an `ObservableInput`.\n * @param config A configuration object to define `leading` and `trailing`\n * behavior. Defaults to `{ leading: true, trailing: false }`.\n * @return A function that returns an Observable that performs the throttle\n * operation to limit the rate of emissions from the source.\n */\nexport function throttle<T>(durationSelector: (value: T) => ObservableInput<any>, config?: ThrottleConfig): MonoTypeOperatorFunction<T> {\n  return operate((source, subscriber) => {\n    const { leading = true, trailing = false } = config ?? {};\n    let hasValue = false;\n    let sendValue: T | null = null;\n    let throttled: Subscription | null = null;\n    let isComplete = false;\n\n    const endThrottling = () => {\n      throttled?.unsubscribe();\n      throttled = null;\n      if (trailing) {\n        send();\n        isComplete && subscriber.complete();\n      }\n    };\n\n    const cleanupThrottling = () => {\n      throttled = null;\n      isComplete && subscriber.complete();\n    };\n\n    const startThrottle = (value: T) =>\n      (throttled = innerFrom(durationSelector(value)).subscribe(createOperatorSubscriber(subscriber, endThrottling, cleanupThrottling)));\n\n    const send = () => {\n      if (hasValue) {\n        // Ensure we clear out our value and hasValue flag\n        // before we emit, otherwise reentrant code can cause\n        // issues here.\n        hasValue = false;\n        const value = sendValue!;\n        sendValue = null;\n        // Emit the value.\n        subscriber.next(value);\n        !isComplete && startThrottle(value);\n      }\n    };\n\n    source.subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        // Regarding the presence of throttled.closed in the following\n        // conditions, if a synchronous duration selector is specified - weird,\n        // but legal - an already-closed subscription will be assigned to\n        // throttled, so the subscription's closed property needs to be checked,\n        // too.\n        (value) => {\n          hasValue = true;\n          sendValue = value;\n          !(throttled && !throttled.closed) && (leading ? send() : startThrottle(value));\n        },\n        () => {\n          isComplete = true;\n          !(trailing && hasValue && throttled && !throttled.closed) && subscriber.complete();\n        }\n      )\n    );\n  });\n}\n","import { asyncScheduler } from '../scheduler/async';\nimport { throttle, ThrottleConfig } from './throttle';\nimport { MonoTypeOperatorFunction, SchedulerLike } from '../types';\nimport { timer } from '../observable/timer';\n\n/**\n * Emits a value from the source Observable, then ignores subsequent source\n * values for `duration` milliseconds, then repeats this process.\n *\n * <span class=\"informal\">Lets a value pass, then ignores source values for the\n * next `duration` milliseconds.</span>\n *\n * ![](throttleTime.png)\n *\n * `throttleTime` emits the source Observable values on the output Observable\n * when its internal timer is disabled, and ignores source values when the timer\n * is enabled. Initially, the timer is disabled. As soon as the first source\n * value arrives, it is forwarded to the output Observable, and then the timer\n * is enabled. After `duration` milliseconds (or the time unit determined\n * internally by the optional `scheduler`) has passed, the timer is disabled,\n * and this process repeats for the next source value. Optionally takes a\n * {@link SchedulerLike} for managing timers.\n *\n * ## Examples\n *\n * ### Limit click rate\n *\n * Emit clicks at a rate of at most one click per second\n *\n * ```ts\n * import { fromEvent, throttleTime } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(throttleTime(1000));\n *\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link auditTime}\n * @see {@link debounceTime}\n * @see {@link delay}\n * @see {@link sampleTime}\n * @see {@link throttle}\n *\n * @param duration Time to wait before emitting another value after\n * emitting the last value, measured in milliseconds or the time unit determined\n * internally by the optional `scheduler`.\n * @param scheduler The {@link SchedulerLike} to use for\n * managing the timers that handle the throttling. Defaults to {@link asyncScheduler}.\n * @param config A configuration object to define `leading` and\n * `trailing` behavior. Defaults to `{ leading: true, trailing: false }`.\n * @return A function that returns an Observable that performs the throttle\n * operation to limit the rate of emissions from the source.\n */\nexport function throttleTime<T>(\n  duration: number,\n  scheduler: SchedulerLike = asyncScheduler,\n  config?: ThrottleConfig\n): MonoTypeOperatorFunction<T> {\n  const duration$ = timer(duration, scheduler);\n  return throttle(() => duration$, config);\n}\n","import { EmptyError } from '../util/EmptyError';\nimport { MonoTypeOperatorFunction } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\n/**\n * If the source observable completes without emitting a value, it will emit\n * an error. The error will be created at that time by the optional\n * `errorFactory` argument, otherwise, the error will be {@link EmptyError}.\n *\n * ![](throwIfEmpty.png)\n *\n * ## Example\n *\n * Throw an error if the document wasn't clicked within 1 second\n *\n * ```ts\n * import { fromEvent, takeUntil, timer, throwIfEmpty } from 'rxjs';\n *\n * const click$ = fromEvent(document, 'click');\n *\n * click$.pipe(\n *   takeUntil(timer(1000)),\n *   throwIfEmpty(() => new Error('The document was not clicked within 1 second'))\n * )\n * .subscribe({\n *   next() {\n *    console.log('The document was clicked');\n *   },\n *   error(err) {\n *     console.error(err.message);\n *   }\n * });\n * ```\n *\n * @param errorFactory A factory function called to produce the\n * error to be thrown when the source observable completes without emitting a\n * value.\n * @return A function that returns an Observable that throws an error if the\n * source Observable completed without emitting.\n */\nexport function throwIfEmpty<T>(errorFactory: () => any = defaultErrorFactory): MonoTypeOperatorFunction<T> {\n  return operate((source, subscriber) => {\n    let hasValue = false;\n    source.subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        (value) => {\n          hasValue = true;\n          subscriber.next(value);\n        },\n        () => (hasValue ? subscriber.complete() : subscriber.error(errorFactory()))\n      )\n    );\n  });\n}\n\nfunction defaultErrorFactory() {\n  return new EmptyError();\n}\n","import { asyncScheduler } from '../scheduler/async';\nimport { SchedulerLike, OperatorFunction } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\n/**\n * Emits an object containing the current value, and the time that has\n * passed between emitting the current value and the previous value, which is\n * calculated by using the provided `scheduler`'s `now()` method to retrieve\n * the current time at each emission, then calculating the difference. The `scheduler`\n * defaults to {@link asyncScheduler}, so by default, the `interval` will be in\n * milliseconds.\n *\n * <span class=\"informal\">Convert an Observable that emits items into one that\n * emits indications of the amount of time elapsed between those emissions.</span>\n *\n * ![](timeInterval.png)\n *\n * ## Example\n *\n * Emit interval between current value with the last value\n *\n * ```ts\n * import { interval, timeInterval } from 'rxjs';\n *\n * const seconds = interval(1000);\n *\n * seconds\n *   .pipe(timeInterval())\n *   .subscribe(value => console.log(value));\n *\n * // NOTE: The values will never be this precise,\n * // intervals created with `interval` or `setInterval`\n * // are non-deterministic.\n *\n * // { value: 0, interval: 1000 }\n * // { value: 1, interval: 1000 }\n * // { value: 2, interval: 1000 }\n * ```\n *\n * @param {SchedulerLike} [scheduler] Scheduler used to get the current time.\n * @return A function that returns an Observable that emits information about\n * value and interval.\n */\nexport function timeInterval<T>(scheduler: SchedulerLike = asyncScheduler): OperatorFunction<T, TimeInterval<T>> {\n  return operate((source, subscriber) => {\n    let last = scheduler.now();\n    source.subscribe(\n      createOperatorSubscriber(subscriber, (value) => {\n        const now = scheduler.now();\n        const interval = now - last;\n        last = now;\n        subscriber.next(new TimeInterval(value, interval));\n      })\n    );\n  });\n}\n\n// TODO(benlesh): make this an interface, export the interface, but not the implemented class,\n// there's no reason users should be manually creating this type.\n\nexport class TimeInterval<T> {\n  /**\n   * @deprecated Internal implementation detail, do not construct directly. Will be made an interface in v8.\n   */\n  constructor(public value: T, public interval: number) {}\n}\n","import { asyncScheduler } from '../scheduler/async';\nimport { MonoTypeOperatorFunction, SchedulerLike, OperatorFunction, ObservableInput, ObservedValueOf } from '../types';\nimport { isValidDate } from '../util/isDate';\nimport { Subscription } from '../Subscription';\nimport { operate } from '../util/lift';\nimport { Observable } from '../Observable';\nimport { innerFrom } from '../observable/innerFrom';\nimport { createErrorClass } from '../util/createErrorClass';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nimport { executeSchedule } from '../util/executeSchedule';\n\nexport interface TimeoutConfig<T, O extends ObservableInput<unknown> = ObservableInput<T>, M = unknown> {\n  /**\n   * The time allowed between values from the source before timeout is triggered.\n   */\n  each?: number;\n\n  /**\n   * The relative time as a `number` in milliseconds, or a specific time as a `Date` object,\n   * by which the first value must arrive from the source before timeout is triggered.\n   */\n  first?: number | Date;\n\n  /**\n   * The scheduler to use with time-related operations within this operator. Defaults to {@link asyncScheduler}\n   */\n  scheduler?: SchedulerLike;\n\n  /**\n   * A factory used to create observable to switch to when timeout occurs. Provides\n   * a {@link TimeoutInfo} about the source observable's emissions and what delay or\n   * exact time triggered the timeout.\n   */\n  with?: (info: TimeoutInfo<T, M>) => O;\n\n  /**\n   * Optional additional metadata you can provide to code that handles\n   * the timeout, will be provided through the {@link TimeoutError}.\n   * This can be used to help identify the source of a timeout or pass along\n   * other information related to the timeout.\n   */\n  meta?: M;\n}\n\nexport interface TimeoutInfo<T, M = unknown> {\n  /** Optional metadata that was provided to the timeout configuration. */\n  readonly meta: M;\n  /** The number of messages seen before the timeout */\n  readonly seen: number;\n  /** The last message seen */\n  readonly lastValue: T | null;\n}\n\n/**\n * An error emitted when a timeout occurs.\n */\nexport interface TimeoutError<T = unknown, M = unknown> extends Error {\n  /**\n   * The information provided to the error by the timeout\n   * operation that created the error. Will be `null` if\n   * used directly in non-RxJS code with an empty constructor.\n   * (Note that using this constructor directly is not recommended,\n   * you should create your own errors)\n   */\n  info: TimeoutInfo<T, M> | null;\n}\n\nexport interface TimeoutErrorCtor {\n  /**\n   * @deprecated Internal implementation detail. Do not construct error instances.\n   * Cannot be tagged as internal: https://github.com/ReactiveX/rxjs/issues/6269\n   */\n  new <T = unknown, M = unknown>(info?: TimeoutInfo<T, M>): TimeoutError<T, M>;\n}\n\n/**\n * An error thrown by the {@link timeout} operator.\n *\n * Provided so users can use as a type and do quality comparisons.\n * We recommend you do not subclass this or create instances of this class directly.\n * If you have need of a error representing a timeout, you should\n * create your own error class and use that.\n *\n * @see {@link timeout}\n *\n * @class TimeoutError\n */\nexport const TimeoutError: TimeoutErrorCtor = createErrorClass(\n  (_super) =>\n    function TimeoutErrorImpl(this: any, info: TimeoutInfo<any> | null = null) {\n      _super(this);\n      this.message = 'Timeout has occurred';\n      this.name = 'TimeoutError';\n      this.info = info;\n    }\n);\n\n/**\n * If `with` is provided, this will return an observable that will switch to a different observable if the source\n * does not push values within the specified time parameters.\n *\n * <span class=\"informal\">The most flexible option for creating a timeout behavior.</span>\n *\n * The first thing to know about the configuration is if you do not provide a `with` property to the configuration,\n * when timeout conditions are met, this operator will emit a {@link TimeoutError}. Otherwise, it will use the factory\n * function provided by `with`, and switch your subscription to the result of that. Timeout conditions are provided by\n * the settings in `first` and `each`.\n *\n * The `first` property can be either a `Date` for a specific time, a `number` for a time period relative to the\n * point of subscription, or it can be skipped. This property is to check timeout conditions for the arrival of\n * the first value from the source _only_. The timings of all subsequent values  from the source will be checked\n * against the time period provided by `each`, if it was provided.\n *\n * The `each` property can be either a `number` or skipped. If a value for `each` is provided, it represents the amount of\n * time the resulting observable will wait between the arrival of values from the source before timing out. Note that if\n * `first` is _not_ provided, the value from `each` will be used to check timeout conditions for the arrival of the first\n * value and all subsequent values. If `first` _is_ provided, `each` will only be use to check all values after the first.\n *\n * ## Examples\n *\n * Emit a custom error if there is too much time between values\n *\n * ```ts\n * import { interval, timeout, throwError } from 'rxjs';\n *\n * class CustomTimeoutError extends Error {\n *   constructor() {\n *     super('It was too slow');\n *     this.name = 'CustomTimeoutError';\n *   }\n * }\n *\n * const slow$ = interval(900);\n *\n * slow$.pipe(\n *   timeout({\n *     each: 1000,\n *     with: () => throwError(() => new CustomTimeoutError())\n *   })\n * )\n * .subscribe({\n *   error: console.error\n * });\n * ```\n *\n * Switch to a faster observable if your source is slow.\n *\n * ```ts\n * import { interval, timeout } from 'rxjs';\n *\n * const slow$ = interval(900);\n * const fast$ = interval(500);\n *\n * slow$.pipe(\n *   timeout({\n *     each: 1000,\n *     with: () => fast$,\n *   })\n * )\n * .subscribe(console.log);\n * ```\n * @param config The configuration for the timeout.\n */\nexport function timeout<T, O extends ObservableInput<unknown>, M = unknown>(\n  config: TimeoutConfig<T, O, M> & { with: (info: TimeoutInfo<T, M>) => O }\n): OperatorFunction<T, T | ObservedValueOf<O>>;\n\n/**\n * Returns an observable that will error or switch to a different observable if the source does not push values\n * within the specified time parameters.\n *\n * <span class=\"informal\">The most flexible option for creating a timeout behavior.</span>\n *\n * The first thing to know about the configuration is if you do not provide a `with` property to the configuration,\n * when timeout conditions are met, this operator will emit a {@link TimeoutError}. Otherwise, it will use the factory\n * function provided by `with`, and switch your subscription to the result of that. Timeout conditions are provided by\n * the settings in `first` and `each`.\n *\n * The `first` property can be either a `Date` for a specific time, a `number` for a time period relative to the\n * point of subscription, or it can be skipped. This property is to check timeout conditions for the arrival of\n * the first value from the source _only_. The timings of all subsequent values  from the source will be checked\n * against the time period provided by `each`, if it was provided.\n *\n * The `each` property can be either a `number` or skipped. If a value for `each` is provided, it represents the amount of\n * time the resulting observable will wait between the arrival of values from the source before timing out. Note that if\n * `first` is _not_ provided, the value from `each` will be used to check timeout conditions for the arrival of the first\n * value and all subsequent values. If `first` _is_ provided, `each` will only be use to check all values after the first.\n *\n * ### Handling TimeoutErrors\n *\n * If no `with` property was provided, subscriptions to the resulting observable may emit an error of {@link TimeoutError}.\n * The timeout error provides useful information you can examine when you're handling the error. The most common way to handle\n * the error would be with {@link catchError}, although you could use {@link tap} or just the error handler in your `subscribe` call\n * directly, if your error handling is only a side effect (such as notifying the user, or logging).\n *\n * In this case, you would check the error for `instanceof TimeoutError` to validate that the error was indeed from `timeout`, and\n * not from some other source. If it's not from `timeout`, you should probably rethrow it if you're in a `catchError`.\n *\n * ## Examples\n *\n * Emit a {@link TimeoutError} if the first value, and _only_ the first value, does not arrive within 5 seconds\n *\n * ```ts\n * import { interval, timeout } from 'rxjs';\n *\n * // A random interval that lasts between 0 and 10 seconds per tick\n * const source$ = interval(Math.round(Math.random() * 10_000));\n *\n * source$.pipe(\n *   timeout({ first: 5_000 })\n * )\n * .subscribe({\n *   next: console.log,\n *   error: console.error\n * });\n * ```\n *\n * Emit a {@link TimeoutError} if the source waits longer than 5 seconds between any two values or the first value\n * and subscription.\n *\n * ```ts\n * import { timer, timeout, expand } from 'rxjs';\n *\n * const getRandomTime = () => Math.round(Math.random() * 10_000);\n *\n * // An observable that waits a random amount of time between each delivered value\n * const source$ = timer(getRandomTime())\n *   .pipe(expand(() => timer(getRandomTime())));\n *\n * source$\n *   .pipe(timeout({ each: 5_000 }))\n *   .subscribe({\n *     next: console.log,\n *     error: console.error\n *   });\n * ```\n *\n * Emit a {@link TimeoutError} if the source does not emit before 7 seconds, _or_ if the source waits longer than\n * 5 seconds between any two values after the first.\n *\n * ```ts\n * import { timer, timeout, expand } from 'rxjs';\n *\n * const getRandomTime = () => Math.round(Math.random() * 10_000);\n *\n * // An observable that waits a random amount of time between each delivered value\n * const source$ = timer(getRandomTime())\n *   .pipe(expand(() => timer(getRandomTime())));\n *\n * source$\n *   .pipe(timeout({ first: 7_000, each: 5_000 }))\n *   .subscribe({\n *     next: console.log,\n *     error: console.error\n *   });\n * ```\n */\nexport function timeout<T, M = unknown>(config: Omit<TimeoutConfig<T, any, M>, 'with'>): OperatorFunction<T, T>;\n\n/**\n * Returns an observable that will error if the source does not push its first value before the specified time passed as a `Date`.\n * This is functionally the same as `timeout({ first: someDate })`.\n *\n * <span class=\"informal\">Errors if the first value doesn't show up before the given date and time</span>\n *\n * ![](timeout.png)\n *\n * @param first The date to at which the resulting observable will timeout if the source observable\n * does not emit at least one value.\n * @param scheduler The scheduler to use. Defaults to {@link asyncScheduler}.\n */\nexport function timeout<T>(first: Date, scheduler?: SchedulerLike): MonoTypeOperatorFunction<T>;\n\n/**\n * Returns an observable that will error if the source does not push a value within the specified time in milliseconds.\n * This is functionally the same as `timeout({ each: milliseconds })`.\n *\n * <span class=\"informal\">Errors if it waits too long between any value</span>\n *\n * ![](timeout.png)\n *\n * @param each The time allowed between each pushed value from the source before the resulting observable\n * will timeout.\n * @param scheduler The scheduler to use. Defaults to {@link asyncScheduler}.\n */\nexport function timeout<T>(each: number, scheduler?: SchedulerLike): MonoTypeOperatorFunction<T>;\n\n/**\n *\n * Errors if Observable does not emit a value in given time span.\n *\n * <span class=\"informal\">Timeouts on Observable that doesn't emit values fast enough.</span>\n *\n * ![](timeout.png)\n *\n * @see {@link timeoutWith}\n *\n * @return A function that returns an Observable that mirrors behaviour of the\n * source Observable, unless timeout happens when it throws an error.\n */\nexport function timeout<T, O extends ObservableInput<any>, M>(\n  config: number | Date | TimeoutConfig<T, O, M>,\n  schedulerArg?: SchedulerLike\n): OperatorFunction<T, T | ObservedValueOf<O>> {\n  // Intentionally terse code.\n  // If the first argument is a valid `Date`, then we use it as the `first` config.\n  // Otherwise, if the first argument is a `number`, then we use it as the `each` config.\n  // Otherwise, it can be assumed the first argument is the configuration object itself, and\n  // we destructure that into what we're going to use, setting important defaults as we do.\n  // NOTE: The default for `scheduler` will be the `scheduler` argument if it exists, or\n  // it will default to the `asyncScheduler`.\n  const {\n    first,\n    each,\n    with: _with = timeoutErrorFactory,\n    scheduler = schedulerArg ?? asyncScheduler,\n    meta = null!,\n  } = (isValidDate(config) ? { first: config } : typeof config === 'number' ? { each: config } : config) as TimeoutConfig<T, O, M>;\n\n  if (first == null && each == null) {\n    // Ensure timeout was provided at runtime.\n    throw new TypeError('No timeout provided.');\n  }\n\n  return operate((source, subscriber) => {\n    // This subscription encapsulates our subscription to the\n    // source for this operator. We're capturing it separately,\n    // because if there is a `with` observable to fail over to,\n    // we want to unsubscribe from our original subscription, and\n    // hand of the subscription to that one.\n    let originalSourceSubscription: Subscription;\n    // The subscription for our timeout timer. This changes\n    // every time we get a new value.\n    let timerSubscription: Subscription;\n    // A bit of state we pass to our with and error factories to\n    // tell what the last value we saw was.\n    let lastValue: T | null = null;\n    // A bit of state we pass to the with and error factories to\n    // tell how many values we have seen so far.\n    let seen = 0;\n    const startTimer = (delay: number) => {\n      timerSubscription = executeSchedule(\n        subscriber,\n        scheduler,\n        () => {\n          try {\n            originalSourceSubscription.unsubscribe();\n            innerFrom(\n              _with!({\n                meta,\n                lastValue,\n                seen,\n              })\n            ).subscribe(subscriber);\n          } catch (err) {\n            subscriber.error(err);\n          }\n        },\n        delay\n      );\n    };\n\n    originalSourceSubscription = source.subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        (value: T) => {\n          // clear the timer so we can emit and start another one.\n          timerSubscription?.unsubscribe();\n          seen++;\n          // Emit\n          subscriber.next((lastValue = value));\n          // null | undefined are both < 0. Thanks, JavaScript.\n          each! > 0 && startTimer(each!);\n        },\n        undefined,\n        undefined,\n        () => {\n          if (!timerSubscription?.closed) {\n            timerSubscription?.unsubscribe();\n          }\n          // Be sure not to hold the last value in memory after unsubscription\n          // it could be quite large.\n          lastValue = null;\n        }\n      )\n    );\n\n    // Intentionally terse code.\n    // If we've `seen` a value, that means the \"first\" clause was met already, if it existed.\n    //   it also means that a timer was already started for \"each\" (in the next handler above).\n    // If `first` was provided, and it's a number, then use it.\n    // If `first` was provided and it's not a number, it's a Date, and we get the difference between it and \"now\".\n    // If `first` was not provided at all, then our first timer will be the value from `each`.\n    !seen && startTimer(first != null ? (typeof first === 'number' ? first : +first - scheduler!.now()) : each!);\n  });\n}\n\n/**\n * The default function to use to emit an error when timeout occurs and a `with` function\n * is not specified.\n * @param info The information about the timeout to pass along to the error\n */\nfunction timeoutErrorFactory(info: TimeoutInfo<any>): Observable<never> {\n  throw new TimeoutError(info);\n}\n","import { async } from '../scheduler/async';\nimport { isValidDate } from '../util/isDate';\nimport { ObservableInput, OperatorFunction, SchedulerLike } from '../types';\nimport { timeout } from './timeout';\n\n/** @deprecated Replaced with {@link timeout}. Instead of `timeoutWith(someDate, a$, scheduler)`, use the configuration object\n * `timeout({ first: someDate, with: () => a$, scheduler })`. Will be removed in v8. */\nexport function timeoutWith<T, R>(dueBy: Date, switchTo: ObservableInput<R>, scheduler?: SchedulerLike): OperatorFunction<T, T | R>;\n/** @deprecated Replaced with {@link timeout}. Instead of `timeoutWith(100, a$, scheduler)`, use the configuration object\n *  `timeout({ each: 100, with: () => a$, scheduler })`. Will be removed in v8. */\nexport function timeoutWith<T, R>(waitFor: number, switchTo: ObservableInput<R>, scheduler?: SchedulerLike): OperatorFunction<T, T | R>;\n\n/**\n * When the passed timespan elapses before the source emits any given value, it will unsubscribe from the source,\n * and switch the subscription to another observable.\n *\n * <span class=\"informal\">Used to switch to a different observable if your source is being slow.</span>\n *\n * Useful in cases where:\n *\n * - You want to switch to a different source that may be faster.\n * - You want to notify a user that the data stream is slow.\n * - You want to emit a custom error rather than the {@link TimeoutError} emitted\n *   by the default usage of {@link timeout}.\n *\n * If the first parameter is passed as Date and the time of the Date arrives before the first value arrives from the source,\n * it will unsubscribe from the source and switch the subscription to another observable.\n *\n * <span class=\"informal\">Use Date object to switch to a different observable if the first value doesn't arrive by a specific time.</span>\n *\n * Can be used to set a timeout only for the first value, however it's recommended to use the {@link timeout} operator with\n * the `first` configuration to get the same effect.\n *\n * ## Examples\n *\n * Fallback to a faster observable\n *\n * ```ts\n * import { interval, timeoutWith } from 'rxjs';\n *\n * const slow$ = interval(1000);\n * const faster$ = interval(500);\n *\n * slow$\n *   .pipe(timeoutWith(900, faster$))\n *   .subscribe(console.log);\n * ```\n *\n * Emit your own custom timeout error\n *\n * ```ts\n * import { interval, timeoutWith, throwError } from 'rxjs';\n *\n * class CustomTimeoutError extends Error {\n *   constructor() {\n *     super('It was too slow');\n *     this.name = 'CustomTimeoutError';\n *   }\n * }\n *\n * const slow$ = interval(1000);\n *\n * slow$\n *   .pipe(timeoutWith(900, throwError(() => new CustomTimeoutError())))\n *   .subscribe({\n *     error: err => console.error(err.message)\n *   });\n * ```\n *\n * @see {@link timeout}\n *\n * @param due When passed a number, used as the time (in milliseconds) allowed between each value from the source before timeout\n * is triggered. When passed a Date, used as the exact time at which the timeout will be triggered if the first value does not arrive.\n * @param withObservable The observable to switch to when timeout occurs.\n * @param scheduler The scheduler to use with time-related operations within this operator. Defaults to {@link asyncScheduler}\n * @return A function that returns an Observable that mirrors behaviour of the\n * source Observable, unless timeout happens when it starts emitting values\n * from the `ObservableInput` passed as a second parameter.\n * @deprecated Replaced with {@link timeout}. Instead of `timeoutWith(100, a$, scheduler)`, use {@link timeout} with the configuration\n * object: `timeout({ each: 100, with: () => a$, scheduler })`. Instead of `timeoutWith(someDate, a$, scheduler)`, use {@link timeout}\n * with the configuration object: `timeout({ first: someDate, with: () => a$, scheduler })`. Will be removed in v8.\n */\nexport function timeoutWith<T, R>(\n  due: number | Date,\n  withObservable: ObservableInput<R>,\n  scheduler?: SchedulerLike\n): OperatorFunction<T, T | R> {\n  let first: number | Date | undefined;\n  let each: number | undefined;\n  let _with: () => ObservableInput<R>;\n  scheduler = scheduler ?? async;\n\n  if (isValidDate(due)) {\n    first = due;\n  } else if (typeof due === 'number') {\n    each = due;\n  }\n\n  if (withObservable) {\n    _with = () => withObservable;\n  } else {\n    throw new TypeError('No observable provided to switch to');\n  }\n\n  if (first == null && each == null) {\n    // Ensure timeout was provided at runtime.\n    throw new TypeError('No timeout provided.');\n  }\n\n  return timeout<T, ObservableInput<R>>({\n    first,\n    each,\n    scheduler,\n    with: _with,\n  });\n}\n","import { OperatorFunction, TimestampProvider, Timestamp } from '../types';\nimport { dateTimestampProvider } from '../scheduler/dateTimestampProvider';\nimport { map } from './map';\n\n/**\n * Attaches a timestamp to each item emitted by an observable indicating when it was emitted\n *\n * The `timestamp` operator maps the *source* observable stream to an object of type\n * `{value: T, timestamp: R}`. The properties are generically typed. The `value` property contains the value\n * and type of the *source* observable. The `timestamp` is generated by the schedulers `now` function. By\n * default, it uses the `asyncScheduler` which simply returns `Date.now()` (milliseconds since 1970/01/01\n * 00:00:00:000) and therefore is of type `number`.\n *\n * ![](timestamp.png)\n *\n * ## Example\n *\n * In this example there is a timestamp attached to the document's click events\n *\n * ```ts\n * import { fromEvent, timestamp } from 'rxjs';\n *\n * const clickWithTimestamp = fromEvent(document, 'click').pipe(\n *   timestamp()\n * );\n *\n * // Emits data of type { value: PointerEvent, timestamp: number }\n * clickWithTimestamp.subscribe(data => {\n *   console.log(data);\n * });\n * ```\n *\n * @param timestampProvider An object with a `now()` method used to get the current timestamp.\n * @return A function that returns an Observable that attaches a timestamp to\n * each item emitted by the source Observable indicating when it was emitted.\n */\nexport function timestamp<T>(timestampProvider: TimestampProvider = dateTimestampProvider): OperatorFunction<T, Timestamp<T>> {\n  return map((value: T) => ({ value, timestamp: timestampProvider.now() }));\n}\n","import { reduce } from './reduce';\nimport { OperatorFunction } from '../types';\nimport { operate } from '../util/lift';\n\nconst arrReducer = (arr: any[], value: any) => (arr.push(value), arr);\n\n/**\n * Collects all source emissions and emits them as an array when the source completes.\n *\n * <span class=\"informal\">Get all values inside an array when the source completes</span>\n *\n * ![](toArray.png)\n *\n * `toArray` will wait until the source Observable completes before emitting\n * the array containing all emissions. When the source Observable errors no\n * array will be emitted.\n *\n * ## Example\n *\n * ```ts\n * import { interval, take, toArray } from 'rxjs';\n *\n * const source = interval(1000);\n * const example = source.pipe(\n *   take(10),\n *   toArray()\n * );\n *\n * example.subscribe(value => console.log(value));\n *\n * // output: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n * ```\n *\n * @return A function that returns an Observable that emits an array of items\n * emitted by the source Observable when source completes.\n */\nexport function toArray<T>(): OperatorFunction<T, T[]> {\n  // Because arrays are mutable, and we're mutating the array in this\n  // reducer process, we have to encapsulate the creation of the initial\n  // array within this `operate` function.\n  return operate((source, subscriber) => {\n    reduce(arrReducer, [] as T[])(source).subscribe(subscriber);\n  });\n}\n","import { Observable } from '../Observable';\nimport { OperatorFunction, ObservableInput } from '../types';\nimport { Subject } from '../Subject';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nimport { noop } from '../util/noop';\nimport { innerFrom } from '../observable/innerFrom';\n\n/**\n * Branch out the source Observable values as a nested Observable whenever\n * `windowBoundaries` emits.\n *\n * <span class=\"informal\">It's like {@link buffer}, but emits a nested Observable\n * instead of an array.</span>\n *\n * ![](window.png)\n *\n * Returns an Observable that emits windows of items it collects from the source\n * Observable. The output Observable emits connected, non-overlapping\n * windows. It emits the current window and opens a new one whenever the\n * `windowBoundaries` emits an item. `windowBoundaries` can be any type that\n * `ObservableInput` accepts. It internally gets converted to an Observable.\n * Because each window is an Observable, the output is a higher-order Observable.\n *\n * ## Example\n *\n * In every window of 1 second each, emit at most 2 click events\n *\n * ```ts\n * import { fromEvent, interval, window, map, take, mergeAll } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const sec = interval(1000);\n * const result = clicks.pipe(\n *   window(sec),\n *   map(win => win.pipe(take(2))), // take at most 2 emissions from each window\n *   mergeAll()                     // flatten the Observable-of-Observables\n * );\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link windowCount}\n * @see {@link windowTime}\n * @see {@link windowToggle}\n * @see {@link windowWhen}\n * @see {@link buffer}\n *\n * @param windowBoundaries An `ObservableInput` that completes the\n * previous window and starts a new window.\n * @return A function that returns an Observable of windows, which are\n * Observables emitting values of the source Observable.\n */\nexport function window<T>(windowBoundaries: ObservableInput<any>): OperatorFunction<T, Observable<T>> {\n  return operate((source, subscriber) => {\n    let windowSubject: Subject<T> = new Subject<T>();\n\n    subscriber.next(windowSubject.asObservable());\n\n    const errorHandler = (err: any) => {\n      windowSubject.error(err);\n      subscriber.error(err);\n    };\n\n    // Subscribe to our source\n    source.subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        (value) => windowSubject?.next(value),\n        () => {\n          windowSubject.complete();\n          subscriber.complete();\n        },\n        errorHandler\n      )\n    );\n\n    // Subscribe to the window boundaries.\n    innerFrom(windowBoundaries).subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        () => {\n          windowSubject.complete();\n          subscriber.next((windowSubject = new Subject()));\n        },\n        noop,\n        errorHandler\n      )\n    );\n\n    return () => {\n      // Unsubscribing the subject ensures that anyone who has captured\n      // a reference to this window that tries to use it after it can\n      // no longer get values from the source will get an ObjectUnsubscribedError.\n      windowSubject?.unsubscribe();\n      windowSubject = null!;\n    };\n  });\n}\n","import { Observable } from '../Observable';\nimport { Subject } from '../Subject';\nimport { OperatorFunction } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\n/**\n * Branch out the source Observable values as a nested Observable with each\n * nested Observable emitting at most `windowSize` values.\n *\n * <span class=\"informal\">It's like {@link bufferCount}, but emits a nested\n * Observable instead of an array.</span>\n *\n * ![](windowCount.png)\n *\n * Returns an Observable that emits windows of items it collects from the source\n * Observable. The output Observable emits windows every `startWindowEvery`\n * items, each containing no more than `windowSize` items. When the source\n * Observable completes or encounters an error, the output Observable emits\n * the current window and propagates the notification from the source\n * Observable. If `startWindowEvery` is not provided, then new windows are\n * started immediately at the start of the source and when each window completes\n * with size `windowSize`.\n *\n * ## Examples\n *\n * Ignore every 3rd click event, starting from the first one\n *\n * ```ts\n * import { fromEvent, windowCount, map, skip, mergeAll } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(\n *   windowCount(3),\n *   map(win => win.pipe(skip(1))), // skip first of every 3 clicks\n *   mergeAll()                     // flatten the Observable-of-Observables\n * );\n * result.subscribe(x => console.log(x));\n * ```\n *\n * Ignore every 3rd click event, starting from the third one\n *\n * ```ts\n * import { fromEvent, windowCount, mergeAll } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(\n *   windowCount(2, 3),\n *   mergeAll() // flatten the Observable-of-Observables\n * );\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link window}\n * @see {@link windowTime}\n * @see {@link windowToggle}\n * @see {@link windowWhen}\n * @see {@link bufferCount}\n *\n * @param {number} windowSize The maximum number of values emitted by each\n * window.\n * @param {number} [startWindowEvery] Interval at which to start a new window.\n * For example if `startWindowEvery` is `2`, then a new window will be started\n * on every other value from the source. A new window is started at the\n * beginning of the source by default.\n * @return A function that returns an Observable of windows, which in turn are\n * Observable of values.\n */\nexport function windowCount<T>(windowSize: number, startWindowEvery: number = 0): OperatorFunction<T, Observable<T>> {\n  const startEvery = startWindowEvery > 0 ? startWindowEvery : windowSize;\n\n  return operate((source, subscriber) => {\n    let windows = [new Subject<T>()];\n    let starts: number[] = [];\n    let count = 0;\n\n    // Open the first window.\n    subscriber.next(windows[0].asObservable());\n\n    source.subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        (value: T) => {\n          // Emit the value through all current windows.\n          // We don't need to create a new window yet, we\n          // do that as soon as we close one.\n          for (const window of windows) {\n            window.next(value);\n          }\n          // Here we're using the size of the window array to figure\n          // out if the oldest window has emitted enough values. We can do this\n          // because the size of the window array is a function of the values\n          // seen by the subscription. If it's time to close it, we complete\n          // it and remove it.\n          const c = count - windowSize + 1;\n          if (c >= 0 && c % startEvery === 0) {\n            windows.shift()!.complete();\n          }\n\n          // Look to see if the next count tells us it's time to open a new window.\n          // TODO: We need to figure out if this really makes sense. We're technically\n          // emitting windows *before* we have a value to emit them for. It's probably\n          // more expected that we should be emitting the window when the start\n          // count is reached -- not before.\n          if (++count % startEvery === 0) {\n            const window = new Subject<T>();\n            windows.push(window);\n            subscriber.next(window.asObservable());\n          }\n        },\n        () => {\n          while (windows.length > 0) {\n            windows.shift()!.complete();\n          }\n          subscriber.complete();\n        },\n        (err) => {\n          while (windows.length > 0) {\n            windows.shift()!.error(err);\n          }\n          subscriber.error(err);\n        },\n        () => {\n          starts = null!;\n          windows = null!;\n        }\n      )\n    );\n  });\n}\n","import { Subject } from '../Subject';\nimport { asyncScheduler } from '../scheduler/async';\nimport { Observable } from '../Observable';\nimport { Subscription } from '../Subscription';\nimport { Observer, OperatorFunction, SchedulerLike } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nimport { arrRemove } from '../util/arrRemove';\nimport { popScheduler } from '../util/args';\nimport { executeSchedule } from '../util/executeSchedule';\n\nexport function windowTime<T>(windowTimeSpan: number, scheduler?: SchedulerLike): OperatorFunction<T, Observable<T>>;\nexport function windowTime<T>(\n  windowTimeSpan: number,\n  windowCreationInterval: number,\n  scheduler?: SchedulerLike\n): OperatorFunction<T, Observable<T>>;\nexport function windowTime<T>(\n  windowTimeSpan: number,\n  windowCreationInterval: number | null | void,\n  maxWindowSize: number,\n  scheduler?: SchedulerLike\n): OperatorFunction<T, Observable<T>>;\n\n/**\n * Branch out the source Observable values as a nested Observable periodically\n * in time.\n *\n * <span class=\"informal\">It's like {@link bufferTime}, but emits a nested\n * Observable instead of an array.</span>\n *\n * ![](windowTime.png)\n *\n * Returns an Observable that emits windows of items it collects from the source\n * Observable. The output Observable starts a new window periodically, as\n * determined by the `windowCreationInterval` argument. It emits each window\n * after a fixed timespan, specified by the `windowTimeSpan` argument. When the\n * source Observable completes or encounters an error, the output Observable\n * emits the current window and propagates the notification from the source\n * Observable. If `windowCreationInterval` is not provided, the output\n * Observable starts a new window when the previous window of duration\n * `windowTimeSpan` completes. If `maxWindowCount` is provided, each window\n * will emit at most fixed number of values. Window will complete immediately\n * after emitting last value and next one still will open as specified by\n * `windowTimeSpan` and `windowCreationInterval` arguments.\n *\n * ## Examples\n *\n * In every window of 1 second each, emit at most 2 click events\n *\n * ```ts\n * import { fromEvent, windowTime, map, take, mergeAll } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(\n *   windowTime(1000),\n *   map(win => win.pipe(take(2))), // take at most 2 emissions from each window\n *   mergeAll()                     // flatten the Observable-of-Observables\n * );\n * result.subscribe(x => console.log(x));\n * ```\n *\n * Every 5 seconds start a window 1 second long, and emit at most 2 click events per window\n *\n * ```ts\n * import { fromEvent, windowTime, map, take, mergeAll } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(\n *   windowTime(1000, 5000),\n *   map(win => win.pipe(take(2))), // take at most 2 emissions from each window\n *   mergeAll()                     // flatten the Observable-of-Observables\n * );\n * result.subscribe(x => console.log(x));\n * ```\n *\n * Same as example above but with `maxWindowCount` instead of `take`\n *\n * ```ts\n * import { fromEvent, windowTime, mergeAll } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(\n *   windowTime(1000, 5000, 2), // take at most 2 emissions from each window\n *   mergeAll()                 // flatten the Observable-of-Observables\n * );\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link window}\n * @see {@link windowCount}\n * @see {@link windowToggle}\n * @see {@link windowWhen}\n * @see {@link bufferTime}\n *\n * @param windowTimeSpan The amount of time, in milliseconds, to fill each window.\n * @param windowCreationInterval The interval at which to start new\n * windows.\n * @param maxWindowSize Max number of\n * values each window can emit before completion.\n * @param scheduler The scheduler on which to schedule the\n * intervals that determine window boundaries.\n * @return A function that returns an Observable of windows, which in turn are\n * Observables.\n */\nexport function windowTime<T>(windowTimeSpan: number, ...otherArgs: any[]): OperatorFunction<T, Observable<T>> {\n  const scheduler = popScheduler(otherArgs) ?? asyncScheduler;\n  const windowCreationInterval = (otherArgs[0] as number) ?? null;\n  const maxWindowSize = (otherArgs[1] as number) || Infinity;\n\n  return operate((source, subscriber) => {\n    // The active windows, their related subscriptions, and removal functions.\n    let windowRecords: WindowRecord<T>[] | null = [];\n    // If true, it means that every time we close a window, we want to start a new window.\n    // This is only really used for when *just* the time span is passed.\n    let restartOnClose = false;\n\n    const closeWindow = (record: { window: Subject<T>; subs: Subscription }) => {\n      const { window, subs } = record;\n      window.complete();\n      subs.unsubscribe();\n      arrRemove(windowRecords, record);\n      restartOnClose && startWindow();\n    };\n\n    /**\n     * Called every time we start a new window. This also does\n     * the work of scheduling the job to close the window.\n     */\n    const startWindow = () => {\n      if (windowRecords) {\n        const subs = new Subscription();\n        subscriber.add(subs);\n        const window = new Subject<T>();\n        const record = {\n          window,\n          subs,\n          seen: 0,\n        };\n        windowRecords.push(record);\n        subscriber.next(window.asObservable());\n        executeSchedule(subs, scheduler, () => closeWindow(record), windowTimeSpan);\n      }\n    };\n\n    if (windowCreationInterval !== null && windowCreationInterval >= 0) {\n      // The user passed both a windowTimeSpan (required), and a creation interval\n      // That means we need to start new window on the interval, and those windows need\n      // to wait the required time span before completing.\n      executeSchedule(subscriber, scheduler, startWindow, windowCreationInterval, true);\n    } else {\n      restartOnClose = true;\n    }\n\n    startWindow();\n\n    /**\n     * We need to loop over a copy of the window records several times in this operator.\n     * This is to save bytes over the wire more than anything.\n     * The reason we copy the array is that reentrant code could mutate the array while\n     * we are iterating over it.\n     */\n    const loop = (cb: (record: WindowRecord<T>) => void) => windowRecords!.slice().forEach(cb);\n\n    /**\n     * Used to notify all of the windows and the subscriber in the same way\n     * in the error and complete handlers.\n     */\n    const terminate = (cb: (consumer: Observer<any>) => void) => {\n      loop(({ window }) => cb(window));\n      cb(subscriber);\n      subscriber.unsubscribe();\n    };\n\n    source.subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        (value: T) => {\n          // Notify all windows of the value.\n          loop((record) => {\n            record.window.next(value);\n            // If the window is over the max size, we need to close it.\n            maxWindowSize <= ++record.seen && closeWindow(record);\n          });\n        },\n        // Complete the windows and the downstream subscriber and clean up.\n        () => terminate((consumer) => consumer.complete()),\n        // Notify the windows and the downstream subscriber of the error and clean up.\n        (err) => terminate((consumer) => consumer.error(err))\n      )\n    );\n\n    // Additional finalization. This will be called when the\n    // destination tears down. Other finalizations are registered implicitly\n    // above via subscription.\n    return () => {\n      // Ensure that the buffer is released.\n      windowRecords = null!;\n    };\n  });\n}\n\ninterface WindowRecord<T> {\n  seen: number;\n  window: Subject<T>;\n  subs: Subscription;\n}\n","import { Observable } from '../Observable';\nimport { Subject } from '../Subject';\nimport { Subscription } from '../Subscription';\nimport { ObservableInput, OperatorFunction } from '../types';\nimport { operate } from '../util/lift';\nimport { innerFrom } from '../observable/innerFrom';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nimport { noop } from '../util/noop';\nimport { arrRemove } from '../util/arrRemove';\n\n/**\n * Branch out the source Observable values as a nested Observable starting from\n * an emission from `openings` and ending when the output of `closingSelector`\n * emits.\n *\n * <span class=\"informal\">It's like {@link bufferToggle}, but emits a nested\n * Observable instead of an array.</span>\n *\n * ![](windowToggle.png)\n *\n * Returns an Observable that emits windows of items it collects from the source\n * Observable. The output Observable emits windows that contain those items\n * emitted by the source Observable between the time when the `openings`\n * Observable emits an item and when the Observable returned by\n * `closingSelector` emits an item.\n *\n * ## Example\n *\n * Every other second, emit the click events from the next 500ms\n *\n * ```ts\n * import { fromEvent, interval, windowToggle, EMPTY, mergeAll } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const openings = interval(1000);\n * const result = clicks.pipe(\n *   windowToggle(openings, i => i % 2 ? interval(500) : EMPTY),\n *   mergeAll()\n * );\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link window}\n * @see {@link windowCount}\n * @see {@link windowTime}\n * @see {@link windowWhen}\n * @see {@link bufferToggle}\n *\n * @param {Observable<O>} openings An observable of notifications to start new\n * windows.\n * @param {function(value: O): Observable} closingSelector A function that takes\n * the value emitted by the `openings` observable and returns an Observable,\n * which, when it emits a next notification, signals that the\n * associated window should complete.\n * @return A function that returns an Observable of windows, which in turn are\n * Observables.\n */\nexport function windowToggle<T, O>(\n  openings: ObservableInput<O>,\n  closingSelector: (openValue: O) => ObservableInput<any>\n): OperatorFunction<T, Observable<T>> {\n  return operate((source, subscriber) => {\n    const windows: Subject<T>[] = [];\n\n    const handleError = (err: any) => {\n      while (0 < windows.length) {\n        windows.shift()!.error(err);\n      }\n      subscriber.error(err);\n    };\n\n    innerFrom(openings).subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        (openValue) => {\n          const window = new Subject<T>();\n          windows.push(window);\n          const closingSubscription = new Subscription();\n          const closeWindow = () => {\n            arrRemove(windows, window);\n            window.complete();\n            closingSubscription.unsubscribe();\n          };\n\n          let closingNotifier: Observable<any>;\n          try {\n            closingNotifier = innerFrom(closingSelector(openValue));\n          } catch (err) {\n            handleError(err);\n            return;\n          }\n\n          subscriber.next(window.asObservable());\n\n          closingSubscription.add(closingNotifier.subscribe(createOperatorSubscriber(subscriber, closeWindow, noop, handleError)));\n        },\n        noop\n      )\n    );\n\n    // Subscribe to the source to get things started.\n    source.subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        (value: T) => {\n          // Copy the windows array before we emit to\n          // make sure we don't have issues with reentrant code.\n          const windowsCopy = windows.slice();\n          for (const window of windowsCopy) {\n            window.next(value);\n          }\n        },\n        () => {\n          // Complete all of our windows before we complete.\n          while (0 < windows.length) {\n            windows.shift()!.complete();\n          }\n          subscriber.complete();\n        },\n        handleError,\n        () => {\n          // Add this finalization so that all window subjects are\n          // disposed of. This way, if a user tries to subscribe\n          // to a window *after* the outer subscription has been unsubscribed,\n          // they will get an error, instead of waiting forever to\n          // see if a value arrives.\n          while (0 < windows.length) {\n            windows.shift()!.unsubscribe();\n          }\n        }\n      )\n    );\n  });\n}\n","import { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { Subject } from '../Subject';\nimport { ObservableInput, OperatorFunction } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nimport { innerFrom } from '../observable/innerFrom';\n\n/**\n * Branch out the source Observable values as a nested Observable using a\n * factory function of closing Observables to determine when to start a new\n * window.\n *\n * <span class=\"informal\">It's like {@link bufferWhen}, but emits a nested\n * Observable instead of an array.</span>\n *\n * ![](windowWhen.png)\n *\n * Returns an Observable that emits windows of items it collects from the source\n * Observable. The output Observable emits connected, non-overlapping windows.\n * It emits the current window and opens a new one whenever the Observable\n * produced by the specified `closingSelector` function emits an item. The first\n * window is opened immediately when subscribing to the output Observable.\n *\n * ## Example\n *\n * Emit only the first two clicks events in every window of [1-5] random seconds\n *\n * ```ts\n * import { fromEvent, windowWhen, interval, map, take, mergeAll } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(\n *   windowWhen(() => interval(1000 + Math.random() * 4000)),\n *   map(win => win.pipe(take(2))), // take at most 2 emissions from each window\n *   mergeAll()                     // flatten the Observable-of-Observables\n * );\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link window}\n * @see {@link windowCount}\n * @see {@link windowTime}\n * @see {@link windowToggle}\n * @see {@link bufferWhen}\n *\n * @param {function(): Observable} closingSelector A function that takes no\n * arguments and returns an Observable that signals (on either `next` or\n * `complete`) when to close the previous window and start a new one.\n * @return A function that returns an Observable of windows, which in turn are\n * Observables.\n */\nexport function windowWhen<T>(closingSelector: () => ObservableInput<any>): OperatorFunction<T, Observable<T>> {\n  return operate((source, subscriber) => {\n    let window: Subject<T> | null;\n    let closingSubscriber: Subscriber<any> | undefined;\n\n    /**\n     * When we get an error, we have to notify both the\n     * destination subscriber and the window.\n     */\n    const handleError = (err: any) => {\n      window!.error(err);\n      subscriber.error(err);\n    };\n\n    /**\n     * Called every time we need to open a window.\n     * Recursive, as it will start the closing notifier, which\n     * inevitably *should* call openWindow -- but may not if\n     * it is a \"never\" observable.\n     */\n    const openWindow = () => {\n      // We need to clean up our closing subscription,\n      // we only cared about the first next or complete notification.\n      closingSubscriber?.unsubscribe();\n\n      // Close our window before starting a new one.\n      window?.complete();\n\n      // Start the new window.\n      window = new Subject<T>();\n      subscriber.next(window.asObservable());\n\n      // Get our closing notifier.\n      let closingNotifier: Observable<any>;\n      try {\n        closingNotifier = innerFrom(closingSelector());\n      } catch (err) {\n        handleError(err);\n        return;\n      }\n\n      // Subscribe to the closing notifier, be sure\n      // to capture the subscriber (aka Subscription)\n      // so we can clean it up when we close the window\n      // and open a new one.\n      closingNotifier.subscribe((closingSubscriber = createOperatorSubscriber(subscriber, openWindow, openWindow, handleError)));\n    };\n\n    // Start the first window.\n    openWindow();\n\n    // Subscribe to the source\n    source.subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        (value) => window!.next(value),\n        () => {\n          // The source completed, close the window and complete.\n          window!.complete();\n          subscriber.complete();\n        },\n        handleError,\n        () => {\n          // Be sure to clean up our closing subscription\n          // when this tears down.\n          closingSubscriber?.unsubscribe();\n          window = null!;\n        }\n      )\n    );\n  });\n}\n","import { OperatorFunction, ObservableInputTuple } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nimport { innerFrom } from '../observable/innerFrom';\nimport { identity } from '../util/identity';\nimport { noop } from '../util/noop';\nimport { popResultSelector } from '../util/args';\n\nexport function withLatestFrom<T, O extends unknown[]>(...inputs: [...ObservableInputTuple<O>]): OperatorFunction<T, [T, ...O]>;\n\nexport function withLatestFrom<T, O extends unknown[], R>(\n  ...inputs: [...ObservableInputTuple<O>, (...value: [T, ...O]) => R]\n): OperatorFunction<T, R>;\n\n/**\n * Combines the source Observable with other Observables to create an Observable\n * whose values are calculated from the latest values of each, only when the\n * source emits.\n *\n * <span class=\"informal\">Whenever the source Observable emits a value, it\n * computes a formula using that value plus the latest values from other input\n * Observables, then emits the output of that formula.</span>\n *\n * ![](withLatestFrom.png)\n *\n * `withLatestFrom` combines each value from the source Observable (the\n * instance) with the latest values from the other input Observables only when\n * the source emits a value, optionally using a `project` function to determine\n * the value to be emitted on the output Observable. All input Observables must\n * emit at least one value before the output Observable will emit a value.\n *\n * ## Example\n *\n * On every click event, emit an array with the latest timer event plus the click event\n *\n * ```ts\n * import { fromEvent, interval, withLatestFrom } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const timer = interval(1000);\n * const result = clicks.pipe(withLatestFrom(timer));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link combineLatest}\n *\n * @param {ObservableInput} other An input Observable to combine with the source\n * Observable. More than one input Observables may be given as argument.\n * @param {Function} [project] Projection function for combining values\n * together. Receives all values in order of the Observables passed, where the\n * first parameter is a value from the source Observable. (e.g.\n * `a.pipe(withLatestFrom(b, c), map(([a1, b1, c1]) => a1 + b1 + c1))`). If this is not\n * passed, arrays will be emitted on the output Observable.\n * @return A function that returns an Observable of projected values from the\n * most recent values from each input Observable, or an array of the most\n * recent values from each input Observable.\n */\nexport function withLatestFrom<T, R>(...inputs: any[]): OperatorFunction<T, R | any[]> {\n  const project = popResultSelector(inputs) as ((...args: any[]) => R) | undefined;\n\n  return operate((source, subscriber) => {\n    const len = inputs.length;\n    const otherValues = new Array(len);\n    // An array of whether or not the other sources have emitted. Matched with them by index.\n    // TODO: At somepoint, we should investigate the performance implications here, and look\n    // into using a `Set()` and checking the `size` to see if we're ready.\n    let hasValue = inputs.map(() => false);\n    // Flipped true when we have at least one value from all other sources and\n    // we are ready to start emitting values.\n    let ready = false;\n\n    // Other sources. Note that here we are not checking `subscriber.closed`,\n    // this causes all inputs to be subscribed to, even if nothing can be emitted\n    // from them. This is an important distinction because subscription constitutes\n    // a side-effect.\n    for (let i = 0; i < len; i++) {\n      innerFrom(inputs[i]).subscribe(\n        createOperatorSubscriber(\n          subscriber,\n          (value) => {\n            otherValues[i] = value;\n            if (!ready && !hasValue[i]) {\n              // If we're not ready yet, flag to show this observable has emitted.\n              hasValue[i] = true;\n              // Intentionally terse code.\n              // If all of our other observables have emitted, set `ready` to `true`,\n              // so we know we can start emitting values, then clean up the `hasValue` array,\n              // because we don't need it anymore.\n              (ready = hasValue.every(identity)) && (hasValue = null!);\n            }\n          },\n          // Completing one of the other sources has\n          // no bearing on the completion of our result.\n          noop\n        )\n      );\n    }\n\n    // Source subscription\n    source.subscribe(\n      createOperatorSubscriber(subscriber, (value) => {\n        if (ready) {\n          // We have at least one value from the other sources. Go ahead and emit.\n          const values = [value, ...otherValues];\n          subscriber.next(project ? project(...values) : values);\n        }\n      })\n    );\n  });\n}\n","import { zip as zipStatic } from '../observable/zip';\nimport { ObservableInput, ObservableInputTuple, OperatorFunction, Cons } from '../types';\nimport { operate } from '../util/lift';\n\n/** @deprecated Replaced with {@link zipWith}. Will be removed in v8. */\nexport function zip<T, A extends readonly unknown[]>(otherInputs: [...ObservableInputTuple<A>]): OperatorFunction<T, Cons<T, A>>;\n/** @deprecated Replaced with {@link zipWith}. Will be removed in v8. */\nexport function zip<T, A extends readonly unknown[], R>(\n  otherInputsAndProject: [...ObservableInputTuple<A>],\n  project: (...values: Cons<T, A>) => R\n): OperatorFunction<T, R>;\n/** @deprecated Replaced with {@link zipWith}. Will be removed in v8. */\nexport function zip<T, A extends readonly unknown[]>(...otherInputs: [...ObservableInputTuple<A>]): OperatorFunction<T, Cons<T, A>>;\n/** @deprecated Replaced with {@link zipWith}. Will be removed in v8. */\nexport function zip<T, A extends readonly unknown[], R>(\n  ...otherInputsAndProject: [...ObservableInputTuple<A>, (...values: Cons<T, A>) => R]\n): OperatorFunction<T, R>;\n\n/**\n * @deprecated Replaced with {@link zipWith}. Will be removed in v8.\n */\nexport function zip<T, R>(...sources: Array<ObservableInput<any> | ((...values: Array<any>) => R)>): OperatorFunction<T, any> {\n  return operate((source, subscriber) => {\n    zipStatic(source as ObservableInput<any>, ...(sources as Array<ObservableInput<any>>)).subscribe(subscriber);\n  });\n}\n","import { OperatorFunction, ObservableInput } from '../types';\nimport { zip } from '../observable/zip';\nimport { joinAllInternals } from './joinAllInternals';\n\n/**\n * Collects all observable inner sources from the source, once the source completes,\n * it will subscribe to all inner sources, combining their values by index and emitting\n * them.\n *\n * @see {@link zipWith}\n * @see {@link zip}\n */\nexport function zipAll<T>(): OperatorFunction<ObservableInput<T>, T[]>;\nexport function zipAll<T>(): OperatorFunction<any, T[]>;\nexport function zipAll<T, R>(project: (...values: T[]) => R): OperatorFunction<ObservableInput<T>, R>;\nexport function zipAll<R>(project: (...values: Array<any>) => R): OperatorFunction<any, R>;\n\nexport function zipAll<T, R>(project?: (...values: T[]) => R) {\n  return joinAllInternals(zip, project);\n}\n","import { ObservableInputTuple, OperatorFunction, Cons } from '../types';\nimport { zip } from './zip';\n\n/**\n * Subscribes to the source, and the observable inputs provided as arguments, and combines their values, by index, into arrays.\n *\n * What is meant by \"combine by index\": The first value from each will be made into a single array, then emitted,\n * then the second value from each will be combined into a single array and emitted, then the third value\n * from each will be combined into a single array and emitted, and so on.\n *\n * This will continue until it is no longer able to combine values of the same index into an array.\n *\n * After the last value from any one completed source is emitted in an array, the resulting observable will complete,\n * as there is no way to continue \"zipping\" values together by index.\n *\n * Use-cases for this operator are limited. There are memory concerns if one of the streams is emitting\n * values at a much faster rate than the others. Usage should likely be limited to streams that emit\n * at a similar pace, or finite streams of known length.\n *\n * In many cases, authors want `combineLatestWith` and not `zipWith`.\n *\n * @param otherInputs other observable inputs to collate values from.\n * @return A function that returns an Observable that emits items by index\n * combined from the source Observable and provided Observables, in form of an\n * array.\n */\nexport function zipWith<T, A extends readonly unknown[]>(...otherInputs: [...ObservableInputTuple<A>]): OperatorFunction<T, Cons<T, A>> {\n  return zip(...otherInputs);\n}\n","import { Observable } from '../Observable';\nimport { SchedulerLike } from '../types';\n\nexport function scheduleArray<T>(input: ArrayLike<T>, scheduler: SchedulerLike) {\n  return new Observable<T>((subscriber) => {\n    // The current array index.\n    let i = 0;\n    // Start iterating over the array like on a schedule.\n    return scheduler.schedule(function () {\n      if (i === input.length) {\n        // If we have hit the end of the array like in the\n        // previous job, we can complete.\n        subscriber.complete();\n      } else {\n        // Otherwise let's next the value at the current index,\n        // then increment our index.\n        subscriber.next(input[i++]);\n        // If the last emission didn't cause us to close the subscriber\n        // (via take or some side effect), reschedule the job and we'll\n        // make another pass.\n        if (!subscriber.closed) {\n          this.schedule();\n        }\n      }\n    });\n  });\n}\n","import { SchedulerLike } from '../types';\nimport { Observable } from '../Observable';\nimport { executeSchedule } from '../util/executeSchedule';\n\nexport function scheduleAsyncIterable<T>(input: AsyncIterable<T>, scheduler: SchedulerLike) {\n  if (!input) {\n    throw new Error('Iterable cannot be null');\n  }\n  return new Observable<T>((subscriber) => {\n    executeSchedule(subscriber, scheduler, () => {\n      const iterator = input[Symbol.asyncIterator]();\n      executeSchedule(\n        subscriber,\n        scheduler,\n        () => {\n          iterator.next().then((result) => {\n            if (result.done) {\n              // This will remove the subscriptions from\n              // the parent subscription.\n              subscriber.complete();\n            } else {\n              subscriber.next(result.value);\n            }\n          });\n        },\n        0,\n        true\n      );\n    });\n  });\n}\n","import { Observable } from '../Observable';\nimport { SchedulerLike } from '../types';\nimport { iterator as Symbol_iterator } from '../symbol/iterator';\nimport { isFunction } from '../util/isFunction';\nimport { executeSchedule } from '../util/executeSchedule';\n\n/**\n * Used in {@link scheduled} to create an observable from an Iterable.\n * @param input The iterable to create an observable from\n * @param scheduler The scheduler to use\n */\nexport function scheduleIterable<T>(input: Iterable<T>, scheduler: SchedulerLike) {\n  return new Observable<T>((subscriber) => {\n    let iterator: Iterator<T, T>;\n\n    // Schedule the initial creation of the iterator from\n    // the iterable. This is so the code in the iterable is\n    // not called until the scheduled job fires.\n    executeSchedule(subscriber, scheduler, () => {\n      // Create the iterator.\n      iterator = (input as any)[Symbol_iterator]();\n\n      executeSchedule(\n        subscriber,\n        scheduler,\n        () => {\n          let value: T;\n          let done: boolean | undefined;\n          try {\n            // Pull the value out of the iterator\n            ({ value, done } = iterator.next());\n          } catch (err) {\n            // We got an error while pulling from the iterator\n            subscriber.error(err);\n            return;\n          }\n\n          if (done) {\n            // If it is \"done\" we just complete. This mimics the\n            // behavior of JavaScript's `for..of` consumption of\n            // iterables, which will not emit the value from an iterator\n            // result of `{ done: true: value: 'here' }`.\n            subscriber.complete();\n          } else {\n            // The iterable is not done, emit the value.\n            subscriber.next(value);\n          }\n        },\n        0,\n        true\n      );\n    });\n\n    // During finalization, if we see this iterator has a `return` method,\n    // then we know it is a Generator, and not just an Iterator. So we call\n    // the `return()` function. This will ensure that any `finally { }` blocks\n    // inside of the generator we can hit will be hit properly.\n    return () => isFunction(iterator?.return) && iterator.return();\n  });\n}\n","import { innerFrom } from '../observable/innerFrom';\nimport { observeOn } from '../operators/observeOn';\nimport { subscribeOn } from '../operators/subscribeOn';\nimport { InteropObservable, SchedulerLike } from '../types';\n\nexport function scheduleObservable<T>(input: InteropObservable<T>, scheduler: SchedulerLike) {\n  return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));\n}\n","import { innerFrom } from '../observable/innerFrom';\nimport { observeOn } from '../operators/observeOn';\nimport { subscribeOn } from '../operators/subscribeOn';\nimport { SchedulerLike } from '../types';\n\nexport function schedulePromise<T>(input: PromiseLike<T>, scheduler: SchedulerLike) {\n  return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));\n}\n","import { SchedulerLike, ReadableStreamLike } from '../types';\nimport { Observable } from '../Observable';\nimport { scheduleAsyncIterable } from './scheduleAsyncIterable';\nimport { readableStreamLikeToAsyncGenerator } from '../util/isReadableStreamLike';\n\nexport function scheduleReadableStreamLike<T>(input: ReadableStreamLike<T>, scheduler: SchedulerLike): Observable<T> {\n  return scheduleAsyncIterable(readableStreamLikeToAsyncGenerator(input), scheduler);\n}\n","import { scheduleObservable } from './scheduleObservable';\nimport { schedulePromise } from './schedulePromise';\nimport { scheduleArray } from './scheduleArray';\nimport { scheduleIterable } from './scheduleIterable';\nimport { scheduleAsyncIterable } from './scheduleAsyncIterable';\nimport { isInteropObservable } from '../util/isInteropObservable';\nimport { isPromise } from '../util/isPromise';\nimport { isArrayLike } from '../util/isArrayLike';\nimport { isIterable } from '../util/isIterable';\nimport { ObservableInput, SchedulerLike } from '../types';\nimport { Observable } from '../Observable';\nimport { isAsyncIterable } from '../util/isAsyncIterable';\nimport { createInvalidObservableTypeError } from '../util/throwUnobservableError';\nimport { isReadableStreamLike } from '../util/isReadableStreamLike';\nimport { scheduleReadableStreamLike } from './scheduleReadableStreamLike';\n\n/**\n * Converts from a common {@link ObservableInput} type to an observable where subscription and emissions\n * are scheduled on the provided scheduler.\n *\n * @see {@link from}\n * @see {@link of}\n *\n * @param input The observable, array, promise, iterable, etc you would like to schedule\n * @param scheduler The scheduler to use to schedule the subscription and emissions from\n * the returned observable.\n */\nexport function scheduled<T>(input: ObservableInput<T>, scheduler: SchedulerLike): Observable<T> {\n  if (input != null) {\n    if (isInteropObservable(input)) {\n      return scheduleObservable(input, scheduler);\n    }\n    if (isArrayLike(input)) {\n      return scheduleArray(input, scheduler);\n    }\n    if (isPromise(input)) {\n      return schedulePromise(input, scheduler);\n    }\n    if (isAsyncIterable(input)) {\n      return scheduleAsyncIterable(input, scheduler);\n    }\n    if (isIterable(input)) {\n      return scheduleIterable(input, scheduler);\n    }\n    if (isReadableStreamLike(input)) {\n      return scheduleReadableStreamLike(input, scheduler);\n    }\n  }\n  throw createInvalidObservableTypeError(input);\n}\n","import { Scheduler } from '../Scheduler';\nimport { Subscription } from '../Subscription';\nimport { SchedulerAction } from '../types';\n\n/**\n * A unit of work to be executed in a `scheduler`. An action is typically\n * created from within a {@link SchedulerLike} and an RxJS user does not need to concern\n * themselves about creating and manipulating an Action.\n *\n * ```ts\n * class Action<T> extends Subscription {\n *   new (scheduler: Scheduler, work: (state?: T) => void);\n *   schedule(state?: T, delay: number = 0): Subscription;\n * }\n * ```\n *\n * @class Action<T>\n */\nexport class Action<T> extends Subscription {\n  constructor(scheduler: Scheduler, work: (this: SchedulerAction<T>, state?: T) => void) {\n    super();\n  }\n  /**\n   * Schedules this action on its parent {@link SchedulerLike} for execution. May be passed\n   * some context object, `state`. May happen at some point in the future,\n   * according to the `delay` parameter, if specified.\n   * @param {T} [state] Some contextual data that the `work` function uses when\n   * called by the Scheduler.\n   * @param {number} [delay] Time to wait before executing the work, where the\n   * time unit is implicit and defined by the Scheduler.\n   * @return {void}\n   */\n  public schedule(state?: T, delay: number = 0): Subscription {\n    return this;\n  }\n}\n","import { AsyncAction } from './AsyncAction';\nimport { AnimationFrameScheduler } from './AnimationFrameScheduler';\nimport { SchedulerAction } from '../types';\nimport { animationFrameProvider } from './animationFrameProvider';\nimport { TimerHandle } from './timerHandle';\n\nexport class AnimationFrameAction<T> extends AsyncAction<T> {\n  constructor(protected scheduler: AnimationFrameScheduler, protected work: (this: SchedulerAction<T>, state?: T) => void) {\n    super(scheduler, work);\n  }\n\n  protected requestAsyncId(scheduler: AnimationFrameScheduler, id?: TimerHandle, delay: number = 0): TimerHandle {\n    // If delay is greater than 0, request as an async action.\n    if (delay !== null && delay > 0) {\n      return super.requestAsyncId(scheduler, id, delay);\n    }\n    // Push the action to the end of the scheduler queue.\n    scheduler.actions.push(this);\n    // If an animation frame has already been requested, don't request another\n    // one. If an animation frame hasn't been requested yet, request one. Return\n    // the current animation frame request id.\n    return scheduler._scheduled || (scheduler._scheduled = animationFrameProvider.requestAnimationFrame(() => scheduler.flush(undefined)));\n  }\n\n  protected recycleAsyncId(scheduler: AnimationFrameScheduler, id?: TimerHandle, delay: number = 0): TimerHandle | undefined {\n    // If delay exists and is greater than 0, or if the delay is null (the\n    // action wasn't rescheduled) but was originally scheduled as an async\n    // action, then recycle as an async action.\n    if (delay != null ? delay > 0 : this.delay > 0) {\n      return super.recycleAsyncId(scheduler, id, delay);\n    }\n    // If the scheduler queue has no remaining actions with the same async id,\n    // cancel the requested animation frame and set the scheduled flag to\n    // undefined so the next AnimationFrameAction will request its own.\n    const { actions } = scheduler;\n    if (id != null && actions[actions.length - 1]?.id !== id) {\n      animationFrameProvider.cancelAnimationFrame(id as number);\n      scheduler._scheduled = undefined;\n    }\n    // Return undefined so the action knows to request a new async id if it's rescheduled.\n    return undefined;\n  }\n}\n","import { AsyncAction } from './AsyncAction';\nimport { AsyncScheduler } from './AsyncScheduler';\n\nexport class AnimationFrameScheduler extends AsyncScheduler {\n  public flush(action?: AsyncAction<any>): void {\n    this._active = true;\n    // The async id that effects a call to flush is stored in _scheduled.\n    // Before executing an action, it's necessary to check the action's async\n    // id to determine whether it's supposed to be executed in the current\n    // flush.\n    // Previous implementations of this method used a count to determine this,\n    // but that was unsound, as actions that are unsubscribed - i.e. cancelled -\n    // are removed from the actions array and that can shift actions that are\n    // scheduled to be executed in a subsequent flush into positions at which\n    // they are executed within the current flush.\n    const flushId = this._scheduled;\n    this._scheduled = undefined;\n\n    const { actions } = this;\n    let error: any;\n    action = action || actions.shift()!;\n\n    do {\n      if ((error = action.execute(action.state, action.delay))) {\n        break;\n      }\n    } while ((action = actions[0]) && action.id === flushId && actions.shift());\n\n    this._active = false;\n\n    if (error) {\n      while ((action = actions[0]) && action.id === flushId && actions.shift()) {\n        action.unsubscribe();\n      }\n      throw error;\n    }\n  }\n}\n","import { AsyncAction } from './AsyncAction';\nimport { AsapScheduler } from './AsapScheduler';\nimport { SchedulerAction } from '../types';\nimport { immediateProvider } from './immediateProvider';\nimport { TimerHandle } from './timerHandle';\n\nexport class AsapAction<T> extends AsyncAction<T> {\n  constructor(protected scheduler: AsapScheduler, protected work: (this: SchedulerAction<T>, state?: T) => void) {\n    super(scheduler, work);\n  }\n\n  protected requestAsyncId(scheduler: AsapScheduler, id?: TimerHandle, delay: number = 0): TimerHandle {\n    // If delay is greater than 0, request as an async action.\n    if (delay !== null && delay > 0) {\n      return super.requestAsyncId(scheduler, id, delay);\n    }\n    // Push the action to the end of the scheduler queue.\n    scheduler.actions.push(this);\n    // If a microtask has already been scheduled, don't schedule another\n    // one. If a microtask hasn't been scheduled yet, schedule one now. Return\n    // the current scheduled microtask id.\n    return scheduler._scheduled || (scheduler._scheduled = immediateProvider.setImmediate(scheduler.flush.bind(scheduler, undefined)));\n  }\n\n  protected recycleAsyncId(scheduler: AsapScheduler, id?: TimerHandle, delay: number = 0): TimerHandle | undefined {\n    // If delay exists and is greater than 0, or if the delay is null (the\n    // action wasn't rescheduled) but was originally scheduled as an async\n    // action, then recycle as an async action.\n    if (delay != null ? delay > 0 : this.delay > 0) {\n      return super.recycleAsyncId(scheduler, id, delay);\n    }\n    // If the scheduler queue has no remaining actions with the same async id,\n    // cancel the requested microtask and set the scheduled flag to undefined\n    // so the next AsapAction will request its own.\n    const { actions } = scheduler;\n    if (id != null && actions[actions.length - 1]?.id !== id) {\n      immediateProvider.clearImmediate(id);\n      if (scheduler._scheduled === id) {\n        scheduler._scheduled = undefined;\n      }\n    }\n    // Return undefined so the action knows to request a new async id if it's rescheduled.\n    return undefined;\n  }\n}\n","import { AsyncAction } from './AsyncAction';\nimport { AsyncScheduler } from './AsyncScheduler';\n\nexport class AsapScheduler extends AsyncScheduler {\n  public flush(action?: AsyncAction<any>): void {\n    this._active = true;\n    // The async id that effects a call to flush is stored in _scheduled.\n    // Before executing an action, it's necessary to check the action's async\n    // id to determine whether it's supposed to be executed in the current\n    // flush.\n    // Previous implementations of this method used a count to determine this,\n    // but that was unsound, as actions that are unsubscribed - i.e. cancelled -\n    // are removed from the actions array and that can shift actions that are\n    // scheduled to be executed in a subsequent flush into positions at which\n    // they are executed within the current flush.\n    const flushId = this._scheduled;\n    this._scheduled = undefined;\n\n    const { actions } = this;\n    let error: any;\n    action = action || actions.shift()!;\n\n    do {\n      if ((error = action.execute(action.state, action.delay))) {\n        break;\n      }\n    } while ((action = actions[0]) && action.id === flushId && actions.shift());\n\n    this._active = false;\n\n    if (error) {\n      while ((action = actions[0]) && action.id === flushId && actions.shift()) {\n        action.unsubscribe();\n      }\n      throw error;\n    }\n  }\n}\n","import { Action } from './Action';\nimport { SchedulerAction } from '../types';\nimport { Subscription } from '../Subscription';\nimport { AsyncScheduler } from './AsyncScheduler';\nimport { intervalProvider } from './intervalProvider';\nimport { arrRemove } from '../util/arrRemove';\nimport { TimerHandle } from './timerHandle';\n\nexport class AsyncAction<T> extends Action<T> {\n  public id: TimerHandle | undefined;\n  public state?: T;\n  // @ts-ignore: Property has no initializer and is not definitely assigned\n  public delay: number;\n  protected pending: boolean = false;\n\n  constructor(protected scheduler: AsyncScheduler, protected work: (this: SchedulerAction<T>, state?: T) => void) {\n    super(scheduler, work);\n  }\n\n  public schedule(state?: T, delay: number = 0): Subscription {\n    if (this.closed) {\n      return this;\n    }\n\n    // Always replace the current state with the new state.\n    this.state = state;\n\n    const id = this.id;\n    const scheduler = this.scheduler;\n\n    //\n    // Important implementation note:\n    //\n    // Actions only execute once by default, unless rescheduled from within the\n    // scheduled callback. This allows us to implement single and repeat\n    // actions via the same code path, without adding API surface area, as well\n    // as mimic traditional recursion but across asynchronous boundaries.\n    //\n    // However, JS runtimes and timers distinguish between intervals achieved by\n    // serial `setTimeout` calls vs. a single `setInterval` call. An interval of\n    // serial `setTimeout` calls can be individually delayed, which delays\n    // scheduling the next `setTimeout`, and so on. `setInterval` attempts to\n    // guarantee the interval callback will be invoked more precisely to the\n    // interval period, regardless of load.\n    //\n    // Therefore, we use `setInterval` to schedule single and repeat actions.\n    // If the action reschedules itself with the same delay, the interval is not\n    // canceled. If the action doesn't reschedule, or reschedules with a\n    // different delay, the interval will be canceled after scheduled callback\n    // execution.\n    //\n    if (id != null) {\n      this.id = this.recycleAsyncId(scheduler, id, delay);\n    }\n\n    // Set the pending flag indicating that this action has been scheduled, or\n    // has recursively rescheduled itself.\n    this.pending = true;\n\n    this.delay = delay;\n    // If this action has already an async Id, don't request a new one.\n    this.id = this.id ?? this.requestAsyncId(scheduler, this.id, delay);\n\n    return this;\n  }\n\n  protected requestAsyncId(scheduler: AsyncScheduler, _id?: TimerHandle, delay: number = 0): TimerHandle {\n    return intervalProvider.setInterval(scheduler.flush.bind(scheduler, this), delay);\n  }\n\n  protected recycleAsyncId(_scheduler: AsyncScheduler, id?: TimerHandle, delay: number | null = 0): TimerHandle | undefined {\n    // If this action is rescheduled with the same delay time, don't clear the interval id.\n    if (delay != null && this.delay === delay && this.pending === false) {\n      return id;\n    }\n    // Otherwise, if the action's delay time is different from the current delay,\n    // or the action has been rescheduled before it's executed, clear the interval id\n    if (id != null) {\n      intervalProvider.clearInterval(id);\n    }\n\n    return undefined;\n  }\n\n  /**\n   * Immediately executes this action and the `work` it contains.\n   * @return {any}\n   */\n  public execute(state: T, delay: number): any {\n    if (this.closed) {\n      return new Error('executing a cancelled action');\n    }\n\n    this.pending = false;\n    const error = this._execute(state, delay);\n    if (error) {\n      return error;\n    } else if (this.pending === false && this.id != null) {\n      // Dequeue if the action didn't reschedule itself. Don't call\n      // unsubscribe(), because the action could reschedule later.\n      // For example:\n      // ```\n      // scheduler.schedule(function doWork(counter) {\n      //   /* ... I'm a busy worker bee ... */\n      //   var originalAction = this;\n      //   /* wait 100ms before rescheduling the action */\n      //   setTimeout(function () {\n      //     originalAction.schedule(counter + 1);\n      //   }, 100);\n      // }, 1000);\n      // ```\n      this.id = this.recycleAsyncId(this.scheduler, this.id, null);\n    }\n  }\n\n  protected _execute(state: T, _delay: number): any {\n    let errored: boolean = false;\n    let errorValue: any;\n    try {\n      this.work(state);\n    } catch (e) {\n      errored = true;\n      // HACK: Since code elsewhere is relying on the \"truthiness\" of the\n      // return here, we can't have it return \"\" or 0 or false.\n      // TODO: Clean this up when we refactor schedulers mid-version-8 or so.\n      errorValue = e ? e : new Error('Scheduled action threw falsy error');\n    }\n    if (errored) {\n      this.unsubscribe();\n      return errorValue;\n    }\n  }\n\n  unsubscribe() {\n    if (!this.closed) {\n      const { id, scheduler } = this;\n      const { actions } = scheduler;\n\n      this.work = this.state = this.scheduler = null!;\n      this.pending = false;\n\n      arrRemove(actions, this);\n      if (id != null) {\n        this.id = this.recycleAsyncId(scheduler, id, null);\n      }\n\n      this.delay = null!;\n      super.unsubscribe();\n    }\n  }\n}\n","import { Scheduler } from '../Scheduler';\nimport { Action } from './Action';\nimport { AsyncAction } from './AsyncAction';\nimport { TimerHandle } from './timerHandle';\n\nexport class AsyncScheduler extends Scheduler {\n  public actions: Array<AsyncAction<any>> = [];\n  /**\n   * A flag to indicate whether the Scheduler is currently executing a batch of\n   * queued actions.\n   * @type {boolean}\n   * @internal\n   */\n  public _active: boolean = false;\n  /**\n   * An internal ID used to track the latest asynchronous task such as those\n   * coming from `setTimeout`, `setInterval`, `requestAnimationFrame`, and\n   * others.\n   * @type {any}\n   * @internal\n   */\n  public _scheduled: TimerHandle | undefined;\n\n  constructor(SchedulerAction: typeof Action, now: () => number = Scheduler.now) {\n    super(SchedulerAction, now);\n  }\n\n  public flush(action: AsyncAction<any>): void {\n    const { actions } = this;\n\n    if (this._active) {\n      actions.push(action);\n      return;\n    }\n\n    let error: any;\n    this._active = true;\n\n    do {\n      if ((error = action.execute(action.state, action.delay))) {\n        break;\n      }\n    } while ((action = actions.shift()!)); // exhaust the scheduler queue\n\n    this._active = false;\n\n    if (error) {\n      while ((action = actions.shift()!)) {\n        action.unsubscribe();\n      }\n      throw error;\n    }\n  }\n}\n","import { AsyncAction } from './AsyncAction';\nimport { Subscription } from '../Subscription';\nimport { QueueScheduler } from './QueueScheduler';\nimport { SchedulerAction } from '../types';\nimport { TimerHandle } from './timerHandle';\n\nexport class QueueAction<T> extends AsyncAction<T> {\n  constructor(protected scheduler: QueueScheduler, protected work: (this: SchedulerAction<T>, state?: T) => void) {\n    super(scheduler, work);\n  }\n\n  public schedule(state?: T, delay: number = 0): Subscription {\n    if (delay > 0) {\n      return super.schedule(state, delay);\n    }\n    this.delay = delay;\n    this.state = state;\n    this.scheduler.flush(this);\n    return this;\n  }\n\n  public execute(state: T, delay: number): any {\n    return delay > 0 || this.closed ? super.execute(state, delay) : this._execute(state, delay);\n  }\n\n  protected requestAsyncId(scheduler: QueueScheduler, id?: TimerHandle, delay: number = 0): TimerHandle {\n    // If delay exists and is greater than 0, or if the delay is null (the\n    // action wasn't rescheduled) but was originally scheduled as an async\n    // action, then recycle as an async action.\n\n    if ((delay != null && delay > 0) || (delay == null && this.delay > 0)) {\n      return super.requestAsyncId(scheduler, id, delay);\n    }\n\n    // Otherwise flush the scheduler starting with this action.\n    scheduler.flush(this);\n\n    // HACK: In the past, this was returning `void`. However, `void` isn't a valid\n    // `TimerHandle`, and generally the return value here isn't really used. So the\n    // compromise is to return `0` which is both \"falsy\" and a valid `TimerHandle`,\n    // as opposed to refactoring every other instanceo of `requestAsyncId`.\n    return 0;\n  }\n}\n","import { AsyncScheduler } from './AsyncScheduler';\n\nexport class QueueScheduler extends AsyncScheduler {\n}\n","import { AsyncAction } from './AsyncAction';\nimport { Subscription } from '../Subscription';\nimport { AsyncScheduler } from './AsyncScheduler';\nimport { SchedulerAction } from '../types';\nimport { TimerHandle } from './timerHandle';\n\nexport class VirtualTimeScheduler extends AsyncScheduler {\n  /** @deprecated Not used in VirtualTimeScheduler directly. Will be removed in v8. */\n  static frameTimeFactor = 10;\n\n  /**\n   * The current frame for the state of the virtual scheduler instance. The difference\n   * between two \"frames\" is synonymous with the passage of \"virtual time units\". So if\n   * you record `scheduler.frame` to be `1`, then later, observe `scheduler.frame` to be at `11`,\n   * that means `10` virtual time units have passed.\n   */\n  public frame: number = 0;\n\n  /**\n   * Used internally to examine the current virtual action index being processed.\n   * @deprecated Internal implementation detail, do not use directly. Will be made internal in v8.\n   */\n  public index: number = -1;\n\n  /**\n   * This creates an instance of a `VirtualTimeScheduler`. Experts only. The signature of\n   * this constructor is likely to change in the long run.\n   *\n   * @param schedulerActionCtor The type of Action to initialize when initializing actions during scheduling.\n   * @param maxFrames The maximum number of frames to process before stopping. Used to prevent endless flush cycles.\n   */\n  constructor(schedulerActionCtor: typeof AsyncAction = VirtualAction as any, public maxFrames: number = Infinity) {\n    super(schedulerActionCtor, () => this.frame);\n  }\n\n  /**\n   * Prompt the Scheduler to execute all of its queued actions, therefore\n   * clearing its queue.\n   * @return {void}\n   */\n  public flush(): void {\n    const { actions, maxFrames } = this;\n    let error: any;\n    let action: AsyncAction<any> | undefined;\n\n    while ((action = actions[0]) && action.delay <= maxFrames) {\n      actions.shift();\n      this.frame = action.delay;\n\n      if ((error = action.execute(action.state, action.delay))) {\n        break;\n      }\n    }\n\n    if (error) {\n      while ((action = actions.shift())) {\n        action.unsubscribe();\n      }\n      throw error;\n    }\n  }\n}\n\nexport class VirtualAction<T> extends AsyncAction<T> {\n  protected active: boolean = true;\n\n  constructor(\n    protected scheduler: VirtualTimeScheduler,\n    protected work: (this: SchedulerAction<T>, state?: T) => void,\n    protected index: number = (scheduler.index += 1)\n  ) {\n    super(scheduler, work);\n    this.index = scheduler.index = index;\n  }\n\n  public schedule(state?: T, delay: number = 0): Subscription {\n    if (Number.isFinite(delay)) {\n      if (!this.id) {\n        return super.schedule(state, delay);\n      }\n      this.active = false;\n      // If an action is rescheduled, we save allocations by mutating its state,\n      // pushing it to the end of the scheduler queue, and recycling the action.\n      // But since the VirtualTimeScheduler is used for testing, VirtualActions\n      // must be immutable so they can be inspected later.\n      const action = new VirtualAction(this.scheduler, this.work);\n      this.add(action);\n      return action.schedule(state, delay);\n    } else {\n      // If someone schedules something with Infinity, it'll never happen. So we\n      // don't even schedule it.\n      return Subscription.EMPTY;\n    }\n  }\n\n  protected requestAsyncId(scheduler: VirtualTimeScheduler, id?: any, delay: number = 0): TimerHandle {\n    this.delay = scheduler.frame + delay;\n    const { actions } = scheduler;\n    actions.push(this);\n    (actions as Array<VirtualAction<T>>).sort(VirtualAction.sortActions);\n    return 1;\n  }\n\n  protected recycleAsyncId(scheduler: VirtualTimeScheduler, id?: any, delay: number = 0): TimerHandle | undefined {\n    return undefined;\n  }\n\n  protected _execute(state: T, delay: number): any {\n    if (this.active === true) {\n      return super._execute(state, delay);\n    }\n  }\n\n  private static sortActions<T>(a: VirtualAction<T>, b: VirtualAction<T>) {\n    if (a.delay === b.delay) {\n      if (a.index === b.index) {\n        return 0;\n      } else if (a.index > b.index) {\n        return 1;\n      } else {\n        return -1;\n      }\n    } else if (a.delay > b.delay) {\n      return 1;\n    } else {\n      return -1;\n    }\n  }\n}\n","import { AnimationFrameAction } from './AnimationFrameAction';\nimport { AnimationFrameScheduler } from './AnimationFrameScheduler';\n\n/**\n *\n * Animation Frame Scheduler\n *\n * <span class=\"informal\">Perform task when `window.requestAnimationFrame` would fire</span>\n *\n * When `animationFrame` scheduler is used with delay, it will fall back to {@link asyncScheduler} scheduler\n * behaviour.\n *\n * Without delay, `animationFrame` scheduler can be used to create smooth browser animations.\n * It makes sure scheduled task will happen just before next browser content repaint,\n * thus performing animations as efficiently as possible.\n *\n * ## Example\n * Schedule div height animation\n * ```ts\n * // html: <div style=\"background: #0ff;\"></div>\n * import { animationFrameScheduler } from 'rxjs';\n *\n * const div = document.querySelector('div');\n *\n * animationFrameScheduler.schedule(function(height) {\n *   div.style.height = height + \"px\";\n *\n *   this.schedule(height + 1);  // `this` references currently executing Action,\n *                               // which we reschedule with new state\n * }, 0, 0);\n *\n * // You will see a div element growing in height\n * ```\n */\n\nexport const animationFrameScheduler = new AnimationFrameScheduler(AnimationFrameAction);\n\n/**\n * @deprecated Renamed to {@link animationFrameScheduler}. Will be removed in v8.\n */\nexport const animationFrame = animationFrameScheduler;\n","import { Subscription } from '../Subscription';\n\ninterface AnimationFrameProvider {\n  schedule(callback: FrameRequestCallback): Subscription;\n  requestAnimationFrame: typeof requestAnimationFrame;\n  cancelAnimationFrame: typeof cancelAnimationFrame;\n  delegate:\n    | {\n        requestAnimationFrame: typeof requestAnimationFrame;\n        cancelAnimationFrame: typeof cancelAnimationFrame;\n      }\n    | undefined;\n}\n\nexport const animationFrameProvider: AnimationFrameProvider = {\n  // When accessing the delegate, use the variable rather than `this` so that\n  // the functions can be called without being bound to the provider.\n  schedule(callback) {\n    let request = requestAnimationFrame;\n    let cancel: typeof cancelAnimationFrame | undefined = cancelAnimationFrame;\n    const { delegate } = animationFrameProvider;\n    if (delegate) {\n      request = delegate.requestAnimationFrame;\n      cancel = delegate.cancelAnimationFrame;\n    }\n    const handle = request((timestamp) => {\n      // Clear the cancel function. The request has been fulfilled, so\n      // attempting to cancel the request upon unsubscription would be\n      // pointless.\n      cancel = undefined;\n      callback(timestamp);\n    });\n    return new Subscription(() => cancel?.(handle));\n  },\n  requestAnimationFrame(...args) {\n    const { delegate } = animationFrameProvider;\n    return (delegate?.requestAnimationFrame || requestAnimationFrame)(...args);\n  },\n  cancelAnimationFrame(...args) {\n    const { delegate } = animationFrameProvider;\n    return (delegate?.cancelAnimationFrame || cancelAnimationFrame)(...args);\n  },\n  delegate: undefined,\n};\n","import { AsapAction } from './AsapAction';\nimport { AsapScheduler } from './AsapScheduler';\n\n/**\n *\n * Asap Scheduler\n *\n * <span class=\"informal\">Perform task as fast as it can be performed asynchronously</span>\n *\n * `asap` scheduler behaves the same as {@link asyncScheduler} scheduler when you use it to delay task\n * in time. If however you set delay to `0`, `asap` will wait for current synchronously executing\n * code to end and then it will try to execute given task as fast as possible.\n *\n * `asap` scheduler will do its best to minimize time between end of currently executing code\n * and start of scheduled task. This makes it best candidate for performing so called \"deferring\".\n * Traditionally this was achieved by calling `setTimeout(deferredTask, 0)`, but that technique involves\n * some (although minimal) unwanted delay.\n *\n * Note that using `asap` scheduler does not necessarily mean that your task will be first to process\n * after currently executing code. In particular, if some task was also scheduled with `asap` before,\n * that task will execute first. That being said, if you need to schedule task asynchronously, but\n * as soon as possible, `asap` scheduler is your best bet.\n *\n * ## Example\n * Compare async and asap scheduler<\n * ```ts\n * import { asapScheduler, asyncScheduler } from 'rxjs';\n *\n * asyncScheduler.schedule(() => console.log('async')); // scheduling 'async' first...\n * asapScheduler.schedule(() => console.log('asap'));\n *\n * // Logs:\n * // \"asap\"\n * // \"async\"\n * // ... but 'asap' goes first!\n * ```\n */\n\nexport const asapScheduler = new AsapScheduler(AsapAction);\n\n/**\n * @deprecated Renamed to {@link asapScheduler}. Will be removed in v8.\n */\nexport const asap = asapScheduler;\n","import { AsyncAction } from './AsyncAction';\nimport { AsyncScheduler } from './AsyncScheduler';\n\n/**\n *\n * Async Scheduler\n *\n * <span class=\"informal\">Schedule task as if you used setTimeout(task, duration)</span>\n *\n * `async` scheduler schedules tasks asynchronously, by putting them on the JavaScript\n * event loop queue. It is best used to delay tasks in time or to schedule tasks repeating\n * in intervals.\n *\n * If you just want to \"defer\" task, that is to perform it right after currently\n * executing synchronous code ends (commonly achieved by `setTimeout(deferredTask, 0)`),\n * better choice will be the {@link asapScheduler} scheduler.\n *\n * ## Examples\n * Use async scheduler to delay task\n * ```ts\n * import { asyncScheduler } from 'rxjs';\n *\n * const task = () => console.log('it works!');\n *\n * asyncScheduler.schedule(task, 2000);\n *\n * // After 2 seconds logs:\n * // \"it works!\"\n * ```\n *\n * Use async scheduler to repeat task in intervals\n * ```ts\n * import { asyncScheduler } from 'rxjs';\n *\n * function task(state) {\n *   console.log(state);\n *   this.schedule(state + 1, 1000); // `this` references currently executing Action,\n *                                   // which we reschedule with new state and delay\n * }\n *\n * asyncScheduler.schedule(task, 3000, 0);\n *\n * // Logs:\n * // 0 after 3s\n * // 1 after 4s\n * // 2 after 5s\n * // 3 after 6s\n * ```\n */\n\nexport const asyncScheduler = new AsyncScheduler(AsyncAction);\n\n/**\n * @deprecated Renamed to {@link asyncScheduler}. Will be removed in v8.\n */\nexport const async = asyncScheduler;\n","import { TimestampProvider } from '../types';\n\ninterface DateTimestampProvider extends TimestampProvider {\n  delegate: TimestampProvider | undefined;\n}\n\nexport const dateTimestampProvider: DateTimestampProvider = {\n  now() {\n    // Use the variable rather than `this` so that the function can be called\n    // without being bound to the provider.\n    return (dateTimestampProvider.delegate || Date).now();\n  },\n  delegate: undefined,\n};\n","import { Immediate } from '../util/Immediate';\nimport type { TimerHandle } from './timerHandle';\nconst { setImmediate, clearImmediate } = Immediate;\n\ntype SetImmediateFunction = (handler: () => void, ...args: any[]) => TimerHandle;\ntype ClearImmediateFunction = (handle: TimerHandle) => void;\n\ninterface ImmediateProvider {\n  setImmediate: SetImmediateFunction;\n  clearImmediate: ClearImmediateFunction;\n  delegate:\n    | {\n        setImmediate: SetImmediateFunction;\n        clearImmediate: ClearImmediateFunction;\n      }\n    | undefined;\n}\n\nexport const immediateProvider: ImmediateProvider = {\n  // When accessing the delegate, use the variable rather than `this` so that\n  // the functions can be called without being bound to the provider.\n  setImmediate(...args) {\n    const { delegate } = immediateProvider;\n    return (delegate?.setImmediate || setImmediate)(...args);\n  },\n  clearImmediate(handle) {\n    const { delegate } = immediateProvider;\n    return (delegate?.clearImmediate || clearImmediate)(handle as any);\n  },\n  delegate: undefined,\n};\n","import type { TimerHandle } from './timerHandle';\ntype SetIntervalFunction = (handler: () => void, timeout?: number, ...args: any[]) => TimerHandle;\ntype ClearIntervalFunction = (handle: TimerHandle) => void;\n\ninterface IntervalProvider {\n  setInterval: SetIntervalFunction;\n  clearInterval: ClearIntervalFunction;\n  delegate:\n    | {\n        setInterval: SetIntervalFunction;\n        clearInterval: ClearIntervalFunction;\n      }\n    | undefined;\n}\n\nexport const intervalProvider: IntervalProvider = {\n  // When accessing the delegate, use the variable rather than `this` so that\n  // the functions can be called without being bound to the provider.\n  setInterval(handler: () => void, timeout?: number, ...args) {\n    const { delegate } = intervalProvider;\n    if (delegate?.setInterval) {\n      return delegate.setInterval(handler, timeout, ...args);\n    }\n    return setInterval(handler, timeout, ...args);\n  },\n  clearInterval(handle) {\n    const { delegate } = intervalProvider;\n    return (delegate?.clearInterval || clearInterval)(handle as any);\n  },\n  delegate: undefined,\n};\n","import { TimestampProvider } from '../types';\n\ninterface PerformanceTimestampProvider extends TimestampProvider {\n  delegate: TimestampProvider | undefined;\n}\n\nexport const performanceTimestampProvider: PerformanceTimestampProvider = {\n  now() {\n    // Use the variable rather than `this` so that the function can be called\n    // without being bound to the provider.\n    return (performanceTimestampProvider.delegate || performance).now();\n  },\n  delegate: undefined,\n};\n","import { QueueAction } from './QueueAction';\nimport { QueueScheduler } from './QueueScheduler';\n\n/**\n *\n * Queue Scheduler\n *\n * <span class=\"informal\">Put every next task on a queue, instead of executing it immediately</span>\n *\n * `queue` scheduler, when used with delay, behaves the same as {@link asyncScheduler} scheduler.\n *\n * When used without delay, it schedules given task synchronously - executes it right when\n * it is scheduled. However when called recursively, that is when inside the scheduled task,\n * another task is scheduled with queue scheduler, instead of executing immediately as well,\n * that task will be put on a queue and wait for current one to finish.\n *\n * This means that when you execute task with `queue` scheduler, you are sure it will end\n * before any other task scheduled with that scheduler will start.\n *\n * ## Examples\n * Schedule recursively first, then do something\n * ```ts\n * import { queueScheduler } from 'rxjs';\n *\n * queueScheduler.schedule(() => {\n *   queueScheduler.schedule(() => console.log('second')); // will not happen now, but will be put on a queue\n *\n *   console.log('first');\n * });\n *\n * // Logs:\n * // \"first\"\n * // \"second\"\n * ```\n *\n * Reschedule itself recursively\n * ```ts\n * import { queueScheduler } from 'rxjs';\n *\n * queueScheduler.schedule(function(state) {\n *   if (state !== 0) {\n *     console.log('before', state);\n *     this.schedule(state - 1); // `this` references currently executing Action,\n *                               // which we reschedule with new state\n *     console.log('after', state);\n *   }\n * }, 0, 3);\n *\n * // In scheduler that runs recursively, you would expect:\n * // \"before\", 3\n * // \"before\", 2\n * // \"before\", 1\n * // \"after\", 1\n * // \"after\", 2\n * // \"after\", 3\n *\n * // But with queue it logs:\n * // \"before\", 3\n * // \"after\", 3\n * // \"before\", 2\n * // \"after\", 2\n * // \"before\", 1\n * // \"after\", 1\n * ```\n */\n\nexport const queueScheduler = new QueueScheduler(QueueAction);\n\n/**\n * @deprecated Renamed to {@link queueScheduler}. Will be removed in v8.\n */\nexport const queue = queueScheduler;\n","import type { TimerHandle } from './timerHandle';\ntype SetTimeoutFunction = (handler: () => void, timeout?: number, ...args: any[]) => TimerHandle;\ntype ClearTimeoutFunction = (handle: TimerHandle) => void;\n\ninterface TimeoutProvider {\n  setTimeout: SetTimeoutFunction;\n  clearTimeout: ClearTimeoutFunction;\n  delegate:\n    | {\n        setTimeout: SetTimeoutFunction;\n        clearTimeout: ClearTimeoutFunction;\n      }\n    | undefined;\n}\n\nexport const timeoutProvider: TimeoutProvider = {\n  // When accessing the delegate, use the variable rather than `this` so that\n  // the functions can be called without being bound to the provider.\n  setTimeout(handler: () => void, timeout?: number, ...args) {\n    const { delegate } = timeoutProvider;\n    if (delegate?.setTimeout) {\n      return delegate.setTimeout(handler, timeout, ...args);\n    }\n    return setTimeout(handler, timeout, ...args);\n  },\n  clearTimeout(handle) {\n    const { delegate } = timeoutProvider;\n    return (delegate?.clearTimeout || clearTimeout)(handle as any);\n  },\n  delegate: undefined,\n};\n","export function getSymbolIterator(): symbol {\n  if (typeof Symbol !== 'function' || !Symbol.iterator) {\n    return '@@iterator' as any;\n  }\n\n  return Symbol.iterator;\n}\n\nexport const iterator = getSymbolIterator();\n","/**\n * Symbol.observable or a string \"@@observable\". Used for interop\n *\n * @deprecated We will no longer be exporting this symbol in upcoming versions of RxJS.\n * Instead polyfill and use Symbol.observable directly *or* use https://www.npmjs.com/package/symbol-observable\n */\nexport const observable: string | symbol = (() => (typeof Symbol === 'function' && Symbol.observable) || '@@observable')();\n","import { createErrorClass } from './createErrorClass';\n\nexport interface ArgumentOutOfRangeError extends Error {}\n\nexport interface ArgumentOutOfRangeErrorCtor {\n  /**\n   * @deprecated Internal implementation detail. Do not construct error instances.\n   * Cannot be tagged as internal: https://github.com/ReactiveX/rxjs/issues/6269\n   */\n  new (): ArgumentOutOfRangeError;\n}\n\n/**\n * An error thrown when an element was queried at a certain index of an\n * Observable, but no such index or position exists in that sequence.\n *\n * @see {@link elementAt}\n * @see {@link take}\n * @see {@link takeLast}\n *\n * @class ArgumentOutOfRangeError\n */\nexport const ArgumentOutOfRangeError: ArgumentOutOfRangeErrorCtor = createErrorClass(\n  (_super) =>\n    function ArgumentOutOfRangeErrorImpl(this: any) {\n      _super(this);\n      this.name = 'ArgumentOutOfRangeError';\n      this.message = 'argument out of range';\n    }\n);\n","import { createErrorClass } from './createErrorClass';\n\nexport interface EmptyError extends Error {}\n\nexport interface EmptyErrorCtor {\n  /**\n   * @deprecated Internal implementation detail. Do not construct error instances.\n   * Cannot be tagged as internal: https://github.com/ReactiveX/rxjs/issues/6269\n   */\n  new (): EmptyError;\n}\n\n/**\n * An error thrown when an Observable or a sequence was queried but has no\n * elements.\n *\n * @see {@link first}\n * @see {@link last}\n * @see {@link single}\n * @see {@link firstValueFrom}\n * @see {@link lastValueFrom}\n *\n * @class EmptyError\n */\nexport const EmptyError: EmptyErrorCtor = createErrorClass((_super) => function EmptyErrorImpl(this: any) {\n  _super(this);\n  this.name = 'EmptyError';\n  this.message = 'no elements in sequence';\n});\n","let nextHandle = 1;\n// The promise needs to be created lazily otherwise it won't be patched by Zones\nlet resolved: Promise<any>;\nconst activeHandles: { [key: number]: any } = {};\n\n/**\n * Finds the handle in the list of active handles, and removes it.\n * Returns `true` if found, `false` otherwise. Used both to clear\n * Immediate scheduled tasks, and to identify if a task should be scheduled.\n */\nfunction findAndClearHandle(handle: number): boolean {\n  if (handle in activeHandles) {\n    delete activeHandles[handle];\n    return true;\n  }\n  return false;\n}\n\n/**\n * Helper functions to schedule and unschedule microtasks.\n */\nexport const Immediate = {\n  setImmediate(cb: () => void): number {\n    const handle = nextHandle++;\n    activeHandles[handle] = true;\n    if (!resolved) {\n      resolved = Promise.resolve();\n    }\n    resolved.then(() => findAndClearHandle(handle) && cb());\n    return handle;\n  },\n\n  clearImmediate(handle: number): void {\n    findAndClearHandle(handle);\n  },\n};\n\n/**\n * Used for internal testing purposes only. Do not export from library.\n */\nexport const TestTools = {\n  pending() {\n    return Object.keys(activeHandles).length;\n  }\n};\n","import { createErrorClass } from './createErrorClass';\n\nexport interface NotFoundError extends Error {}\n\nexport interface NotFoundErrorCtor {\n  /**\n   * @deprecated Internal implementation detail. Do not construct error instances.\n   * Cannot be tagged as internal: https://github.com/ReactiveX/rxjs/issues/6269\n   */\n  new (message: string): NotFoundError;\n}\n\n/**\n * An error thrown when a value or values are missing from an\n * observable sequence.\n *\n * @see {@link operators/single}\n *\n * @class NotFoundError\n */\nexport const NotFoundError: NotFoundErrorCtor = createErrorClass(\n  (_super) =>\n    function NotFoundErrorImpl(this: any, message: string) {\n      _super(this);\n      this.name = 'NotFoundError';\n      this.message = message;\n    }\n);\n","import { createErrorClass } from './createErrorClass';\n\nexport interface ObjectUnsubscribedError extends Error {}\n\nexport interface ObjectUnsubscribedErrorCtor {\n  /**\n   * @deprecated Internal implementation detail. Do not construct error instances.\n   * Cannot be tagged as internal: https://github.com/ReactiveX/rxjs/issues/6269\n   */\n  new (): ObjectUnsubscribedError;\n}\n\n/**\n * An error thrown when an action is invalid because the object has been\n * unsubscribed.\n *\n * @see {@link Subject}\n * @see {@link BehaviorSubject}\n *\n * @class ObjectUnsubscribedError\n */\nexport const ObjectUnsubscribedError: ObjectUnsubscribedErrorCtor = createErrorClass(\n  (_super) =>\n    function ObjectUnsubscribedErrorImpl(this: any) {\n      _super(this);\n      this.name = 'ObjectUnsubscribedError';\n      this.message = 'object unsubscribed';\n    }\n);\n","import { createErrorClass } from './createErrorClass';\n\nexport interface SequenceError extends Error {}\n\nexport interface SequenceErrorCtor {\n  /**\n   * @deprecated Internal implementation detail. Do not construct error instances.\n   * Cannot be tagged as internal: https://github.com/ReactiveX/rxjs/issues/6269\n   */\n  new (message: string): SequenceError;\n}\n\n/**\n * An error thrown when something is wrong with the sequence of\n * values arriving on the observable.\n *\n * @see {@link operators/single}\n *\n * @class SequenceError\n */\nexport const SequenceError: SequenceErrorCtor = createErrorClass(\n  (_super) =>\n    function SequenceErrorImpl(this: any, message: string) {\n      _super(this);\n      this.name = 'SequenceError';\n      this.message = message;\n    }\n);\n","import { createErrorClass } from './createErrorClass';\n\nexport interface UnsubscriptionError extends Error {\n  readonly errors: any[];\n}\n\nexport interface UnsubscriptionErrorCtor {\n  /**\n   * @deprecated Internal implementation detail. Do not construct error instances.\n   * Cannot be tagged as internal: https://github.com/ReactiveX/rxjs/issues/6269\n   */\n  new (errors: any[]): UnsubscriptionError;\n}\n\n/**\n * An error thrown when one or more errors have occurred during the\n * `unsubscribe` of a {@link Subscription}.\n */\nexport const UnsubscriptionError: UnsubscriptionErrorCtor = createErrorClass(\n  (_super) =>\n    function UnsubscriptionErrorImpl(this: any, errors: (Error | string)[]) {\n      _super(this);\n      this.message = errors\n        ? `${errors.length} errors occurred during unsubscription:\n${errors.map((err, i) => `${i + 1}) ${err.toString()}`).join('\\n  ')}`\n        : '';\n      this.name = 'UnsubscriptionError';\n      this.errors = errors;\n    }\n);\n","import { SchedulerLike } from '../types';\nimport { isFunction } from './isFunction';\nimport { isScheduler } from './isScheduler';\n\nfunction last<T>(arr: T[]): T | undefined {\n  return arr[arr.length - 1];\n}\n\nexport function popResultSelector(args: any[]): ((...args: unknown[]) => unknown) | undefined {\n  return isFunction(last(args)) ? args.pop() : undefined;\n}\n\nexport function popScheduler(args: any[]): SchedulerLike | undefined {\n  return isScheduler(last(args)) ? args.pop() : undefined;\n}\n\nexport function popNumber(args: any[], defaultValue: number): number {\n  return typeof last(args) === 'number' ? args.pop()! : defaultValue;\n}\n","const { isArray } = Array;\nconst { getPrototypeOf, prototype: objectProto, keys: getKeys } = Object;\n\n/**\n * Used in functions where either a list of arguments, a single array of arguments, or a\n * dictionary of arguments can be returned. Returns an object with an `args` property with\n * the arguments in an array, if it is a dictionary, it will also return the `keys` in another\n * property.\n */\nexport function argsArgArrayOrObject<T, O extends Record<string, T>>(args: T[] | [O] | [T[]]): { args: T[]; keys: string[] | null } {\n  if (args.length === 1) {\n    const first = args[0];\n    if (isArray(first)) {\n      return { args: first, keys: null };\n    }\n    if (isPOJO(first)) {\n      const keys = getKeys(first);\n      return {\n        args: keys.map((key) => first[key]),\n        keys,\n      };\n    }\n  }\n\n  return { args: args as T[], keys: null };\n}\n\nfunction isPOJO(obj: any): obj is object {\n  return obj && typeof obj === 'object' && getPrototypeOf(obj) === objectProto;\n}\n","const { isArray } = Array;\n\n/**\n * Used in operators and functions that accept either a list of arguments, or an array of arguments\n * as a single argument.\n */\nexport function argsOrArgArray<T>(args: (T | T[])[]): T[] {\n  return args.length === 1 && isArray(args[0]) ? args[0] : (args as T[]);\n}\n","/**\n * Removes an item from an array, mutating it.\n * @param arr The array to remove the item from\n * @param item The item to remove\n */\nexport function arrRemove<T>(arr: T[] | undefined | null, item: T) {\n  if (arr) {\n    const index = arr.indexOf(item);\n    0 <= index && arr.splice(index, 1);\n  }\n}\n","/**\n * Used to create Error subclasses until the community moves away from ES5.\n *\n * This is because compiling from TypeScript down to ES5 has issues with subclassing Errors\n * as well as other built-in types: https://github.com/Microsoft/TypeScript/issues/12123\n *\n * @param createImpl A factory function to create the actual constructor implementation. The returned\n * function should be a named function that calls `_super` internally.\n */\nexport function createErrorClass<T>(createImpl: (_super: any) => any): T {\n  const _super = (instance: any) => {\n    Error.call(instance);\n    instance.stack = new Error().stack;\n  };\n\n  const ctorFunc = createImpl(_super);\n  ctorFunc.prototype = Object.create(Error.prototype);\n  ctorFunc.prototype.constructor = ctorFunc;\n  return ctorFunc;\n}\n","export function createObject(keys: string[], values: any[]) {\n  return keys.reduce((result, key, i) => ((result[key] = values[i]), result), {} as any);\n}\n","import { config } from '../config';\n\nlet context: { errorThrown: boolean; error: any } | null = null;\n\n/**\n * Handles dealing with errors for super-gross mode. Creates a context, in which\n * any synchronously thrown errors will be passed to {@link captureError}. Which\n * will record the error such that it will be rethrown after the call back is complete.\n * TODO: Remove in v8\n * @param cb An immediately executed function.\n */\nexport function errorContext(cb: () => void) {\n  if (config.useDeprecatedSynchronousErrorHandling) {\n    const isRoot = !context;\n    if (isRoot) {\n      context = { errorThrown: false, error: null };\n    }\n    cb();\n    if (isRoot) {\n      const { errorThrown, error } = context!;\n      context = null;\n      if (errorThrown) {\n        throw error;\n      }\n    }\n  } else {\n    // This is the general non-deprecated path for everyone that\n    // isn't crazy enough to use super-gross mode (useDeprecatedSynchronousErrorHandling)\n    cb();\n  }\n}\n\n/**\n * Captures errors only in super-gross mode.\n * @param err the error to capture\n */\nexport function captureError(err: any) {\n  if (config.useDeprecatedSynchronousErrorHandling && context) {\n    context.errorThrown = true;\n    context.error = err;\n  }\n}\n","import { Subscription } from '../Subscription';\nimport { SchedulerAction, SchedulerLike } from '../types';\n\nexport function executeSchedule(\n  parentSubscription: Subscription,\n  scheduler: SchedulerLike,\n  work: () => void,\n  delay: number,\n  repeat: true\n): void;\nexport function executeSchedule(\n  parentSubscription: Subscription,\n  scheduler: SchedulerLike,\n  work: () => void,\n  delay?: number,\n  repeat?: false\n): Subscription;\n\nexport function executeSchedule(\n  parentSubscription: Subscription,\n  scheduler: SchedulerLike,\n  work: () => void,\n  delay = 0,\n  repeat = false\n): Subscription | void {\n  const scheduleSubscription = scheduler.schedule(function (this: SchedulerAction<any>) {\n    work();\n    if (repeat) {\n      parentSubscription.add(this.schedule(null, delay));\n    } else {\n      this.unsubscribe();\n    }\n  }, delay);\n\n  parentSubscription.add(scheduleSubscription);\n\n  if (!repeat) {\n    // Because user-land scheduler implementations are unlikely to properly reuse\n    // Actions for repeat scheduling, we can't trust that the returned subscription\n    // will control repeat subscription scenarios. So we're trying to avoid using them\n    // incorrectly within this library.\n    return scheduleSubscription;\n  }\n}\n","/**\n * This function takes one parameter and just returns it. Simply put,\n * this is like `<T>(x: T): T => x`.\n *\n * ## Examples\n *\n * This is useful in some cases when using things like `mergeMap`\n *\n * ```ts\n * import { interval, take, map, range, mergeMap, identity } from 'rxjs';\n *\n * const source$ = interval(1000).pipe(take(5));\n *\n * const result$ = source$.pipe(\n *   map(i => range(i)),\n *   mergeMap(identity) // same as mergeMap(x => x)\n * );\n *\n * result$.subscribe({\n *   next: console.log\n * });\n * ```\n *\n * Or when you want to selectively apply an operator\n *\n * ```ts\n * import { interval, take, identity } from 'rxjs';\n *\n * const shouldLimit = () => Math.random() < 0.5;\n *\n * const source$ = interval(1000);\n *\n * const result$ = source$.pipe(shouldLimit() ? take(5) : identity);\n *\n * result$.subscribe({\n *   next: console.log\n * });\n * ```\n *\n * @param x Any value that is returned by this function\n * @returns The value passed as the first parameter to this function\n */\nexport function identity<T>(x: T): T {\n  return x;\n}\n","export const isArrayLike = (<T>(x: any): x is ArrayLike<T> => x && typeof x.length === 'number' && typeof x !== 'function');","import { isFunction } from './isFunction';\n\nexport function isAsyncIterable<T>(obj: any): obj is AsyncIterable<T> {\n  return Symbol.asyncIterator && isFunction(obj?.[Symbol.asyncIterator]);\n}\n","/**\n * Checks to see if a value is not only a `Date` object,\n * but a *valid* `Date` object that can be converted to a\n * number. For example, `new Date('blah')` is indeed an\n * `instanceof Date`, however it cannot be converted to a\n * number.\n */\nexport function isValidDate(value: any): value is Date {\n  return value instanceof Date && !isNaN(value as any);\n}\n","/**\n * Returns true if the object is a function.\n * @param value The value to check\n */\nexport function isFunction(value: any): value is (...args: any[]) => any {\n  return typeof value === 'function';\n}\n","import { InteropObservable } from '../types';\nimport { observable as Symbol_observable } from '../symbol/observable';\nimport { isFunction } from './isFunction';\n\n/** Identifies an input as being Observable (but not necessary an Rx Observable) */\nexport function isInteropObservable(input: any): input is InteropObservable<any> {\n  return isFunction(input[Symbol_observable]);\n}\n","import { iterator as Symbol_iterator } from '../symbol/iterator';\nimport { isFunction } from './isFunction';\n\n/** Identifies an input as being an Iterable */\nexport function isIterable(input: any): input is Iterable<any> {\n  return isFunction(input?.[Symbol_iterator]);\n}\n","/** prettier */\nimport { Observable } from '../Observable';\nimport { isFunction } from './isFunction';\n\n/**\n * Tests to see if the object is an RxJS {@link Observable}\n * @param obj the object to test\n */\nexport function isObservable(obj: any): obj is Observable<unknown> {\n  // The !! is to ensure that this publicly exposed function returns\n  // `false` if something like `null` or `0` is passed.\n  return !!obj && (obj instanceof Observable || (isFunction(obj.lift) && isFunction(obj.subscribe)));\n}\n","import { isFunction } from \"./isFunction\";\n\n/**\n * Tests to see if the object is \"thennable\".\n * @param value the object to test\n */\nexport function isPromise(value: any): value is PromiseLike<any> {\n  return isFunction(value?.then);\n}\n","import { ReadableStreamLike } from '../types';\nimport { isFunction } from './isFunction';\n\nexport async function* readableStreamLikeToAsyncGenerator<T>(readableStream: ReadableStreamLike<T>): AsyncGenerator<T> {\n  const reader = readableStream.getReader();\n  try {\n    while (true) {\n      const { value, done } = await reader.read();\n      if (done) {\n        return;\n      }\n      yield value!;\n    }\n  } finally {\n    reader.releaseLock();\n  }\n}\n\nexport function isReadableStreamLike<T>(obj: any): obj is ReadableStreamLike<T> {\n  // We don't want to use instanceof checks because they would return\n  // false for instances from another Realm, like an <iframe>.\n  return isFunction(obj?.getReader);\n}\n","import { SchedulerLike } from '../types';\nimport { isFunction } from './isFunction';\n\nexport function isScheduler(value: any): value is SchedulerLike {\n  return value && isFunction(value.schedule);\n}\n","import { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { OperatorFunction } from '../types';\nimport { isFunction } from './isFunction';\n\n/**\n * Used to determine if an object is an Observable with a lift function.\n */\nexport function hasLift(source: any): source is { lift: InstanceType<typeof Observable>['lift'] } {\n  return isFunction(source?.lift);\n}\n\n/**\n * Creates an `OperatorFunction`. Used to define operators throughout the library in a concise way.\n * @param init The logic to connect the liftedSource to the subscriber at the moment of subscription.\n */\nexport function operate<T, R>(\n  init: (liftedSource: Observable<T>, subscriber: Subscriber<R>) => (() => void) | void\n): OperatorFunction<T, R> {\n  return (source: Observable<T>) => {\n    if (hasLift(source)) {\n      return source.lift(function (this: Subscriber<R>, liftedSource: Observable<T>) {\n        try {\n          return init(liftedSource, this);\n        } catch (err) {\n          this.error(err);\n        }\n      });\n    }\n    throw new TypeError('Unable to lift unknown Observable type');\n  };\n}\n","import { OperatorFunction } from \"../types\";\nimport { map } from \"../operators/map\";\n\nconst { isArray } = Array;\n\nfunction callOrApply<T, R>(fn: ((...values: T[]) => R), args: T|T[]): R {\n    return isArray(args) ? fn(...args) : fn(args);\n}\n\n/**\n * Used in several -- mostly deprecated -- situations where we need to \n * apply a list of arguments or a single argument to a result selector.\n */\nexport function mapOneOrManyArgs<T, R>(fn: ((...values: T[]) => R)): OperatorFunction<T|T[], R> {\n    return map(args => callOrApply(fn, args))\n}","/* tslint:disable:no-empty */\nexport function noop() { }\n","export function not<T>(pred: (value: T, index: number) => boolean, thisArg: any): (value: T, index: number) => boolean {\n  return (value: T, index: number) => !pred.call(thisArg, value, index); \n}","import { identity } from './identity';\nimport { UnaryFunction } from '../types';\n\nexport function pipe(): typeof identity;\nexport function pipe<T, A>(fn1: UnaryFunction<T, A>): UnaryFunction<T, A>;\nexport function pipe<T, A, B>(fn1: UnaryFunction<T, A>, fn2: UnaryFunction<A, B>): UnaryFunction<T, B>;\nexport function pipe<T, A, B, C>(fn1: UnaryFunction<T, A>, fn2: UnaryFunction<A, B>, fn3: UnaryFunction<B, C>): UnaryFunction<T, C>;\nexport function pipe<T, A, B, C, D>(\n  fn1: UnaryFunction<T, A>,\n  fn2: UnaryFunction<A, B>,\n  fn3: UnaryFunction<B, C>,\n  fn4: UnaryFunction<C, D>\n): UnaryFunction<T, D>;\nexport function pipe<T, A, B, C, D, E>(\n  fn1: UnaryFunction<T, A>,\n  fn2: UnaryFunction<A, B>,\n  fn3: UnaryFunction<B, C>,\n  fn4: UnaryFunction<C, D>,\n  fn5: UnaryFunction<D, E>\n): UnaryFunction<T, E>;\nexport function pipe<T, A, B, C, D, E, F>(\n  fn1: UnaryFunction<T, A>,\n  fn2: UnaryFunction<A, B>,\n  fn3: UnaryFunction<B, C>,\n  fn4: UnaryFunction<C, D>,\n  fn5: UnaryFunction<D, E>,\n  fn6: UnaryFunction<E, F>\n): UnaryFunction<T, F>;\nexport function pipe<T, A, B, C, D, E, F, G>(\n  fn1: UnaryFunction<T, A>,\n  fn2: UnaryFunction<A, B>,\n  fn3: UnaryFunction<B, C>,\n  fn4: UnaryFunction<C, D>,\n  fn5: UnaryFunction<D, E>,\n  fn6: UnaryFunction<E, F>,\n  fn7: UnaryFunction<F, G>\n): UnaryFunction<T, G>;\nexport function pipe<T, A, B, C, D, E, F, G, H>(\n  fn1: UnaryFunction<T, A>,\n  fn2: UnaryFunction<A, B>,\n  fn3: UnaryFunction<B, C>,\n  fn4: UnaryFunction<C, D>,\n  fn5: UnaryFunction<D, E>,\n  fn6: UnaryFunction<E, F>,\n  fn7: UnaryFunction<F, G>,\n  fn8: UnaryFunction<G, H>\n): UnaryFunction<T, H>;\nexport function pipe<T, A, B, C, D, E, F, G, H, I>(\n  fn1: UnaryFunction<T, A>,\n  fn2: UnaryFunction<A, B>,\n  fn3: UnaryFunction<B, C>,\n  fn4: UnaryFunction<C, D>,\n  fn5: UnaryFunction<D, E>,\n  fn6: UnaryFunction<E, F>,\n  fn7: UnaryFunction<F, G>,\n  fn8: UnaryFunction<G, H>,\n  fn9: UnaryFunction<H, I>\n): UnaryFunction<T, I>;\nexport function pipe<T, A, B, C, D, E, F, G, H, I>(\n  fn1: UnaryFunction<T, A>,\n  fn2: UnaryFunction<A, B>,\n  fn3: UnaryFunction<B, C>,\n  fn4: UnaryFunction<C, D>,\n  fn5: UnaryFunction<D, E>,\n  fn6: UnaryFunction<E, F>,\n  fn7: UnaryFunction<F, G>,\n  fn8: UnaryFunction<G, H>,\n  fn9: UnaryFunction<H, I>,\n  ...fns: UnaryFunction<any, any>[]\n): UnaryFunction<T, unknown>;\n\n/**\n * pipe() can be called on one or more functions, each of which can take one argument (\"UnaryFunction\")\n * and uses it to return a value.\n * It returns a function that takes one argument, passes it to the first UnaryFunction, and then\n * passes the result to the next one, passes that result to the next one, and so on.  \n */\nexport function pipe(...fns: Array<UnaryFunction<any, any>>): UnaryFunction<any, any> {\n  return pipeFromArray(fns);\n}\n\n/** @internal */\nexport function pipeFromArray<T, R>(fns: Array<UnaryFunction<T, R>>): UnaryFunction<T, R> {\n  if (fns.length === 0) {\n    return identity as UnaryFunction<any, any>;\n  }\n\n  if (fns.length === 1) {\n    return fns[0];\n  }\n\n  return function piped(input: T): R {\n    return fns.reduce((prev: any, fn: UnaryFunction<T, R>) => fn(prev), input as any);\n  };\n}\n","import { config } from '../config';\nimport { timeoutProvider } from '../scheduler/timeoutProvider';\n\n/**\n * Handles an error on another job either with the user-configured {@link onUnhandledError},\n * or by throwing it on that new job so it can be picked up by `window.onerror`, `process.on('error')`, etc.\n *\n * This should be called whenever there is an error that is out-of-band with the subscription\n * or when an error hits a terminal boundary of the subscription and no error handler was provided.\n *\n * @param err the error to report\n */\nexport function reportUnhandledError(err: any) {\n  timeoutProvider.setTimeout(() => {\n    const { onUnhandledError } = config;\n    if (onUnhandledError) {\n      // Execute the user-configured error handler.\n      onUnhandledError(err);\n    } else {\n      // Throw so it is picked up by the runtime's uncaught error mechanism.\n      throw err;\n    }\n  });\n}\n","/**\n * Creates the TypeError to throw if an invalid object is passed to `from` or `scheduled`.\n * @param input The object that was passed.\n */\nexport function createInvalidObservableTypeError(input: any) {\n  // TODO: We should create error codes that can be looked up, so this can be less verbose.\n  return new TypeError(\n    `You provided ${\n      input !== null && typeof input === 'object' ? 'an invalid object' : `'${input}'`\n    } where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.`\n  );\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getNeighbours = exports.getNode = exports.clearGrid = exports.removeWall = exports.addWall = void 0;\nvar properties_1 = require(\"./properties\");\nfunction addWall(x, y) {\n    properties_1.mazeProperties.grid[x][y] = -1;\n}\nexports.addWall = addWall;\nfunction removeWall(x, y) {\n    properties_1.mazeProperties.grid[x][y] = 0;\n}\nexports.removeWall = removeWall;\nfunction clearGrid() {\n    if (!properties_1.mazeProperties.isGridClean) {\n        for (var i = 0; i < properties_1.mazeProperties.timeouts.length; i++) {\n            clearTimeout(properties_1.mazeProperties.timeouts[i]);\n        }\n        properties_1.mazeProperties.timeouts = [];\n        clearInterval(properties_1.mazeProperties.myInterval);\n        for (var i = 0; i < properties_1.mazeProperties.grid.length; i++) {\n            for (var j = 0; j < properties_1.mazeProperties.grid[0].length; j++) {\n                if (properties_1.mazeProperties.grid[i][j] > -1) {\n                    removeWall(i, j);\n                }\n                else if (properties_1.mazeProperties.grid[i][j] < -1) {\n                    addWall(i, j);\n                }\n            }\n        }\n        properties_1.mazeProperties.isGridClean = true;\n    }\n}\nexports.clearGrid = clearGrid;\nfunction getNode(x, y) {\n    if (x >= 0 && x < properties_1.mazeProperties.grid.length && y >= 0 && y < properties_1.mazeProperties.grid[0].length) {\n        return properties_1.mazeProperties.grid[x][y];\n    }\n    return -2;\n}\nexports.getNode = getNode;\nfunction getNeighbours(cell, distance) {\n    var up = [cell[0], cell[1] - distance];\n    var right = [cell[0] + distance, cell[1]];\n    var down = [cell[0], cell[1] + distance];\n    var left = [cell[0] - distance, cell[1]];\n    return [up, right, down, left];\n}\nexports.getNeighbours = getNeighbours;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.convertirLaberinto = void 0;\nfunction convertirLaberinto(maze, pathWidth) {\n    var newMaze = [];\n    var originalWidth = maze.length;\n    var originalHeight = maze[0].length;\n    // Calcula el nuevo ancho y alto del laberinto\n    var newWidth = (originalWidth - 2) * pathWidth + 2;\n    var newHeight = (originalHeight - 2) * pathWidth + 2;\n    // Inicializa el nuevo laberinto con muros (-1)\n    for (var i = 0; i < newWidth; i++) {\n        newMaze[i] = [];\n        for (var j = 0; j < newHeight; j++) {\n            newMaze[i][j] = -1;\n        }\n    }\n    // Copia los caminos y la meta del laberinto original al nuevo laberinto\n    for (var i = 1; i < originalWidth - 1; i++) {\n        for (var j = 1; j < originalHeight - 1; j++) {\n            if (maze[i][j] === 0) {\n                for (var i2 = (i * pathWidth - pathWidth + 1); i2 <= (i * pathWidth); i2++) {\n                    for (var j2 = (j * pathWidth - pathWidth + 1); j2 <= (j * pathWidth); j2++) {\n                        newMaze[i2][j2] = 0;\n                    }\n                }\n            }\n            if (maze[i][j] === 99) {\n                for (var i2 = (i * pathWidth - pathWidth + 1); i2 <= (i * pathWidth); i2++) {\n                    for (var j2 = (j * pathWidth - pathWidth + 1); j2 <= (j * pathWidth); j2++) {\n                        newMaze[i2][j2] = 99;\n                    }\n                }\n            }\n        }\n    }\n    return newMaze;\n}\nexports.convertirLaberinto = convertirLaberinto;\n","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.generateMazeAndSolution = void 0;\nvar rxjs_1 = require(\"rxjs\");\nvar maze_generators_1 = require(\"./maze_generators\");\nvar properties_1 = require(\"./properties\");\nwindow.onload = function () {\n    generateMazeAndSolution(11, 11, 3);\n};\nfunction generateMazeAndSolution(gridSizeX, gridSizeY, pathWidth) {\n    return __awaiter(this, void 0, void 0, function () {\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    properties_1.initialConfig.gridSizeX = gridSizeX;\n                    properties_1.initialConfig.gridSizeY = gridSizeY;\n                    properties_1.initialConfig.pathWidth = pathWidth;\n                    generateGrid();\n                    (0, maze_generators_1.maze_generators)();\n                    return [4 /*yield*/, (0, rxjs_1.firstValueFrom)(properties_1.finishedGeneration)];\n                case 1:\n                    _a.sent();\n                    console.log(JSON.parse(JSON.stringify(properties_1.mazeProperties)));\n                    return [2 /*return*/];\n            }\n        });\n    });\n}\nexports.generateMazeAndSolution = generateMazeAndSolution;\nfunction generateGrid() {\n    properties_1.mazeProperties.grid = new Array(properties_1.initialConfig.gridSizeX).fill(0).map(function () { return new Array(properties_1.initialConfig.gridSizeY).fill(0); });\n    properties_1.mazeProperties.startPos = [1, properties_1.initialConfig.gridSizeY - 2];\n    properties_1.mazeProperties.targetPos = [properties_1.initialConfig.gridSizeX - 2, 1];\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.maze_generators = void 0;\nvar common_1 = require(\"./common\");\nvar conversor_1 = require(\"./conversor\");\nvar maze_solvers_1 = require(\"./maze_solvers\");\nvar properties_1 = require(\"./properties\");\nfunction maze_generators() {\n    properties_1.mazeProperties.generating = true;\n    properties_1.mazeProperties.isGridClean = false;\n    switch (properties_1.selectedGenAlgorithm) {\n        case 1:\n            randomized_depth_first();\n            break;\n        case 2:\n            kruskal_algorithm();\n            break;\n        case 3:\n            primAlgorithm();\n            break;\n        case 4:\n            wilson_algorithm();\n            break;\n        case 5:\n            aldousBroderAlgorithm();\n            break;\n        case 6:\n            recursiveDivision();\n            break;\n        default:\n            kruskal_algorithm();\n            break;\n    }\n}\nexports.maze_generators = maze_generators;\nfunction finishGenerate() {\n    properties_1.mazeProperties.finishedGrid = JSON.parse(JSON.stringify(properties_1.mazeProperties.grid));\n    properties_1.mazeProperties.finishedGrid[properties_1.mazeProperties.startPos[1]][properties_1.mazeProperties.startPos[0]] = 99;\n    var newMaze = (0, conversor_1.convertirLaberinto)(properties_1.mazeProperties.finishedGrid, properties_1.initialConfig.pathWidth);\n    properties_1.mazeProperties.renderGrid = newMaze;\n    (0, maze_solvers_1.maze_solvers)();\n}\nfunction enclose() {\n    for (var i = 0; i < properties_1.mazeProperties.grid.length; i++) {\n        (0, common_1.addWall)(i, 0);\n        (0, common_1.addWall)(i, properties_1.mazeProperties.grid[0].length - 1);\n    }\n    for (var j = 0; j < properties_1.mazeProperties.grid[0].length; j++) {\n        (0, common_1.addWall)(0, j);\n        (0, common_1.addWall)(properties_1.mazeProperties.grid.length - 1, j);\n    }\n}\nfunction randomized_depth_first() {\n    fill();\n    var currentCell = [1, 1];\n    (0, common_1.removeWall)(currentCell[0], currentCell[1]);\n    properties_1.mazeProperties.grid[currentCell[0]][currentCell[1]] = 1;\n    var stack = [currentCell];\n    properties_1.mazeProperties.myInterval = window.setInterval(function () {\n        if (stack.length == 0) {\n            clearInterval(properties_1.mazeProperties.myInterval);\n            (0, common_1.clearGrid)();\n            properties_1.mazeProperties.generating = false;\n            finishGenerate();\n            return;\n        }\n        currentCell = stack.pop();\n        var neighbours = [];\n        var list = (0, common_1.getNeighbours)(currentCell, 2);\n        for (var i = 0; i < list.length; i++) {\n            if ((0, common_1.getNode)(list[i][0], list[i][1]) == -1 || (0, common_1.getNode)(list[i][0], list[i][1]) == 0) {\n                neighbours.push(list[i]);\n            }\n        }\n        if (neighbours.length > 0) {\n            stack.push(currentCell);\n            var chosen_cell = neighbours[randomInt(0, neighbours.length)];\n            (0, common_1.removeWall)((currentCell[0] + chosen_cell[0]) / 2, (currentCell[1] + chosen_cell[1]) / 2);\n            (0, common_1.removeWall)(chosen_cell[0], chosen_cell[1]);\n            properties_1.mazeProperties.grid[chosen_cell[0]][chosen_cell[1]] = 1;\n            stack.push(chosen_cell);\n        }\n        else {\n            (0, common_1.removeWall)(currentCell[0], currentCell[1]);\n            properties_1.mazeProperties.grid[currentCell[0]][currentCell[1]] = 2;\n        }\n    }, 16);\n}\nfunction kruskal_algorithm() {\n    fillWalls();\n    var nb_areas = 0;\n    var wall_list = [];\n    for (var i = 1; i < properties_1.mazeProperties.grid.length - 1; i++) {\n        for (var j = 1; j < properties_1.mazeProperties.grid[0].length - 1; j++) {\n            if (i % 2 == 1 && j % 2 == 1) {\n                nb_areas++;\n                properties_1.mazeProperties.grid[i][j] = nb_areas;\n            }\n            if ((i + j) % 2 == 1)\n                wall_list.push([i, j]);\n        }\n    }\n    properties_1.mazeProperties.myInterval = window.setInterval(function () {\n        while (true) {\n            if (nb_areas == 1) {\n                clearInterval(properties_1.mazeProperties.myInterval);\n                (0, common_1.clearGrid)();\n                properties_1.mazeProperties.generating = false;\n                finishGenerate();\n                return;\n            }\n            var index = randomInt(0, wall_list.length);\n            var wall = wall_list[index];\n            wall_list.splice(index, 1);\n            var cell_pair = void 0;\n            if (properties_1.mazeProperties.grid[wall[0] - 1][wall[1]] > -1) {\n                cell_pair = [properties_1.mazeProperties.grid[wall[0] - 1][wall[1]], properties_1.mazeProperties.grid[wall[0] + 1][wall[1]]];\n            }\n            else {\n                cell_pair = [properties_1.mazeProperties.grid[wall[0]][wall[1] - 1], properties_1.mazeProperties.grid[wall[0]][wall[1] + 1]];\n            }\n            if (cell_pair[0] != cell_pair[1]) {\n                for (var i = 1; i < properties_1.mazeProperties.grid.length - 1; i += 2) {\n                    for (var j = 1; j < properties_1.mazeProperties.grid[0].length - 1; j += 2) {\n                        if (properties_1.mazeProperties.grid[i][j] == cell_pair[0]) {\n                            properties_1.mazeProperties.grid[i][j] = cell_pair[1];\n                        }\n                    }\n                }\n                (0, common_1.removeWall)(wall[0], wall[1]);\n                nb_areas--;\n                return;\n            }\n        }\n    }, 29);\n}\nfunction primAlgorithm() {\n    fill();\n    var first_cell = [1, 1];\n    (0, common_1.removeWall)(first_cell[0], first_cell[1]);\n    properties_1.mazeProperties.grid[first_cell[0]][first_cell[1]] = 1;\n    var wall_list = [];\n    var list = (0, common_1.getNeighbours)(first_cell, 1);\n    for (var i = 0; i < list.length; i++) {\n        if (list[i][0] > 0 && list[i][0] < properties_1.mazeProperties.grid.length - 1 && list[i][1] > 0 && list[i][1] < properties_1.mazeProperties.grid[0].length - 1) {\n            wall_list.push(list[i]);\n        }\n    }\n    properties_1.mazeProperties.myInterval = window.setInterval(function () {\n        while (true) {\n            if (wall_list.length == 0) {\n                clearInterval(properties_1.mazeProperties.myInterval);\n                (0, common_1.clearGrid)();\n                properties_1.mazeProperties.generating = false;\n                finishGenerate();\n                return;\n            }\n            var index = randomInt(0, wall_list.length);\n            var wall = wall_list[index];\n            wall_list.splice(index, 1);\n            var cell_pair = void 0;\n            if (wall[0] % 2 == 0) {\n                cell_pair = [[wall[0] - 1, wall[1]], [wall[0] + 1, wall[1]]];\n            }\n            else {\n                cell_pair = [[wall[0], wall[1] - 1], [wall[0], wall[1] + 1]];\n            }\n            var new_cell = void 0;\n            var valid = false;\n            if (properties_1.mazeProperties.grid[cell_pair[0][0]][cell_pair[0][1]] < 1) {\n                new_cell = cell_pair[0];\n                valid = true;\n            }\n            else if (properties_1.mazeProperties.grid[cell_pair[1][0]][cell_pair[1][1]] < 1) {\n                new_cell = cell_pair[1];\n                valid = true;\n            }\n            if (valid) {\n                (0, common_1.removeWall)(wall[0], wall[1]);\n                (0, common_1.removeWall)(new_cell[0], new_cell[1]);\n                properties_1.mazeProperties.grid[new_cell[0]][new_cell[1]] = 1;\n                var list_1 = (0, common_1.getNeighbours)(new_cell, 1);\n                for (var i = 0; i < list_1.length; i++) {\n                    if (list_1[i][0] > 0 && list_1[i][0] < properties_1.mazeProperties.grid.length - 1 &&\n                        list_1[i][1] > 0 && list_1[i][1] < properties_1.mazeProperties.grid[0].length - 1) {\n                        wall_list.push(list_1[i]);\n                    }\n                }\n                return;\n            }\n        }\n    }, 28);\n}\nfunction wilson_algorithm() {\n    fill();\n    var cell_list = [];\n    for (var i = 1; i < properties_1.mazeProperties.grid.length - 1; i += 2) {\n        for (var j = 1; j < properties_1.mazeProperties.grid[0].length - 1; j += 2) {\n            cell_list.push([i, j]);\n        }\n    }\n    var first_cell = cell_list[0];\n    cell_list.splice(0, 1);\n    properties_1.mazeProperties.grid[first_cell[0]][first_cell[1]] = 10;\n    var currentCell = cell_list[randomInt(0, cell_list.length)];\n    var random_walk = true;\n    var first_step = currentCell;\n    var new_way_list = [];\n    properties_1.mazeProperties.myInterval = window.setInterval(function () {\n        if (cell_list.length == 0) {\n            clearInterval(properties_1.mazeProperties.myInterval);\n            (0, common_1.clearGrid)();\n            properties_1.mazeProperties.generating = false;\n            finishGenerate();\n            return;\n        }\n        if (random_walk) {\n            while (true) {\n                var list = (0, common_1.getNeighbours)(currentCell, 2);\n                var index = void 0;\n                var chosen_cell = void 0;\n                do {\n                    index = randomInt(0, list.length);\n                    chosen_cell = list[index];\n                } while ((0, common_1.getNode)(chosen_cell[0], chosen_cell[1]) == -2);\n                properties_1.mazeProperties.grid[currentCell[0]][currentCell[1]] = -(index + 3);\n                if (properties_1.mazeProperties.grid[chosen_cell[0]][chosen_cell[1]] == 10) {\n                    random_walk = false;\n                    currentCell = first_step;\n                    return;\n                }\n                else\n                    currentCell = chosen_cell;\n            }\n        }\n        else {\n            if (properties_1.mazeProperties.grid[currentCell[0]][currentCell[1]] == 10) {\n                currentCell = cell_list[randomInt(0, cell_list.length)];\n                random_walk = true;\n                first_step = currentCell;\n                new_way_list = [];\n            }\n            else {\n                var index = -properties_1.mazeProperties.grid[currentCell[0]][currentCell[1]] - 3;\n                var next_cell = (0, common_1.getNeighbours)(currentCell, 2)[index];\n                var wall = [(currentCell[0] + next_cell[0]) / 2, (currentCell[1] + next_cell[1]) / 2];\n                new_way_list.push(currentCell);\n                new_way_list.push(wall);\n                (0, common_1.removeWall)(currentCell[0], currentCell[1]);\n                (0, common_1.removeWall)(wall[0], wall[1]);\n                properties_1.mazeProperties.grid[currentCell[0]][currentCell[1]] = 10;\n                for (var i = 0; i < cell_list.length; i++) {\n                    if (cell_list[i][0] == currentCell[0] && cell_list[i][1] == currentCell[1]) {\n                        cell_list.splice(i, 1);\n                        break;\n                    }\n                }\n                currentCell = next_cell;\n            }\n        }\n    }, 18);\n}\nfunction aldousBroderAlgorithm() {\n    fill();\n    var cells_nb = ((properties_1.mazeProperties.grid.length - 1) / 2) * ((properties_1.mazeProperties.grid[0].length - 1) / 2);\n    var currentCell = [1, 1];\n    (0, common_1.removeWall)(currentCell[0], currentCell[1]);\n    properties_1.mazeProperties.grid[currentCell[0]][currentCell[1]] = 1;\n    cells_nb--;\n    properties_1.mazeProperties.myInterval = window.setInterval(function () {\n        if (cells_nb == 0) {\n            clearInterval(properties_1.mazeProperties.myInterval);\n            (0, common_1.clearGrid)();\n            properties_1.mazeProperties.generating = false;\n            finishGenerate();\n            return;\n        }\n        while (true) {\n            var neighbours = [];\n            var list = (0, common_1.getNeighbours)(currentCell, 2);\n            for (var i = 0; i < list.length; i++) {\n                if ((0, common_1.getNode)(list[i][0], list[i][1]) != -2) {\n                    neighbours.push(list[i]);\n                }\n            }\n            var chosen_cell = neighbours[randomInt(0, neighbours.length)];\n            if (properties_1.mazeProperties.grid[chosen_cell[0]][chosen_cell[1]] != 1) {\n                var wall = [(currentCell[0] + chosen_cell[0]) / 2, (currentCell[1] + chosen_cell[1]) / 2];\n                (0, common_1.removeWall)(wall[0], wall[1]);\n                (0, common_1.removeWall)(chosen_cell[0], chosen_cell[1]);\n                properties_1.mazeProperties.grid[chosen_cell[0]][chosen_cell[1]] = 1;\n                cells_nb--;\n                currentCell = chosen_cell;\n                return;\n            }\n            currentCell = chosen_cell;\n        }\n    }, 28);\n}\nfunction recursiveDivision() {\n    enclose();\n    var time = 0;\n    var step = 17;\n    properties_1.mazeProperties.timeouts = [];\n    function subRecursiveDivision(x_min, y_min, x_max, y_max) {\n        if (y_max - y_min > x_max - x_min) {\n            var x = randomInt(x_min + 1, x_max);\n            var y_1 = randomInt(y_min + 2, y_max - 1);\n            if ((x - x_min) % 2 == 0) {\n                x += (randomInt(0, 2) == 0 ? 1 : -1);\n            }\n            if ((y_1 - y_min) % 2 == 1) {\n                y_1 += (randomInt(0, 2) == 0 ? 1 : -1);\n            }\n            var _loop_1 = function (i) {\n                if (i != x) {\n                    time += step;\n                    properties_1.mazeProperties.timeouts.push(setTimeout(function () { (0, common_1.addWall)(i, y_1); }, time));\n                }\n            };\n            for (var i = x_min + 1; i < x_max; i++) {\n                _loop_1(i);\n            }\n            if (y_1 - y_min > 2) {\n                subRecursiveDivision(x_min, y_min, x_max, y_1);\n            }\n            if (y_max - y_1 > 2) {\n                subRecursiveDivision(x_min, y_1, x_max, y_max);\n            }\n        }\n        else {\n            var x_1 = randomInt(x_min + 2, x_max - 1);\n            var y = randomInt(y_min + 1, y_max);\n            if ((x_1 - x_min) % 2 == 1) {\n                x_1 += (randomInt(0, 2) == 0 ? 1 : -1);\n            }\n            if ((y - y_min) % 2 == 0) {\n                y += (randomInt(0, 2) == 0 ? 1 : -1);\n            }\n            var _loop_2 = function (i) {\n                if (i != y) {\n                    time += step;\n                    properties_1.mazeProperties.timeouts.push(setTimeout(function () { (0, common_1.addWall)(x_1, i); }, time));\n                }\n            };\n            for (var i = y_min + 1; i < y_max; i++) {\n                _loop_2(i);\n            }\n            if (x_1 - x_min > 2) {\n                subRecursiveDivision(x_min, y_min, x_1, y_max);\n            }\n            if (x_max - x_1 > 2) {\n                subRecursiveDivision(x_1, y_min, x_max, y_max);\n            }\n        }\n    }\n    subRecursiveDivision(0, 0, properties_1.mazeProperties.grid.length - 1, properties_1.mazeProperties.grid[0].length - 1);\n    properties_1.mazeProperties.timeouts.push(setTimeout(function () { properties_1.mazeProperties.generating = false; properties_1.mazeProperties.timeouts = []; }, time));\n}\nfunction randomInt(min, max) {\n    min = Math.ceil(min);\n    max = Math.floor(max);\n    return Math.floor(Math.random() * (max - min)) + min;\n}\nfunction fill() {\n    for (var i = 0; i < properties_1.mazeProperties.grid.length; i++)\n        for (var j = 0; j < properties_1.mazeProperties.grid[0].length; j++)\n            (0, common_1.addWall)(i, j);\n}\nfunction fillWalls() {\n    for (var i = 0; i < properties_1.mazeProperties.grid.length; i++)\n        for (var j = 0; j < properties_1.mazeProperties.grid[0].length; j++)\n            if (i % 2 == 0 || j % 2 == 0)\n                (0, common_1.addWall)(i, j);\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.maze_solvers = void 0;\nvar common_1 = require(\"./common\");\nvar properties_1 = require(\"./properties\");\nvar nodeList;\nvar nodeListIndex;\nvar pathList;\nvar pathListIndex;\nvar found = false;\nvar path = false;\nfunction maze_solvers() {\n    (0, common_1.clearGrid)();\n    properties_1.mazeProperties.isGridClean = false;\n    (0, common_1.clearGrid)();\n    switch (properties_1.selectedSolveAlgorithm) {\n        case 1:\n            breadthFirst();\n            break;\n        case 2:\n            bidirectional_breadthFirst();\n            break;\n        case 3:\n            greedyBestFirst();\n            break;\n        case 4:\n            dijkstra();\n            break;\n        case 5:\n            aStar();\n            break;\n        default:\n            dijkstra();\n            break;\n    }\n}\nexports.maze_solvers = maze_solvers;\nfunction distance(point_1, point_2) {\n    return Math.sqrt(Math.pow(point_2[0] - point_1[0], 2) + Math.pow(point_2[1] - point_1[1], 2));\n}\nfunction mazeSolversInterval() {\n    properties_1.mazeProperties.myInterval = window.setInterval(function () {\n        if (!path) {\n            nodeListIndex++;\n            if (nodeListIndex == nodeList.length) {\n                if (!found)\n                    clearInterval(properties_1.mazeProperties.myInterval);\n                else {\n                    path = true;\n                }\n            }\n        }\n        else {\n            if (pathListIndex == pathList.length) {\n                clearInterval(properties_1.mazeProperties.myInterval);\n                properties_1.mazeProperties.finishedPath = JSON.parse(JSON.stringify(pathList));\n                properties_1.finishedGeneration.next(properties_1.mazeProperties);\n                return;\n            }\n            pathListIndex++;\n        }\n    }, 10);\n}\nfunction breadthFirst() {\n    nodeList = [];\n    nodeListIndex = 0;\n    pathList = [];\n    pathListIndex = 0;\n    found = false;\n    path = false;\n    var frontier = [properties_1.mazeProperties.startPos];\n    properties_1.mazeProperties.grid[properties_1.mazeProperties.startPos[0]][properties_1.mazeProperties.startPos[1]] = 1;\n    do {\n        var list = (0, common_1.getNeighbours)(frontier[0], 1);\n        frontier.splice(0, 1);\n        for (var i = 0; i < list.length; i++) {\n            if ((0, common_1.getNode)(list[i][0], list[i][1]) == 0) {\n                frontier.push(list[i]);\n                properties_1.mazeProperties.grid[list[i][0]][list[i][1]] = i + 1;\n                if (list[i][0] == properties_1.mazeProperties.targetPos[0] && list[i][1] == properties_1.mazeProperties.targetPos[1]) {\n                    found = true;\n                    break;\n                }\n                nodeList.push(list[i]);\n            }\n        }\n    } while (frontier.length > 0 && !found);\n    if (found) {\n        var currentNode = properties_1.mazeProperties.targetPos;\n        while (currentNode[0] != properties_1.mazeProperties.startPos[0] || currentNode[1] != properties_1.mazeProperties.startPos[1]) {\n            switch (properties_1.mazeProperties.grid[currentNode[0]][currentNode[1]]) {\n                case 1:\n                    currentNode = [currentNode[0], currentNode[1] + 1];\n                    break;\n                case 2:\n                    currentNode = [currentNode[0] - 1, currentNode[1]];\n                    break;\n                case 3:\n                    currentNode = [currentNode[0], currentNode[1] - 1];\n                    break;\n                case 4:\n                    currentNode = [currentNode[0] + 1, currentNode[1]];\n                    break;\n                default:\n                    break;\n            }\n            pathList.push(currentNode);\n        }\n        pathList.pop();\n        pathList.reverse();\n    }\n    mazeSolversInterval();\n}\nfunction bidirectional_breadthFirst() {\n    nodeList = [];\n    nodeListIndex = 0;\n    pathList = [];\n    pathListIndex = 0;\n    found = false;\n    path = false;\n    var currentCell;\n    var start_end;\n    var target_end;\n    var frontier = [properties_1.mazeProperties.startPos, properties_1.mazeProperties.targetPos];\n    properties_1.mazeProperties.grid[properties_1.mazeProperties.targetPos[0]][properties_1.mazeProperties.targetPos[1]] = 1;\n    properties_1.mazeProperties.grid[properties_1.mazeProperties.startPos[0]][properties_1.mazeProperties.startPos[1]] = 11;\n    do {\n        currentCell = frontier[0];\n        var list = (0, common_1.getNeighbours)(currentCell, 1);\n        frontier.splice(0, 1);\n        for (var i = 0; i < list.length; i++) {\n            if ((0, common_1.getNode)(list[i][0], list[i][1]) == 0) {\n                frontier.push(list[i]);\n                if (properties_1.mazeProperties.grid[currentCell[0]][currentCell[1]] < 10) {\n                    properties_1.mazeProperties.grid[list[i][0]][list[i][1]] = i + 1;\n                }\n                else {\n                    properties_1.mazeProperties.grid[list[i][0]][list[i][1]] = 11 + i;\n                }\n                nodeList.push(list[i]);\n            }\n            else if ((0, common_1.getNode)(list[i][0], list[i][1]) > 0) {\n                if (properties_1.mazeProperties.grid[currentCell[0]][currentCell[1]] < 10 && (0, common_1.getNode)(list[i][0], list[i][1]) > 10) {\n                    start_end = currentCell;\n                    target_end = list[i];\n                    found = true;\n                    break;\n                }\n                else if (properties_1.mazeProperties.grid[currentCell[0]][currentCell[1]] > 10 && (0, common_1.getNode)(list[i][0], list[i][1]) < 10) {\n                    start_end = list[i];\n                    target_end = currentCell;\n                    found = true;\n                    break;\n                }\n            }\n        }\n    } while (frontier.length > 0 && !found);\n    if (found) {\n        var targets = [properties_1.mazeProperties.targetPos, properties_1.mazeProperties.startPos];\n        var starts = [start_end, target_end];\n        for (var i = 0; i < starts.length; i++) {\n            var currentNode = starts[i];\n            while (currentNode[0] != targets[i][0] || currentNode[1] != targets[i][1]) {\n                pathList.push(currentNode);\n                switch (properties_1.mazeProperties.grid[currentNode[0]][currentNode[1]] - (i * 10)) {\n                    case 1:\n                        currentNode = [currentNode[0], currentNode[1] + 1];\n                        break;\n                    case 2:\n                        currentNode = [currentNode[0] - 1, currentNode[1]];\n                        break;\n                    case 3:\n                        currentNode = [currentNode[0], currentNode[1] - 1];\n                        break;\n                    case 4:\n                        currentNode = [currentNode[0] + 1, currentNode[1]];\n                        break;\n                    default:\n                        break;\n                }\n            }\n            if (i == 0) {\n                pathList.reverse();\n            }\n        }\n        pathList.reverse();\n    }\n    mazeSolversInterval();\n}\nfunction greedyBestFirst() {\n    nodeList = [];\n    nodeListIndex = 0;\n    pathList = [];\n    pathListIndex = 0;\n    found = false;\n    path = false;\n    var frontier = [properties_1.mazeProperties.startPos];\n    properties_1.mazeProperties.grid[properties_1.mazeProperties.startPos[0]][properties_1.mazeProperties.startPos[1]] = 1;\n    do {\n        frontier.sort(function (a, b) {\n            return distance(a, properties_1.mazeProperties.targetPos) - distance(b, properties_1.mazeProperties.targetPos);\n        });\n        var list = (0, common_1.getNeighbours)(frontier[0], 1);\n        frontier.splice(0, 1);\n        for (var i = 0; i < list.length; i++) {\n            if ((0, common_1.getNode)(list[i][0], list[i][1]) == 0) {\n                frontier.push(list[i]);\n                properties_1.mazeProperties.grid[list[i][0]][list[i][1]] = i + 1;\n                if (list[i][0] == properties_1.mazeProperties.targetPos[0] && list[i][1] == properties_1.mazeProperties.targetPos[1]) {\n                    found = true;\n                    break;\n                }\n                nodeList.push(list[i]);\n            }\n        }\n    } while (frontier.length > 0 && !found);\n    if (found) {\n        var currentNode = properties_1.mazeProperties.targetPos;\n        while (currentNode[0] != properties_1.mazeProperties.startPos[0] || currentNode[1] != properties_1.mazeProperties.startPos[1]) {\n            switch (properties_1.mazeProperties.grid[currentNode[0]][currentNode[1]]) {\n                case 1:\n                    currentNode = [currentNode[0], currentNode[1] + 1];\n                    break;\n                case 2:\n                    currentNode = [currentNode[0] - 1, currentNode[1]];\n                    break;\n                case 3:\n                    currentNode = [currentNode[0], currentNode[1] - 1];\n                    break;\n                case 4:\n                    currentNode = [currentNode[0] + 1, currentNode[1]];\n                    break;\n                default:\n                    break;\n            }\n            pathList.push(currentNode);\n        }\n        pathList.pop();\n        pathList.reverse();\n    }\n    mazeSolversInterval();\n}\nfunction dijkstra() {\n    breadthFirst();\n}\nfunction aStar() {\n    nodeList = [];\n    nodeListIndex = 0;\n    pathList = [];\n    pathListIndex = 0;\n    found = false;\n    path = false;\n    var frontier = [properties_1.mazeProperties.startPos];\n    var costGrid = new Array(properties_1.mazeProperties.grid.length).fill(0).map(function () { return new Array(properties_1.mazeProperties.grid[0].length).fill(0); });\n    properties_1.mazeProperties.grid[properties_1.mazeProperties.startPos[0]][properties_1.mazeProperties.startPos[1]] = 1;\n    do {\n        frontier.sort(function (a, b) {\n            var a_value = costGrid[a[0]][a[1]] + distance(a, properties_1.mazeProperties.targetPos) * Math.sqrt(2);\n            var b_value = costGrid[b[0]][b[1]] + distance(b, properties_1.mazeProperties.targetPos) * Math.sqrt(2);\n            return a_value - b_value;\n        });\n        var currentCell = frontier[0];\n        var list = (0, common_1.getNeighbours)(currentCell, 1);\n        frontier.splice(0, 1);\n        for (var i = 0; i < list.length; i++) {\n            if ((0, common_1.getNode)(list[i][0], list[i][1]) == 0) {\n                frontier.push(list[i]);\n                properties_1.mazeProperties.grid[list[i][0]][list[i][1]] = i + 1;\n                costGrid[list[i][0]][list[i][1]] = costGrid[currentCell[0]][currentCell[1]] + 1;\n                if (list[i][0] == properties_1.mazeProperties.targetPos[0] && list[i][1] == properties_1.mazeProperties.targetPos[1]) {\n                    found = true;\n                    break;\n                }\n                nodeList.push(list[i]);\n            }\n        }\n    } while (frontier.length > 0 && !found);\n    if (found) {\n        var currentNode = properties_1.mazeProperties.targetPos;\n        while (currentNode[0] != properties_1.mazeProperties.startPos[0] || currentNode[1] != properties_1.mazeProperties.startPos[1]) {\n            switch (properties_1.mazeProperties.grid[currentNode[0]][currentNode[1]]) {\n                case 1:\n                    currentNode = [currentNode[0], currentNode[1] + 1];\n                    break;\n                case 2:\n                    currentNode = [currentNode[0] - 1, currentNode[1]];\n                    break;\n                case 3:\n                    currentNode = [currentNode[0], currentNode[1] - 1];\n                    break;\n                case 4:\n                    currentNode = [currentNode[0] + 1, currentNode[1]];\n                    break;\n                default: break;\n            }\n            pathList.push(currentNode);\n        }\n        pathList.pop();\n        pathList.reverse();\n    }\n    mazeSolversInterval();\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.mazeProperties = exports.finishedGeneration = exports.selectedSolveAlgorithm = exports.selectedGenAlgorithm = exports.initialConfig = exports.pathWidth = exports.gridSizeY = exports.gridSizeX = void 0;\nvar rxjs_1 = require(\"rxjs\");\nexports.gridSizeX = 21;\nexports.gridSizeY = 21;\nexports.pathWidth = 3;\nexports.initialConfig = {\n    gridSizeX: 21,\n    gridSizeY: 21,\n    pathWidth: 3\n};\n/*  Generator algorithms\n*\n*   1 - Randomized depth first\n*   2 - Krusal algorithm\n*   3 - Prim algorithm\n*   4 - Wilson algorithm\n*   5 - Aldous Broder algorithm\n*   6 - Recursive division\n*/\nexports.selectedGenAlgorithm = 2;\n/*  Solver algorithms\n*\n*   1 - Breadth first\n*   2 - Bidirectional breath first\n*   3 - Greedy best first\n*   4 - Dijkstra\n*   5 - A Star\n*/\nexports.selectedSolveAlgorithm = 1;\nexports.finishedGeneration = new rxjs_1.Subject();\nexports.mazeProperties = {\n    grid: undefined,\n    startPos: undefined,\n    targetPos: undefined,\n    isGridClean: true,\n    myInterval: undefined,\n    generating: false,\n    timeouts: [],\n    finishedGrid: undefined,\n    finishedPath: undefined,\n    renderGrid: undefined\n};\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nrequire(\"./maze_generators\");\nrequire(\"./maze_solvers\");\nrequire(\"./init\");\n"],"names":["Observable","ConnectableObservable","observable","animationFrames","Subject","BehaviorSubject","ReplaySubject","AsyncSubject","asap","asapScheduler","async","asyncScheduler","queue","queueScheduler","animationFrame","animationFrameScheduler","VirtualTimeScheduler","VirtualAction","Scheduler","Subscription","Subscriber","Notification","NotificationKind","pipe","noop","identity","isObservable","lastValueFrom","firstValueFrom","ArgumentOutOfRangeError","EmptyError","NotFoundError","Object","ObjectUnsubscribedError","SequenceError","TimeoutError","UnsubscriptionError","bindCallback","bindNodeCallback","combineLatest","concat","connectable","defer","empty","forkJoin","from","fromEvent","fromEventPattern","generate","iif","interval","merge","never","of","onErrorResumeNext","pairs","partition","race","range","throwError","timer","using","zip","scheduled","EMPTY","NEVER","config","audit","auditTime","buffer","bufferCount","bufferTime","bufferToggle","bufferWhen","catchError","combineAll","combineLatestAll","combineLatestWith","concatAll","concatMap","concatMapTo","concatWith","connect","count","debounce","debounceTime","defaultIfEmpty","delay","delayWhen","dematerialize","distinct","distinctUntilChanged","distinctUntilKeyChanged","elementAt","endWith","every","exhaust","exhaustAll","exhaustMap","expand","filter","finalize","find","findIndex","first","groupBy","ignoreElements","isEmpty","last","map","mapTo","materialize","max","mergeAll","flatMap","mergeMap","mergeMapTo","mergeScan","mergeWith","min","multicast","observeOn","onErrorResumeNextWith","pairwise","pluck","publish","publishBehavior","publishLast","publishReplay","raceWith","reduce","repeat","repeatWhen","retry","retryWhen","refCount","sample","sampleTime","scan","sequenceEqual","share","shareReplay","single","skip","skipLast","skipUntil","skipWhile","startWith","subscribeOn","switchAll","switchMap","switchMapTo","switchScan","take","takeLast","takeUntil","takeWhile","tap","throttle","throttleTime","throwIfEmpty","timeInterval","timeout","timeoutWith","timestamp","toArray","window","windowCount","windowTime","windowToggle","windowWhen","withLatestFrom","zipAll","zipWith","_value","_hasValue","_isComplete","_checkFinalizedStatuses","subscriber","this","hasError","thrownError","isStopped","error","next","complete","value","getValue","_subscribe","subscription","closed","_throwIfClosed","kind","hasValue","observe","observer","observeNotification","do","nextHandler","errorHandler","completeHandler","accept","nextOrObserver","isFunction","toObservable","result","TypeError","createNext","createError","err","undefined","createComplete","completeNotification","notification","createNotification","COMPLETE_NOTIFICATION","subscribe","lift","operator","source","observerOrNext","isObserver","isSubscription","SafeSubscriber","errorContext","add","call","_trySubscribe","sink","forEach","promiseCtor","getPromiseCtor","resolve","reject","unsubscribe","pipeFromArray","operations","toPromise","x","create","Promise","_bufferSize","_windowTime","_timestampProvider","dateTimestampProvider","_buffer","_infiniteTimeWindow","Infinity","Math","push","now","_trimBuffer","_innerSubscribe","copy","slice","i","length","adjustedBufferSize","splice","schedulerActionCtor","schedule","work","state","currentObservers","observers","subject","AnonymousSubject","Array","shift","EMPTY_SUBSCRIPTION","arrRemove","asObservable","destination","EMPTY_OBSERVER","handleStoppedNotification","nextNotification","_next","errorNotification","_error","_complete","_bind","Function","prototype","bind","fn","thisArg","partialObserver","handleUnhandledError","useDeprecatedNextContext","ConsumerObserver","useDeprecatedSynchronousErrorHandling","captureError","reportUnhandledError","onStoppedNotification","timeoutProvider","setTimeout","initialTeardown","_parentage","_finalizers","errors","isArray","remove","initialFinalizer","e","finalizer","execFinalizer","teardown","_hasParent","_addParent","parent","includes","_removeParent","onUnhandledError","hasConfig","defaultValue","subjectFactory","_subject","_refCount","_connection","hasLift","getSubject","_teardown","connection","createOperatorSubscriber","callbackFunc","resultSelector","scheduler","bindCallbackInternals","isNodeStyle","isScheduler","apply","args","mapOneOrManyArgs","uninitialized","subs","results","combineLatestInit","observables","valueTransform","maybeSchedule","values","active","remainingFirstValues","hasFirstValue","execute","executeSchedule","popScheduler","popResultSelector","argsArgArrayOrObject","keys","createObject","DEFAULT_CONFIG","connector","resetOnDisconnect","observableFactory","innerFrom","animationFramesFactory","timestampProvider","provider","performanceTimestampProvider","start","id","run","animationFrameProvider","requestAnimationFrame","elapsed","cancelAnimationFrame","DEFAULT_ANIMATION_FRAMES","emptyScheduled","sources","remainingCompletions","remainingEmissions","sourceIndex","input","nodeEventEmitterMethods","eventTargetMethods","jqueryMethods","toCommonHandlerRegistry","target","eventName","methodName","handler","options","addEventListener","removeEventListener","isEventTarget","addListener","removeListener","isNodeStyleEventEmitter","on","off","isJQueryStyleEventEmitter","isArrayLike","subTarget","addHandler","removeHandler","retValue","subscribable","initialStateOrOptions","condition","iterate","resultSelectorOrScheduler","initialState","gen","arguments","scheduleIterable","trueResult","falseResult","fromInteropObservable","obj","obs","fromArrayLike","array","fromPromise","promise","then","fromIterable","iterable","fromAsyncIterable","asyncIterable","process","catch","fromReadableStreamLike","readableStream","readableStreamLikeToAsyncGenerator","isInteropObservable","isPromise","isAsyncIterable","isIterable","isReadableStreamLike","createInvalidObservableTypeError","period","concurrent","popNumber","nextSources","argsOrArgArray","subscribeNext","nextSource","innerSubscriber","OperatorSubscriber","entries","predicate","not","raceInit","subscriptions","s","end","n","errorOrErrorFactory","errorFactory","init","dueTime","intervalOrScheduler","intervalDuration","due","isValidDate","resourceFactory","resource","buffers","completed","some","onNext","onComplete","onError","onFinalize","shouldUnsubscribe","durationSelector","operate","lastValue","durationSubscriber","isComplete","endDuration","cleanupDuration","duration","closingNotifier","currentBuffer","b","bufferSize","startBufferEvery","toEmit","bufferTimeSpan","otherArgs","bufferCreationInterval","maxBufferSize","bufferRecords","restartOnEmit","emit","record","startBuffer","bufferTimeSubscriber","recordsCopy","openings","closingSelector","openValue","closingSubscription","closingSubscriber","openBuffer","selector","handledResult","innerSub","syncUnsub","project","joinAllInternals","otherSources","innerObservable","fromSubscribable","total","activeTask","lastTime","emitWhenIdle","targetTime","delayDurationSelector","subscriptionDelay","index","keySelector","flushes","distinctKeys","Set","key","has","clear","defaultCompare","a","comparator","previousKey","currentKey","compare","y","hasDefaultValue","v","ii","outerValue","mergeInternals","callback","createFind","elementOrOptions","element","groups","Map","notify","cb","handleError","consumer","activeGroups","teardownAttempted","groupBySourceSubscriber","get","set","grouped","groupSubject","groupSubscriber","delete","joinFn","comparer","onBeforeNext","innerSubScheduler","additionalFinalizer","checkComplete","outerNext","doInnerSub","innerComplete","innerValue","bufferedValue","accumulator","seed","subjectOrSubjectFactory","prev","hasPrev","p","properties","Error","currentProp","initialValue","selectorOrScheduler","scanInternals","refCounter","sharedConnection","conn","countOrConfig","sourceSub","soFar","resubscribe","notifier","subscribeToSource","completions$","syncResub","isNotifierComplete","isMainComplete","subscribeForRepeatWhen","configOrCount","resetOnSuccess","subscribeForRetry","errors$","subscribeForRetryWhen","hasSeed","emitOnNext","emitBeforeComplete","hasState","compareTo","aState","bState","isEqual","createSubscriber","selfState","otherState","sequenceEqualSubscriber","handleReset","reset","onSubscriber","resetOnError","resetOnComplete","resetOnRefCountZero","wrapperSource","resetConnection","hasCompleted","hasErrored","cancelReset","resetAndUnsubscribe","dest","configOrBufferSize","singleValue","seenValue","_","skipCount","ring","seen","valueIndex","oldValue","taking","skipSubscriber","innerIndex","outerIndex","inclusive","tapObserver","isUnsub","leading","trailing","sendValue","throttled","endThrottling","send","cleanupThrottling","startThrottle","duration$","defaultErrorFactory","TimeInterval","timeoutErrorFactory","info","createErrorClass","_super","message","name","schedulerArg","each","with","_with","meta","originalSourceSubscription","timerSubscription","startTimer","withObservable","arrReducer","arr","windowBoundaries","windowSubject","windowSize","startWindowEvery","startEvery","windows","c","windowTimeSpan","windowCreationInterval","maxWindowSize","windowRecords","restartOnClose","closeWindow","startWindow","loop","terminate","windowsCopy","openWindow","inputs","len","otherValues","ready","otherInputs","iterator","Symbol","asyncIterator","done","return","scheduleAsyncIterable","scheduleObservable","scheduleArray","schedulePromise","scheduleReadableStreamLike","Action","requestAsyncId","actions","_scheduled","flush","recycleAsyncId","AsyncAction","AnimationFrameAction","action","_active","flushId","AsyncScheduler","AnimationFrameScheduler","immediateProvider","setImmediate","clearImmediate","AsapAction","AsapScheduler","pending","_id","intervalProvider","setInterval","_scheduler","clearInterval","_execute","_delay","errorValue","errored","SchedulerAction","QueueAction","QueueScheduler","maxFrames","frame","frameTimeFactor","Number","isFinite","sort","sortActions","request","cancel","delegate","handle","Date","Immediate","performance","clearTimeout","getSymbolIterator","resolved","nextHandle","activeHandles","findAndClearHandle","TestTools","toString","join","pop","getPrototypeOf","objectProto","getKeys","item","indexOf","createImpl","ctorFunc","instance","stack","constructor","context","isRoot","errorThrown","parentSubscription","scheduleSubscription","isNaN","reader","getReader","read","releaseLock","liftedSource","callOrApply","pred","fns","defineProperty","exports","getNeighbours","getNode","clearGrid","removeWall","addWall","properties_1","mazeProperties","grid","isGridClean","timeouts","myInterval","j","cell","distance","convertirLaberinto","maze","pathWidth","newMaze","originalWidth","originalHeight","newWidth","newHeight","i2","j2","__awaiter","_arguments","P","generator","fulfilled","step","rejected","__generator","body","f","t","g","label","sent","trys","ops","verb","op","generateMazeAndSolution","rxjs_1","maze_generators_1","gridSizeX","gridSizeY","_a","initialConfig","fill","startPos","targetPos","maze_generators","finishedGeneration","console","log","JSON","parse","stringify","onload","common_1","conversor_1","maze_solvers_1","finishGenerate","finishedGrid","renderGrid","maze_solvers","randomInt","ceil","floor","random","generating","selectedGenAlgorithm","currentCell","neighbours","list","chosen_cell","randomized_depth_first","fillWalls","nb_areas","wall_list","cell_pair","wall","kruskal_algorithm","first_cell","new_cell","valid","list_1","primAlgorithm","cell_list","random_walk","first_step","new_way_list","next_cell","wilson_algorithm","cells_nb","aldousBroderAlgorithm","enclose","time","subRecursiveDivision","x_min","y_min","x_max","y_max","y_1","_loop_1","x_1","_loop_2","recursiveDivision","nodeList","nodeListIndex","pathList","pathListIndex","found","path","point_1","point_2","sqrt","pow","mazeSolversInterval","finishedPath","breadthFirst","frontier","currentNode","reverse","selectedSolveAlgorithm","start_end","target_end","targets","starts","bidirectional_breadthFirst","greedyBestFirst","costGrid","aStar","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","module","__webpack_modules__"],"sourceRoot":""}